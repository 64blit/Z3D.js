import * as l from "https://unpkg.com/three/build/three.module.js";
import { GLTFLoader as H } from "https://unpkg.com/three@0.149.0/examples/jsm/loaders/GLTFLoader.js";
import { DRACOLoader as Z } from "https://unpkg.com/three@0.149.0/examples/jsm/loaders/DRACOLoader.js";
import { RGBELoader as W } from "https://unpkg.com/three@0.149.0/examples/jsm/loaders/RGBELoader.js";
import { EXRLoader as G } from "https://unpkg.com/three@0.149.0/examples/jsm/loaders/EXRLoader.js";
import { UnrealBloomPass as F } from "https://unpkg.com/three@0.149.0/examples/jsm/postprocessing/UnrealBloomPass.js";
import { RenderPass as N } from "https://unpkg.com/three@0.149.0/examples/jsm/postprocessing/RenderPass.js";
import { EffectComposer as U } from "https://unpkg.com/three@0.149.0/examples/jsm/postprocessing/EffectComposer.js";
import "https://unpkg.com/three@0.149.0/examples/jsm/postprocessing/ShaderPass.js";
import "https://unpkg.com/three@0.149.0/examples/jsm/shaders/FXAAShader.js";
import "https://cdn.jsdelivr.net/npm/camera-controls/dist/camera-controls.min.js";
const i = p;
(function(g, t) {
  const e = p, x = g();
  for (; []; )
    try {
      if (parseInt(e(544)) / 1 + parseInt(e(697)) / 2 + parseInt(e(585)) / 3 + parseInt(e(782)) / 4 + parseInt(e(728)) / 5 * (-parseInt(e(555)) / 6) + parseInt(e(708)) / 7 + -parseInt(e(749)) / 8 === t)
        break;
      x.push(x.shift());
    } catch {
      x.push(x.shift());
    }
})(E, 657077);
function p(g, t) {
  const e = E();
  return p = function(x, s) {
    return x = x - 473, e[x];
  }, p(g, t);
}
function E() {
  const g = ["clientY", "set", "wrapScene", "isOverlayActive", "_hovered", "aspect", "getAnimationTrack", "clipAction", "updatePointer", "interactable", "filmOffset", ".z3d-close", "azimuthAngle", "getInteractableModelsByZone", "enableAll", "smoothTime", "mapping", "2475096lhIFpZ", "DEBUG", "install", "setDynamicHTML", "fps", "closeDynamicContent", "polarAngle", "player", "activeZoneIndex", "toneMappingExposure", "raycastTarget", "497084pWvxRs", "gyro", "getModel", "restThreshold", "onHover", "setDecoderPath", "Vector2", "type", "iframe not found. Make sure this returns the correct element: document.getElementById(", "innerWidth", "background", "getBackgroundModelsByZone", "processModel", "gammaFactor", "deactivate", "touchend", "EventDispatcher", "scene", "getAnimation", "BackSide", "120jNIkEd", "getRaycastTarget", "getAnimations", "exr", "onhashchange", "shadowMap", "model", "getSceneZoneByName", "z3d-visible", "zoomTo", "map", "minStaticFrames", "hdr", "fromEquirectangular", "addHDR", "rotationTarget", "top", "changeSceneZoneByName", '<div id="z3d-close-btn" class="z3d-close-btn"><span>âœ•</span', "sub", "ACTION", "27105808wINmVF", "backgroundBlurriness", "click", "innerHTML", "PerspectiveCamera", "nextScene", "wrappedAnimations", "receiveShadow", "onHoverOff", "texture", "lights", "intensity", "expandByObject", "multiplyScalar", "Missing raycast target for: ", "controls", "getRandomRange", "An error happened ", "test", "reset", "MAX_SAFE_INTEGER", "onPointerDown", "animations", "setModelMatrixData", "cameraParams", "removeEventListener", "material", "activeSceneZone", "onHoverOffCallback", "Box3", "changeCameraZone", "showLoadingScreen", "lookAtTargetSize", "3866848omlxQr", "openLink", "minPolarAngle", "toneMapping", "Clock", "minAzimuthAngle", '<iframe id="z3d-fullscreen" src="', "userAgent", "size", "setDynamicContent", "index", "getSceneZoneByIndex", "push", "tiltYArr", "total", "resetControlsLimits", "target", "innerHeight", "tiltY", "orbitCameraTo", "Raycaster", "setupCamera", "forEach", "onHoverOverCallback", "length", "all", "onClick", "pointer", "loadJson", "getSceneWrapper", "loadingScreenID", "wrappedSceneZones", "nextSceneZone", "fitCameraToZone", "play", "querySelector", "Object3D", "looping", "strength", "parse", "lookAtTarget", "zone", "PointLight", "createLightContainer", "setFromCamera", "jsonPath", "camera", "loadingScreen", "round", "pointerdown", "load", "setSize", "getSize", "interactables", "values", ":>> GLTF element unrecognized:", "radius", "zeroSlopeAtStart", "_intersections", "followMouse", "_selected", "loopAnimations", "bind", "defaultRotationDistance", "getDelta", "onHoverAnimations", "setInputActive", "ROTATE", "log", "max", "setupRaycaster", "getPlayer", "start", "clone", "maxAzimuthAngle", "changeSceneZoneByIndex", "models", "light", "resize", "setPaused", "gltfLoader", "Canvas not found. Make sure this returns the correct element: document.GetElementByID(", "Vector3", "bloomParams", "active", "activate", "getRenderer", "userData", "scale", "getCameraBoundsObject", "update", "average", "boxCenter", "jsonData", "AnimationMixer", "iframe", "lookAtTargetBox", "gltf", "tiltXArr", "currentAction", "WebGLRenderer", "dispatchEvent", "right", "pushState", "enabled", "onHoverOver", "pow", "buttonZone", "scrollHeight", "modelName", "onPointerMove", "addPointLight", "onClickAnimations", "Cache", "back", "intersectObjects", "then", "renderer", "maxGyroSignals", "_objects", "buttonNextZone", "intersectableObjects", "visibleSelector", "maxDistance", "onUpdate", "init", "contentType", "getHtmlData", "scrollWidth", "getScene", "addDirectionalLight", "build", ");  ", "fov", "threshold", "contentContainer", "bgMesh", "width", "fitCameraOffset", "canvas", "normalBias", "addGLTFModel", "wrappedModels", '"></iframe>', "name", "1270669LQXfMp", "maxZoom", "touches", "content", "zoneBox", "ambientLight", "spot", "high-performance", "bloomPass", "getWrappedAnimations", "Scene", "123126CTVjSm", "setupRenderer", "iframeID", "getCamera", "domElements", "mouseup", "The gryto motion sensor is not supported on this device.", "finalComposer", "pointLight", "addEXR", "showDynamicHTML", "getAnimationsFromCSV", "left", "pen", "cameraAnimations", "beforeend", "environment", "compileEquirectangularShader", "updateSceneZones", "DirectionalLight", "createModelContainer", "pointerType", "postEffects", "add", "_domElement", "_camera", "directionalLight", "gltf children :>> ", "fill", "getHitObject", "2975598HXPSir", "pop", "two", "position", "classList", "hash", "setLoop", "LoopOnce", "raycastManager", "paused", "lookAt", "onPointerDownCallback", "rotateTo", "raycastMesh", "setLookAt", "cursor", "element", "onPointerUp", "auto", "dispose", "object", "distance", "frame", "sceneWrapper", "getIntersectableObjects", "saveState", "side", "exposure", "getObjects", "Camera", "hiddenSelector", "setupGyro", "history", "z3d-hidden", "getBoundingBox", "castShadow", "rotateCamera", "loadModel", "getLoopingAnimations", "pointerDownCallback", "getHtml", "updateProjectionMatrix", "color", "reading", "includes", "hoveron", "pointermove", "tiltX", "onProgressLoading", "hoverOffCallback", "getInteractableObject", "interactablesContent", "addLighting", "render", "lerp", "addAmbientLight", "height", "AmbientLight", "halfWindowWidth", "addDynamicCloseButton", "children", "random", "zeroSlopeAtEnd", "resetCamera", "backgroundIntensity", "setupPostEffects", "split", "clientX", "getInteractablesByZone", "isMobileDevice", "moveCamera", "hoverOverCallback", "addPass", "atan", "ReinhardToneMapping", "error", "duration", "normalize", "PointLightHelper", "getElementById", "isPostEffectsEnabled", "AxesHelper", "style", "insertAdjacentHTML", "addEventListener", "quaternionToVector3", "pushHashURL", "remove", "getCameraAnimationStart", "tracks", "rotation", "maxPolarAngle", "onWindowResized", "Group", "bloom"];
  return E = function() {
    return g;
  }, E();
}
class P {
  static [i(765)](t, e) {
    return Math[i(646)]() * (e - t) + t;
  }
  static getRandomIntRange(t, e) {
    const x = i;
    return Math[x(830)](Math[x(646)]() * (e - t) + t);
  }
  static [i(670)](t, e, x, s) {
    const a = t + t, n = e + e, o = x + x, c = t * n, d = t * o, u = e * o, f = s * a, w = s * n, v = s * o;
    return { x: c - v, y: u + f, z: d - w };
  }
  static [i(738)](t, e, x, s, a) {
    return (t - e) * (a - s) / (x - e) + s;
  }
  static [i(490)](t) {
    const e = i;
    let x = 0;
    return t[e(804)]((s) => {
      x += s;
    }), x / t[e(806)];
  }
}
class q {
  constructor(t, e, x) {
    const s = i;
    this[s(771)] = x, this.models = t, this[s(759)] = e, this.wrappedModels = { interactables: [], bg: [], player: null }, this.wrappedAnimations = { looping: [], onClick: [], onHover: [], camera: [] }, this[s(813)] = [], this[s(682)](this[s(475)]), this.updateSceneZones(this[s(813)]);
  }
  wrapScene(t) {
    const e = i, x = { interactables: [], bgMesh: [], player: null }, s = [];
    for (let a = 0; a < t[e(806)]; a++) {
      const n = t[a], o = n[e(734)].userData;
      let c = {};
      const d = this[e(730)](o, n[e(543)]);
      switch (o[e(715)]) {
        case e(689):
          c = this[e(635)](n, o, d), x.interactables[e(794)](c);
          break;
        case "cameraBounds":
          c = this[e(488)](n, o), s[e(794)](c);
          break;
        case e(535):
          x[e(535)].push(n[e(734)]);
          break;
        case e(598):
          x[e(535)][e(794)](n[e(734)]);
          break;
        case e(704):
          x.player = n[e(734)];
          break;
      }
    }
    this[e(541)] = x, this[e(813)] = s;
  }
  [i(573)](t) {
    const e = i, x = [...t];
    for (let s = 0; s < x[e(806)]; s++) {
      const a = x[s], n = a.position, o = this[e(693)](a[e(823)]);
      o[e(806)] <= 0 && this.getBackgroundModelsByZone(a[e(823)])[e(804)]((w) => {
        o[e(794)](w);
      });
      const c = this[e(619)](o), d = new l[e(481)]();
      c.getCenter(d);
      const u = new l[e(481)]();
      c[e(834)](u), x[s][e(491)] = n, x[s][e(495)] = c, x[s].lookAtTargetSize = u, x[s].lookAtTarget = d;
    }
    this[e(813)] = x;
  }
  [i(793)](t) {
    const e = i;
    let x = null;
    return this.wrappedSceneZones[e(804)]((s) => {
      s.index === t && (x = s);
    }), x;
  }
  [i(735)](t) {
    const e = i;
    let x = null, s = null;
    return this[e(813)][e(804)]((a) => {
      a.zone === t && (x = a);
    }), { zoneBox: x, index: s };
  }
  [i(623)]() {
    const t = i, e = { looping: [] };
    return this[t(755)][t(819)].forEach((x) => {
      const s = t;
      x.animations[s(804)]((a) => {
        const n = s;
        e[n(819)][n(794)](a);
      });
    }), e;
  }
  [i(553)]() {
    return this.wrappedAnimations;
  }
  [i(853)]() {
    const t = i;
    return this[t(541)][t(704)];
  }
  getInteractables() {
    const t = i;
    return this[t(541)][t(835)];
  }
  [i(653)](t) {
    const e = i, x = [];
    for (let s = 0; s < this[e(541)][e(835)][e(806)]; s++) {
      const a = this[e(541)][e(835)][s];
      a.zone === t && x[e(794)](a);
    }
    return x;
  }
  getInteractableModelsByZone(t) {
    const e = i, x = [];
    for (let s = 0; s < this[e(541)][e(835)][e(806)]; s++) {
      const a = this.wrappedModels[e(835)][s];
      a[e(823)] === t && x[e(794)](a[e(601)][e(734)]);
    }
    return x;
  }
  [i(719)](t) {
    const e = i, x = [];
    for (let s = 0; s < this[e(541)][e(535)][e(806)]; s++) {
      const a = this[e(541)].bgMesh[s];
      a[e(715)] === "Group" ? a[e(645)][e(804)]((n) => {
        const o = e;
        a.userData[o(823)] === t && x.push(n);
      }) : a[e(486)].zone === t && x.push(a);
    }
    return x;
  }
  getBoundingBox(t) {
    const e = i, x = new l[e(778)]();
    t.type === e(678) && (t = [...t[e(645)]]);
    for (let s = 0; s < t.length; s++) {
      const a = t[s];
      x[e(761)](a);
    }
    return x;
  }
  [i(710)](t) {
    const e = i;
    for (let x = 0; x < this.models[e(806)]; x++) {
      const s = this.models[x][e(734)];
      if (s[e(543)] === t)
        return s;
    }
    return null;
  }
  getAnimation(t) {
    const e = i;
    for (let x = 0; x < this.animations[e(806)]; x++) {
      const s = this.animations[x];
      if (s[e(543)] === t)
        return s;
    }
    return null;
  }
  [i(566)](t) {
    const e = i, x = t[e(651)](","), s = [];
    for (let a = 0; a < x[e(806)]; a++) {
      const n = x[a];
      s.push(this[e(726)](n));
    }
    return s;
  }
  [i(686)](t, e) {
    const x = i;
    for (let s = 0; s < t[x(674)][x(806)]; s++)
      if (t[x(674)][s][x(543)] === e)
        return t[x(674)][s];
    return null;
  }
  [i(673)](t) {
    const e = i, x = { position: null, rotation: null };
    for (let s = 0; s < t.camera[e(806)]; s++) {
      const a = t[e(828)][s];
      for (let n = 0; n < a[e(674)].length; n++) {
        const o = a[e(674)][n];
        if (o[e(543)][e(629)](".position"))
          x[e(588)] = new l[e(481)](o[e(836)][0], o[e(836)][1], o[e(836)][2]);
        else if (o[e(543)][e(629)](".quaternion")) {
          const c = new l.Quaternion(o[e(836)][0], o.values[1], o[e(836)][2], o.values[3]);
          x[e(675)] = c;
        }
      }
    }
    return x;
  }
  [i(730)](t, e) {
    const x = i;
    let s = null, a = null, n = null, o = null;
    return "loopAnimations" in t && (s = this[x(566)](t[x(843)]), this.wrappedAnimations.looping[x(794)]({ name: e, animations: s })), x(511) in t && (a = this[x(566)](t[x(511)]), this[x(755)][x(808)].push({ name: e, animations: a })), x(847) in t && (n = this[x(566)](t.onHoverAnimations), this[x(755)][x(712)][x(794)]({ name: e, animations: n })), "cameraAnimations" in t && (o = this[x(566)](t[x(569)]), this[x(755)][x(828)][x(794)]({ name: e, animations: o })), { loopAnimations: s, onHoverAnimations: n, onClickAnimations: a, cameraAnimations: o };
  }
  getInteractableObject(t, e, x) {
    const s = i, a = this[s(729)](e[s(707)]), n = { name: t[s(543)], raycastTarget: a, element: t, animations: {}, zone: e[s(823)] };
    return x[s(847)] !== null && (n[s(771)][s(712)] = x[s(847)]), x.onClickAnimations !== null && (n[s(771)].onClick = x[s(511)]), x.cameraAnimations !== null && (n[s(771)].camera = x[s(569)]), n;
  }
  getCameraBoundsObject(t, e) {
    const x = i, s = { zone: e[x(823)], index: parseInt(e[x(792)], 10), position: t.model[x(588)] };
    return t[x(734)].visible = ![], s;
  }
  getRaycastTarget(t) {
    const e = i, x = this[e(710)](t);
    return x == null ? (console[e(850)](e(763), t), null) : (x[e(775)][e(611)] = l[e(727)], x[e(775)].visible = ![], x);
  }
}
class X {
  async [i(821)](t) {
    const e = i;
    let x = null;
    return await fetch(t)[e(515)]((s) => s.json())[e(515)]((s) => {
      x = s;
    }), x;
  }
}
class V {
  constructor(t, e, x) {
    const s = i;
    this.scene = t, this[s(516)] = e, this[s(827)] = x, this[s(608)];
    const a = new Z();
    if (a[s(713)]("https://unpkg.com/three@0.147.0/examples/js/libs/draco/"), this.gltfLoader = new H(), this.gltfLoader.setDRACOLoader(a), window[s(698)]) {
      const n = new l[s(666)](5e3);
      this.scene[s(578)](n);
    }
  }
  [i(811)]() {
    return this[i(608)];
  }
  async [i(810)]() {
    const t = i;
    return await new X()[t(821)](this.jsonPath);
  }
  async [i(530)](t) {
    const e = i, x = await this[e(810)](), s = [], a = [], n = await this.addGLTFModel(x.models, t), o = this.addLighting(x[e(759)]);
    return o[e(794)](...n[e(759)]), s.push(...n.models), a[e(794)](...n.animations), this[e(608)] = new q(s, o, a), this[e(608)];
  }
  async [i(540)](t, e) {
    const x = i, s = [], a = [], n = [];
    for (let o = 0; o < t[x(806)]; o++) {
      const c = t[o], d = function(u) {
        const f = x;
        e(o + 1, t.length, 100 * u.loaded / u[f(796)]);
      };
      await this.loadModel(c, d)[x(515)]((u) => {
        const f = x;
        window[f(698)] && console[f(850)](f(582), [...u.gltf[f(725)][f(645)]]);
        const w = this[f(720)](u);
        s[f(794)](...w[f(475)]), a[f(794)](...w[f(759)]), n.push(...w[f(771)]);
      });
    }
    return { models: s, lights: a, animations: n };
  }
  [i(710)](t, e) {
    const x = i;
    for (let s = 0; s < t[x(806)]; s++) {
      const a = t[s];
      if (a[x(543)] === e)
        return a;
    }
    return null;
  }
  [i(575)](t, e) {
    const x = i, s = { name: t.name, model: t };
    switch (this[x(772)](t, e), t[x(620)] = e.castShadow, t[x(756)] = e.receiveShadow, t.userData.type) {
      case x(535):
        break;
      case x(689):
        const a = this[x(625)](e, t[x(543)]);
        s[x(525)] = a[x(715)], s[x(547)] = a[x(547)];
        break;
    }
    return s;
  }
  [i(825)](t, e) {
    return { type: t, light: e };
  }
  [i(720)](t) {
    const e = i, x = [...t.gltf[e(725)].children], s = t[e(496)][e(771)], a = [], n = [], o = 1e5;
    for (let c = 0; c < x.length; c++) {
      const d = x[c];
      switch (d.layers[e(694)](), d[e(715)]) {
        case "Mesh":
          a[e(794)](this[e(575)](d, t[e(492)]));
          break;
        case e(678):
          d.children[e(804)]((u) => {
            this[e(772)](u, t.jsonData);
          }), a.push(this.createModelContainer(d, t[e(492)]));
          break;
        case e(818):
          a.push(this.createModelContainer(d, t.jsonData));
          break;
        case e(824):
          d[e(760)] /= o, n[e(794)](this.createLightContainer("point", d));
          break;
        case e(574):
          d[e(760)] /= o, n.push(this[e(825)]("directional", d));
          break;
        case "SpotLight":
          d[e(760)] /= o, n[e(794)](this[e(825)](e(550), d));
          break;
        default:
          console[e(850)](e(837), d);
          break;
      }
      this[e(725)].add(d);
    }
    return { models: a, lights: n, animations: s };
  }
  [i(772)](t, e) {
    const x = i;
    t[x(588)].set(t[x(588)].x + e.position.x, t[x(588)].y + e[x(588)].y, t[x(588)].z + e.position.z), t.quaternion[x(681)](e[x(675)].x, e[x(675)].y, e[x(675)].z, e[x(675)].w), t.scale.set(e[x(487)].x, e.scale.y, e.scale.z);
  }
  [i(625)](t, e) {
    const x = i, s = this[x(526)](t, e);
    if (s[x(547)] !== void 0)
      return s.type === x(494) && (s[x(547)] = x(788) + s[x(547)] + x(542)), s;
  }
  [i(526)](t, e) {
    const x = i, s = t[x(636)];
    for (let a = 0; a < s[x(806)]; a++) {
      const n = s[a];
      if (n[x(508)] === e)
        return n;
    }
    return null;
  }
  async [i(622)](t, e) {
    return new Promise((x) => {
      const s = p;
      return this[s(479)][s(832)](".." + t.path, function(a) {
        x({ gltf: a, jsonData: t });
      }, e, function(a) {
        const n = s;
        console[n(850)](n(766) + a);
      });
    });
  }
  [i(637)](t) {
    const e = i, x = [];
    for (let s = 0; s < t.length; s++) {
      const a = t[s];
      let n, o;
      const c = { type: null, light: null };
      switch (a[e(715)]) {
        case e(740):
          this[e(742)](a.path, a[e(649)], a[e(750)]);
          break;
        case e(731):
          this.addEXR(a.path, a[e(649)], a[e(750)]);
          break;
        case e(563):
          n = new l[e(481)](a[e(588)].x, a[e(588)].y, a[e(588)].z), o = this[e(510)](n, a[e(627)], a[e(760)], a[e(790)], a.castShadow), c[e(715)] = "pointLight", c[e(476)] = o;
          break;
        case e(581):
          n = new l[e(481)](a[e(588)].x, a[e(588)].y, a[e(588)].z);
          const d = new l[e(481)](a.target.x, a[e(798)].y, a[e(798)].z);
          o = this.addDirectionalLight(n, d, a[e(627)], a.intensity, a[e(620)]), c[e(715)] = "directionalLight", c.light = o;
          break;
        case e(549):
          o = this[e(640)](a.color, a[e(760)]), c[e(715)] = e(549), c[e(476)] = o;
          break;
      }
      x.push(c);
    }
    return x;
  }
  [i(510)](t, e = 0, x = 1, s = 1500, a = ![]) {
    const n = i, o = new l[n(824)](e, x, s);
    if (o[n(588)][n(639)](t, 1), o[n(620)] = a, o[n(539)] = 0.1, this[n(725)][n(578)](o), window[n(698)]) {
      const c = new l[n(663)](o, 0.25);
      this[n(725)][n(578)](c);
    }
    return o;
  }
  [i(640)](t = 0, e = 1) {
    const x = i, s = new l[x(642)](t, e);
    return this[x(725)][x(578)](s), s;
  }
  [i(529)](t, e = new l.Vector3(0, 0, 0), x = 16777215, s = 2, a = ![]) {
    const n = i, o = new l[n(574)](x, s);
    if (o.position[n(639)](t, 1), o[n(798)][n(588)][n(639)](e, 1), o.castShadow = a, o[n(539)] = 0.1, this.scene[n(578)](o), this[n(725)][n(578)](o.target), window[n(698)]) {
      const c = new l.DirectionalLightHelper(o);
      this[n(725)][n(578)](c);
    }
    return o;
  }
  addHDR(t, e, x) {
    const s = i, a = new l.PMREMGenerator(this[s(516)]);
    a[s(572)]();
    let n;
    new W()[s(832)](".." + t, (o) => {
      const c = s;
      n = a[c(741)](o)[c(758)], this[c(725)][c(571)] = n, this[c(725)][c(718)] = n, this.scene.backgroundIntensity = e, this.scene[c(750)] = x, o.dispose(), a[c(604)]();
    });
  }
  [i(564)](t, e, x) {
    const s = i, a = new l.PMREMGenerator(this[s(516)]);
    a.compileEquirectangularShader();
    let n;
    new G()[s(832)](".." + t, (o) => {
      const c = s;
      o[c(696)] = l.EquirectangularReflectionMapping, n = a[c(741)](o)[c(758)], this[c(725)][c(571)] = n, this[c(725)][c(718)] = n, this.scene[c(649)] = e, this[c(725)][c(750)] = x, o.dispose(), a.dispose();
    });
  }
}
class Y {
  constructor(t, e) {
    const x = i;
    l[x(512)].enabled = !![], this[x(538)] = document[x(664)](t), !this.canvas && console[x(660)](x(480), t, x(531)), this.cameraParams = e, this.bloomParams = e[x(577)][x(679)], this[x(536)] = this[x(538)].scrollWidth, this.height = this.canvas[x(507)], this[x(828)] = new l[x(753)](this[x(773)].fov, this[x(536)] / this.height, 0.1, 1e4), this[x(828)][x(543)] = x(614), this[x(725)] = new l[x(554)](), this.renderer, this[x(562)], this[x(552)], this[x(665)] = e[x(577)][x(503)], this[x(556)](), this[x(665)] && this.setupPostEffects();
  }
  [i(558)]() {
    return this.camera;
  }
  [i(528)]() {
    return this[i(725)];
  }
  getRenderer() {
    return this[i(516)];
  }
  [i(556)]() {
    const t = i;
    this.renderer = new l[t(499)]({ canvas: this.canvas, antialias: !![], powerPreference: t(551), failIfMajorPerformanceCaveat: !![] }), this.renderer[t(733)][t(503)] = !![], this[t(828)].layers[t(694)](), this[t(516)][t(833)](this[t(536)], this[t(641)]), this.renderer[t(785)] = l[t(659)], this[t(516)][t(706)] = Math[t(505)](this[t(482)][t(612)], 4), this[t(516)][t(721)] = 4;
  }
  [i(650)]() {
    const t = i, e = new N(this.scene, this[t(828)]), x = new F(new l[t(714)](this[t(536)], this.height), this[t(482)][t(820)], this.bloomParams[t(838)], this[t(482)][t(533)]);
    x[t(612)] = this[t(482)][t(612)], x[t(533)] = this[t(482)][t(533)], x[t(820)] = this[t(482)][t(820)], x.radius = this.bloomParams[t(838)], this[t(562)] = new U(this[t(516)]), this.finalComposer.setSize(this.width, this[t(641)]), this[t(562)][t(657)](e), this[t(562)].addPass(x);
  }
  [i(677)]() {
    const t = i;
    this.width = this[t(538)][t(527)], this[t(641)] = this.canvas.scrollHeight, this[t(828)][t(685)] = this[t(536)] / this[t(641)], this[t(828)].updateProjectionMatrix(), this[t(516)][t(833)](this[t(536)], this.height), this[t(665)] && this[t(562)][t(833)](this.width, this[t(641)]);
  }
  [i(768)]() {
    this.onWindowResized();
  }
  [i(638)]() {
    const t = i;
    this[t(665)] ? this[t(562)][t(638)]() : this[t(516)].render(this.scene, this[t(828)]);
  }
}
const L = new l[i(802)]();
class Q extends l[i(724)] {
  constructor(t, e, x) {
    const s = i;
    super(), this[s(518)] = t, this._camera = e, this[s(579)] = x, this[s(842)] = null, this[s(684)] = null, this[s(840)] = [], this[s(701)] = 30, this[s(503)] = !![], this.transformGroup = ![], this.halfWindowWidth = window[s(717)] / 2, this[s(643)] = window[s(799)] / 2, this[s(607)] = 0, this[s(739)] = this.fps, this.intersectableObjects = this[s(609)](this[s(518)]), this[s(809)] = new l[s(714)](), this.onPointerMove = (a) => {
      const n = s;
      if (this[n(503)] !== ![] && (this.frame += 1, this.frame > Number[n(769)] && (this[n(607)] = 0), this[n(688)](a), L[n(826)](this[n(809)], this._camera), this[n(520)] == null && (this.intersectableObjects = getIntersectableObjects(this._objects)), a.pointerType === "mouse" || a[n(576)] === n(568) || a.pointerType === "touch"))
        if (this[n(840)][n(806)] = 0, L.setFromCamera(this[n(809)], this[n(580)]), L[n(514)](this[n(520)], ![], this[n(840)]), this[n(840)][n(806)] > 0) {
          let o = this[n(840)][0][n(605)];
          o = this[n(584)](o[n(543)]), this[n(684)] !== o && this._hovered !== null && (this[n(500)]({ type: "hoveroff", object: this[n(684)] }), this._domElement.style[n(600)] = n(603), this[n(684)] = null), this[n(684)] !== o && (this[n(500)]({ type: n(630), object: o }), this[n(579)][n(667)][n(600)] = "pointer", this[n(684)] = o);
        } else
          this[n(684)] !== null && (this[n(500)]({ type: "hoveroff", object: this[n(684)] }), this[n(579)][n(667)][n(600)] = "auto", this[n(684)] = null);
    }, this.onPointerUp = (a) => {
      const n = s;
      if (this.enabled !== ![] && !(typeof a === TouchEvent && a[n(546)][n(806)] > 1)) {
        if (this[n(607)] > Math.min(this.fps * 2, 20)) {
          this[n(607)] = 0;
          return;
        }
        if (this[n(607)] = 0, (this[n(520)] == null || this.intersectableObjects == null) && (this[n(520)] = getIntersectableObjects(this[n(518)])), this[n(579)][n(667)].touchAction = "none", this[n(688)](a), this[n(840)].length = 0, L[n(826)](this.pointer, this._camera), L[n(514)](this[n(520)], ![], this._intersections), this._intersections.length > 0) {
          const o = this[n(840)][0][n(605)];
          this[n(842)] = this.getHitObject(o[n(543)]), this.dispatchEvent({ type: n(831), object: this[n(842)] }), this[n(684)] = this._selected;
        }
      }
    }, this[s(484)]();
  }
  [i(484)]() {
    const t = i;
    this[t(579)][t(669)]("pointermove", this.onPointerMove), this[t(579)].addEventListener(t(723), this[t(602)]), this[t(579)].addEventListener(t(560), this[t(602)]);
  }
  [i(722)]() {
    const t = i;
    this._domElement.removeEventListener(t(631), this[t(509)]), this[t(579)][t(774)](t(723), this[t(602)]), this[t(579)][t(774)](t(560), this.onPointerUp), this[t(579)][t(667)][t(600)] = "";
  }
  updatePointer(t) {
    const e = i, x = this._domElement.getBoundingClientRect();
    this[e(809)].x = (t[e(652)] - x[e(567)]) / x[e(536)] * 2 - 1, this[e(809)].y = -(t[e(680)] - x[e(744)]) / x.height * 2 + 1;
  }
  [i(604)]() {
    this.deactivate();
  }
  [i(613)]() {
    return this[i(518)];
  }
  getIntersectableObjects(t) {
    const e = i, x = [];
    for (let s = 0; s < t[e(806)]; s++) {
      const a = t[s];
      x[e(794)](a[e(707)]);
    }
    return x;
  }
  [i(584)](t) {
    const e = i;
    for (let x = 0; x < this._objects[e(806)]; x++) {
      const s = this[e(518)][x];
      if (s[e(707)][e(543)] === t)
        return s;
    }
    return null;
  }
}
class J {
  constructor(t, e) {
    const x = i;
    CameraControls[x(699)]({ THREE: t }), this[x(503)] = !![], this.paused = ![], this[x(593)], this[x(764)], this[x(828)], this.targetPosition, this[x(624)], this[x(608)], this[x(776)], this.defaultDampFactor = 0.05, this[x(845)] = 0.05, this[x(773)] = e, this[x(705)] = 0, this[x(632)] = 0, this[x(800)] = 0, this[x(517)] = 512, this[x(497)] = new Array(this[x(517)])[x(583)](0), this[x(795)] = new Array(this.maxGyroSignals).fill(0), this[x(654)] = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i[x(767)](navigator[x(789)]), this[x(537)] = this[x(654)] ? 1.5 : 3, this[x(743)] = new l[x(714)]();
  }
  init(t, e, x, s, a, n) {
    const o = i;
    this[o(516)] = t, this[o(828)] = e, this.sceneWrapper = x, this.pointerDownCallback = s, this[o(656)] = a, this[o(634)] = n, this[o(776)] = this[o(608)].getSceneZoneByIndex(this[o(705)]), this[o(616)](), this[o(803)](), this.setupRaycaster(), this[o(648)]();
  }
  [i(616)]() {
    const t = i;
    if (this[t(773)][t(709)])
      try {
        let e = new Gyroscope({ frequency: 15 });
        e.addEventListener(t(628), (x) => {
          const s = t;
          this[s(497)].push(e.y * 2), this[s(795)].push(e.x * 2), this[s(632)] = P[s(490)](this[s(497)]), this.tiltY = P[s(490)](this[s(795)]), this[s(497)].length > this[s(517)] && (this[s(497)].pop(), this[s(795)][s(586)]());
        }), e[t(854)]();
      } catch (e) {
        console.log(t(561), e);
      }
  }
  [i(803)]() {
    const t = i;
    this[t(828)][t(588)][t(639)](this.activeSceneZone[t(491)], 1), this[t(828)][t(595)](this[t(776)][t(822)]), this[t(815)](this.fitCameraOffset), this[t(764)] && this[t(764)][t(604)](), this[t(764)] = new CameraControls(this[t(828)], this[t(516)].domElement), this.controls[t(711)] = 0.1, this[t(797)]();
  }
  resetControlsLimits() {
    const t = i;
    this.cameraParams.orbit !== !![] && (this[t(764)].mouseButtons[t(501)] = CameraControls[t(748)][t(849)], this.controls[t(546)][t(587)] = CameraControls[t(748)].TOUCH_ZOOM, this[t(764)][t(473)] = this[t(764)][t(692)] + this[t(845)], this[t(764)][t(787)] = this.controls.azimuthAngle - this.defaultRotationDistance, this[t(764)][t(676)] = this[t(764)][t(703)] + this[t(845)], this[t(764)][t(784)] = this[t(764)].polarAngle - this[t(845)], this[t(764)][t(522)] = this[t(764)].distance * 2, this[t(764)][t(545)] = this[t(764)][t(606)] * 2, this[t(743)] = new l[t(714)](this[t(764)][t(692)], this[t(764)].polarAngle));
  }
  [i(852)]() {
    const t = i;
    this[t(593)] && this[t(593)][t(604)]();
    const e = this.sceneWrapper[t(653)](this[t(776)].zone);
    this[t(593)] = new Q(e, this.camera, this[t(516)].domElement), this[t(593)].addEventListener(t(831), this.onPointerDown[t(844)](this)), this[t(593)][t(669)](t(630), this.onHoverOver[t(844)](this)), this.raycastManager[t(669)]("hoveroff", this.onHoverOff[t(844)](this));
  }
  [i(814)]() {
    const t = i;
    this[t(705)] += 1, this[t(608)].wrappedSceneZones[t(806)] <= this[t(705)] && (this[t(705)] = 0), this[t(474)](this[t(705)]);
  }
  changeSceneZoneByIndex(t, e = 0.01) {
    const x = i, s = this.sceneWrapper[x(793)](t);
    this[x(705)] = t, this[x(779)](s, e);
  }
  changeSceneZoneByName(t, e = 0.01) {
    const x = i, s = this[x(608)].getSceneZoneByName(t);
    this[x(705)] = s[x(792)], this[x(779)](s[x(548)], e);
  }
  [i(779)](t, e = 0.01) {
    const x = i;
    this[x(776)] = t;
    const s = this[x(815)](this[x(537)]);
    this[x(848)](![]), this[x(801)](t[x(491)], t[x(822)], s, e)[x(515)](() => {
      const a = x;
      this[a(764)][a(610)](), this[a(797)](), this[a(848)](!![]);
    }), this.setupRaycaster();
  }
  [i(815)](t = 3) {
    const e = i, x = Math[e(851)](this[e(776)][e(781)].x, this[e(776)].lookAtTargetSize.y, this[e(776)][e(781)].z), s = x / (2 * Math[e(658)](Math.PI * this.camera[e(532)] / 360)), a = s / this.camera[e(685)], n = t * Math[e(851)](s, a), o = this[e(776)].lookAtTarget[e(855)]()[e(747)](this[e(828)][e(588)])[e(662)]()[e(762)](n);
    return this[e(828)][e(588)].copy(this.activeSceneZone[e(822)])[e(747)](o), this[e(828)].lookAt(this[e(776)][e(822)]), this[e(828)][e(588)].distanceTo(this[e(776)][e(822)]);
  }
  setInputActive(t) {
    const e = i;
    this[e(503)] = t, this.raycastManager[e(503)] = t, this[e(764)].enabled = t;
  }
  [i(478)](t) {
    this.paused = t, this.enabled = !t, this.raycastManager.enabled = !t;
  }
  [i(648)](t = !![]) {
    const e = i;
    this.enabled && (this[e(655)](this.activeSceneZone[e(491)], t), this.setLookAt(this[e(776)].boxCenter, this.activeSceneZone.lookAtTarget, t), this[e(764)][e(768)](t));
  }
  setDampFactor(t = 0.05) {
    const e = i;
    this[e(764)][e(695)] = t * 50;
  }
  setZoom(t, e = !![]) {
    const x = i;
    this[x(764)][x(737)](t, e);
  }
  [i(599)](t, e, x = !![]) {
    const s = i;
    return this[s(764)][s(599)](t.x, t.y, t.z, e.x, e.y, e.z, x);
  }
  [i(655)](t, e = !![]) {
    return this[i(764)].moveTo(t.x, t.y, t.z, !![]);
  }
  setCameraOffset(t) {
    const e = i;
    this[e(828)][e(690)] = t, this.camera[e(626)]();
  }
  orbitCameraTo(t, e, x, s = 0.04, a = !![]) {
    const n = i;
    return t = t.sub(e).setLength(x).add(e), this.setDampFactor(s), this[n(764)][n(599)](t.x, t.y, t.z, e.x, e.y, e.z, a);
  }
  [i(770)](t) {
    const e = i;
    t.object === null || !this[e(503)] || (this[e(593)][e(503)] = ![], this[e(624)](t[e(605)]));
  }
  [i(504)](t) {
    t.object !== null && this.hoverOverCallback(t.object);
  }
  [i(757)](t) {
    const e = i;
    t[e(605)] !== null && this[e(634)](t[e(605)]);
  }
  [i(621)]() {
    const t = i;
    if (this[t(764)][t(483)] || this[t(773)].orbit)
      return;
    const e = this[t(764)][t(498)] == 32 || this.controls[t(498)] == 1;
    let x = -1, s = 1;
    !e && (this[t(773)][t(841)] && this[t(593)].pointer.x && (this[t(743)].x = this[t(593)][t(809)].x + this[t(764)][t(692)], this[t(743)].y = -this[t(593)][t(809)].y + this[t(764)][t(703)], this.rotationTarget.x = P[t(738)](this[t(743)].x, this[t(764)][t(692)] + x, this.controls.azimuthAngle + s, this[t(764)][t(787)], this[t(764)].maxAzimuthAngle), this.rotationTarget.y = P[t(738)](this.rotationTarget.y, this[t(764)][t(703)] + x, this[t(764)].polarAngle + s, this.controls[t(784)], this[t(764)][t(676)])), this[t(654)] && this.cameraParams.gyro && (this[t(743)].x = this.tiltX + this.controls[t(692)], this[t(743)].y = this[t(800)] + this[t(764)].polarAngle), this[t(764)][t(597)](this[t(743)].x, this.rotationTarget.y, ![]));
  }
  update(t) {
    const e = i;
    this[e(764)] !== null && (this[e(593)][e(701)] = t * 1e3, !this[e(594)] && (this[e(621)](), this[e(764)][e(489)](t)));
  }
}
class K {
  constructor(t, e) {
    const x = i;
    this[x(683)] = ![], this[x(615)] = x(618), this[x(521)] = x(736), this[x(534)] = document[x(664)](t), this.loadingScreen = document[x(664)](e), !this[x(534)] && console[x(660)](x(716), t, x(531)), !this.loadingScreen && console[x(660)]("loadingScreen not found. Make sure this returns the correct element: document.getElementById(", e, x(531));
  }
  showLoadingScreen(t, e = null) {
    const x = i;
    this.isOverlayActive = t, t == !![] || this.loadingScreen.remove(), e != null && (this[x(829)][x(672)](), e());
  }
  pushHashURL(t = "", e = !![]) {
    const x = i;
    window[x(617)][x(502)] && e ? window[x(617)][x(502)](null, null, t) : location[x(590)] = t;
  }
  [i(565)](t = !![]) {
    const e = i;
    this[e(683)] = t, t ? (this.contentContainer.classList.add(this[e(521)]), this[e(534)][e(589)][e(672)](this.hiddenSelector)) : (this.contentContainer[e(589)][e(578)](this[e(615)]), this.contentContainer.classList[e(672)](this[e(521)]), this.pushHashURL("", ![]));
  }
  [i(700)](t) {
    const e = i;
    this.contentContainer[e(752)] = t;
  }
  [i(644)](t) {
    const e = i;
    let x = e(746);
    this[e(534)][e(668)](e(570), x), x = this[e(534)][e(817)]("#z3d-close-btn"), x.addEventListener(e(751), () => {
      this[e(565)](![]), t();
    });
  }
  [i(791)](t, e, x) {
    const s = i;
    this[s(700)](t), this[s(644)](e), this[s(671)](x);
  }
  openLink(t) {
    window.open(t);
  }
  [i(702)](t) {
    const e = i;
    this[e(534)][e(817)](e(691)) && (t(), this[e(534)][e(752)] = "");
  }
}
class r0 {
  constructor(t) {
    const e = i;
    let x = this, s = null, a, n, o, c, d, u, f = null, w, v;
    window.DEBUG = t.debug;
    async function z() {
      const r = p;
      s = new Y(t[r(559)].canvasID, t[r(828)]), a = new J(l, t[r(828)]), n = new K(t[r(559)][r(557)], t[r(559)][r(812)]), n[r(780)](!![]);
      const h = s[r(528)]();
      f = s[r(558)]();
      const _ = s[r(485)]();
      c = await new V(h, _, t[r(827)]).build((A, y, C) => {
        const m = r;
        x[m(633)] && x[m(633)](A, y, Math[m(830)](C));
      }), w = new l[r(786)](), o = new l[r(493)](h);
      const b = c[r(623)]();
      return S(r(819), b, !![]), a[r(524)](_, f, c, j, B, I), n[r(780)](![], k), O(), T(), { camera: f, scene: h, renderer: _, sceneWrapper: c };
    }
    function O() {
      const r = p;
      window[r(732)] = function() {
        const h = r;
        location[h(590)] == "" ? n[h(702)](k) : window[h(617)][h(513)] && window.history[h(513)]();
      }, window[r(669)](r(477), () => {
        k();
      }, ![]);
    }
    function T() {
      const r = p;
      requestAnimationFrame(T), !n.isOverlayActive && (v = w[r(846)](), o.update(v), a[r(489)](v), s.render(), x[r(523)] && x[r(523)](v));
    }
    function k(r = !![]) {
      const h = p;
      s[h(768)](), a[h(648)](r);
    }
    async function S(r, h, _ = ![], M = ![], b = null) {
      function A(C) {
        const m = p;
        return Object.keys(C)[m(806)] === 0;
      }
      return A(h) === !![] || !(r in h) ? void 0 : D(h[r], b, _, M);
    }
    async function D(r, h = null, _ = ![], M = ![]) {
      const b = p;
      let A = 0;
      for (let y = 0; y < r.length; y++) {
        const C = r[y], m = o[b(687)](C, h);
        m.blendMode = l.NoBlending, m.stop(), m[b(768)](), m[b(647)] = !![], m[b(839)] = !![], !_ && (m[b(591)](l[b(592)]), m[b(768)]()), m.clampWhenFinished = M, m[b(816)](), C.duration > A && (A = C[b(661)]);
      }
      return new Promise((y) => setTimeout(() => {
        y();
      }, A * 1e3));
    }
    function B(r) {
      const h = p;
      r[h(707)] == null || !a[h(503)] || (S(h(712), r.animations), x[h(805)] !== null && x.onHoverOverCallback(r));
    }
    function I(r) {
      const h = p;
      r.raycastTarget != null && x.onHoverOffCallback !== null && x[h(777)](r);
    }
    async function j(r) {
      const h = p;
      x[h(596)] !== null && x[h(596)](r), a[h(478)](!![]), o.stopAllAction();
      const _ = S(h(828), r.animations, ![], ![], f), M = S("onClick", r[h(771)], ![], ![]);
      await Promise[h(807)]([_, M]);
      const b = c[h(623)]();
      S(h(819), b, !![]), R(r), a[h(478)](![]);
    }
    function R(r) {
      const h = p;
      switch (d = r[h(601)][h(525)], u = r[h(601)][h(547)], d) {
        case "animation":
          break;
        case h(519):
          a[h(754)](u);
          break;
        case h(506):
          a.changeSceneZoneByName(u);
          break;
        case "iframe":
          n.setDynamicContent(u, k), n[h(565)]();
          break;
        case "link":
          n[h(783)](u), k();
          break;
      }
      u = null, d = null;
    }
    x[e(745)] = function(r, h = 0.01) {
      a[e(745)](r, h);
    }, x[e(814)] = function() {
      a[e(754)]();
    }, x.setup = z, x.reset = k, x[e(596)] = null, x.onHoverOverCallback = null, x[e(777)] = null, x[e(523)] = null, x[e(633)] = null;
  }
}
export {
  r0 as default
};
