import * as d from "https://unpkg.com/three/build/three.module.js";
import { GLTFLoader as j } from "https://unpkg.com/three@0.149.0/examples/jsm/loaders/GLTFLoader.js";
import { DRACOLoader as H } from "https://unpkg.com/three@0.149.0/examples/jsm/loaders/DRACOLoader.js";
import { RGBELoader as G } from "https://unpkg.com/three@0.149.0/examples/jsm/loaders/RGBELoader.js";
import { EXRLoader as W } from "https://unpkg.com/three@0.149.0/examples/jsm/loaders/EXRLoader.js";
import { UnrealBloomPass as F } from "https://unpkg.com/three@0.149.0/examples/jsm/postprocessing/UnrealBloomPass.js";
import { RenderPass as N } from "https://unpkg.com/three@0.149.0/examples/jsm/postprocessing/RenderPass.js";
import { EffectComposer as q } from "https://unpkg.com/three@0.149.0/examples/jsm/postprocessing/EffectComposer.js";
import "https://unpkg.com/three@0.149.0/examples/jsm/postprocessing/ShaderPass.js";
import "https://unpkg.com/three@0.149.0/examples/jsm/shaders/FXAAShader.js";
import "https://cdn.jsdelivr.net/npm/camera-controls/dist/camera-controls.min.js";
const i = S;
(function(p, t) {
  const e = S, x = p();
  for (; []; )
    try {
      if (parseInt(e(628)) / 1 * (-parseInt(e(591)) / 2) + -parseInt(e(684)) / 3 * (-parseInt(e(544)) / 4) + parseInt(e(576)) / 5 + parseInt(e(542)) / 6 + parseInt(e(595)) / 7 + parseInt(e(477)) / 8 * (-parseInt(e(486)) / 9) + -parseInt(e(588)) / 10 * (parseInt(e(607)) / 11) === t)
        break;
      x.push(x.shift());
    } catch {
      x.push(x.shift());
    }
})(D, 386830);
function D() {
  const p = ["showLoadingScreen", "onClickAnimations", "raycastTarget", "build", "point", "setDynamicContent", "updateSceneZones", "_hovered", "exposure", "ambientLight", "gltf", "raycastManager", "isPostEffectsEnabled", "Raycaster", "onPointerDownCallback", "jsonPath", "isOverlayActive", "enableAll", "setZoom", "pointermove", "2045862XivHvZ", "ROTATE", "1873744Iakbeh", "paused", "addPointLight", "compileEquirectangularShader", "contentType", "getSceneZoneByName", "log", "includes", "history", "DEBUG", "mouse", "touch", "models", "size", "gltfLoader", "rotation", "aspect", "DirectionalLightHelper", "forEach", "getBoundingBox", "onWindowResized", "PMREMGenerator", "scale", "innerHTML", "An error happened ", "zeroSlopeAtStart", "bloom", "getAnimations", "threshold", ":>> GLTF element unrecognized:", "defaultDampFactor", "finalComposer", "321775wLlOcq", "Box3", "_objects", "ACTION", "wrappedModels", "Mesh", "targetPosition", "minPolarAngle", "atan", "insertAdjacentHTML", "onUpdate", "filmOffset", "363770bdbZRz", "getScene", "sub", "278PNLrVP", "right", "loadingScreen", "iframe not found. Make sure this returns the correct element: document.getElementById(", "3170300RRqpbU", "saveState", "values", "NoBlending", "pushHashURL", "fov", "polarAngle", "getInteractablesByZone", "hoverOverCallback", "interactable", "updatePointer", "max", "66OwpaBF", "iframeID", "maxZoom", "lookAtTarget", "intersectObjects", "hdr", "createModelContainer", ");  ", "domElement", "add", "light", "pop", "changeSceneZoneByName", "controls", "_camera", "error", "strength", "setFromCamera", "pointer", "backgroundIntensity", "cameraAnimations", "3637zJczAX", "setModelMatrixData", "update", "buttonZone", "exr", "canvasID", "loadModel", "addDynamicCloseButton", "updateProjectionMatrix", "bind", "scene", "open", "classList", "children", "onPointerMove", "getObjects", "activeSceneZone", "getSceneZoneByIndex", "keys", "onHoverAnimations", "Vector2", "multiplyScalar", "position", "onHoverOff", "enabled", "camera", '<div id="z3d-close-btn" class="z3d-close-btn"><span>âœ•</span', "content", "moveTo", "renderer", "setupCamera", "height", "WebGLRenderer", "expandByObject", "getModel", "interactablesContent", "bloomPass", "mouseup", "activeZoneIndex", "looping", "getWrappedAnimations", "name", "touchend", "debug", "getHitObject", "resetControlsLimits", "fps", "load", "toneMapping", "setInputActive", "pointLight", "quaternion", "deactivate", "duration", "getAnimationsFromCSV", "cursor", "3CKuUZz", "onhashchange", "SpotLight", "quaternionToVector3", "tracks", "intersectableObjects", "smoothTime", "sceneWrapper", "rotationTarget", "getCenter", ".z3d-close", "Vector3", "type", "distance", "_domElement", "Camera", "getRandomIntRange", "openLink", "spot", "castShadow", "start", "clientX", "onHoverOver", "then", "hoveroff", "setSize", "Missing raycast target for: ", "pointerDownCallback", "side", "min", "two", "click", "map", "tiltX", "all", "wrappedSceneZones", "hash", "iframe", "The gryto motion sensor is not supported on this device.", "LoopOnce", "orbitCameraTo", "directionalLight", "clientY", "clampWhenFinished", "background", "gyro", "Cache", "getLoopingAnimations", "getInteractableModelsByZone", "average", "setup", "mapping", "jsonData", "high-performance", "defaultRotationDistance", "AmbientLight", "addEXR", "AnimationMixer", "fill", "animations", "auto", "getInteractableObject", "followMouse", "orbit", "none", "getElementById", "#z3d-close-btn", "lerp", "pointerdown", "setLoop", "tiltXArr", "interactables", "getHtmlData", "back", "Scene", "resize", "resetCamera", "model", "clipAction", "setupGyro", ".quaternion", "rotateCamera", "bgMesh", "tiltYArr", "addEventListener", "material", "EquirectangularReflectionMapping", "Group", "backgroundBlurriness", "getDelta", "moveCamera", "getCameraBoundsObject", "showDynamicHTML", "split", "getRaycastTarget", "addHDR", "fitCameraOffset", "setupRenderer", "ReinhardToneMapping", "pushState", "directional", "zone", "test", "getBackgroundModelsByZone", "changeCameraZone", "round", "touches", "scrollHeight", "beforeend", "bloomParams", "getHtml", "minAzimuthAngle", "frame", "getRenderer", "path", "addAmbientLight", "domElements", "setCameraOffset", "nextScene", "onClick", "lookAt", "remove", "wrappedAnimations", "dispatchEvent", "closeDynamicContent", "_intersections", "azimuthAngle", "removeEventListener", "setDampFactor", "player", "z3d-hidden", "active", "getSceneWrapper", "transformGroup", "radius", "TOUCH_ZOOM", "raycastMesh", "width", "getPlayer", "texture", "contentContainer", "_selected", "visible", "maxPolarAngle", "Object3D", "onProgressLoading", "lookAtTargetSize", "length", "onHoverOffCallback", "Clock", "loopAnimations", "intensity", "normalBias", "onHoverOverCallback", "layers", "addGLTFModel", "addLighting", "addPass", "changeSceneZoneByIndex", "scrollWidth", "tiltY", "loadJson", "setLookAt", "element", "https://unpkg.com/three@0.147.0/examples/js/libs/draco/", "createLightContainer", "loadingScreenID", "boxCenter", "currentAction", "stop", "visibleSelector", "index", "setupRaycaster", "getRandomRange", "copy", "nextSceneZone", "addDirectionalLight", "stopAllAction", "processModel", "24zxtZrG", "userData", "wrapScene", "isMobileDevice", "maxGyroSignals", "buttonNextZone", "push", "getSize", "hoveron", "648099uKLIKT", "lights", "EventDispatcher", "color", "fitCameraToZone", "setupPostEffects", "onPointerUp", "init", "mouseButtons", "activate", "canvas", "setPaused", "z3d-visible", "environment", "zoneBox", "target", "postEffects", "render", "random", "maxAzimuthAngle", "style", "getCamera", "set", "innerWidth", "PointLight", "object", "setDynamicHTML", "reset", "fromEquirectangular", "cameraParams", "onHover", "getIntersectableObjects", "reading", "hiddenSelector", "dispose", "BackSide"];
  return D = function() {
    return p;
  }, D();
}
class z {
  static [i(471)](t, e) {
    return Math[i(504)]() * (e - t) + t;
  }
  static [i(700)](t, e) {
    return Math[i(789)](Math.random() * (e - t) + t);
  }
  static [i(687)](t, e, x, s) {
    const o = t + t, n = e + e, a = x + x, c = t * n, l = t * a, b = e * a, f = s * o, g = s * n, y = s * a;
    return { x: c - y, y: b + f, z: l - g };
  }
  static [i(716)](t, e, x, s, o) {
    return (t - e) * (o - s) / (x - e) + s;
  }
  static [i(733)](t) {
    const e = i;
    let x = 0;
    return t.forEach((s) => {
      x += s;
    }), x / t[e(445)];
  }
}
class U {
  constructor(t, e, x) {
    const s = i;
    this.animations = x, this[s(556)] = t, this[s(487)] = e, this[s(580)] = { interactables: [], bg: [], player: null }, this.wrappedAnimations = { looping: [], onClick: [], onHover: [], camera: [] }, this[s(719)] = [], this.wrapScene(this[s(556)]), this[s(528)](this.wrappedSceneZones);
  }
  [i(479)](t) {
    const e = i, x = { interactables: [], bgMesh: [], player: null }, s = [];
    for (let o = 0; o < t.length; o++) {
      const n = t[o], a = n.model[e(478)];
      let c = {};
      const l = this[e(571)](a, n[e(669)]);
      switch (a[e(696)]) {
        case e(604):
          c = this.getInteractableObject(n, a, l), x[e(755)].push(c);
          break;
        case "cameraBounds":
          c = this[e(775)](n, a), s[e(483)](c);
          break;
        case e(766):
          x[e(766)][e(483)](n[e(761)]);
          break;
        case e(820):
          x.bgMesh.push(n[e(761)]);
          break;
        case "player":
          x.player = n[e(761)];
          break;
      }
    }
    this[e(580)] = x, this[e(719)] = s;
  }
  [i(528)](t) {
    const e = i, x = [...t];
    for (let s = 0; s < x[e(445)]; s++) {
      const o = x[s], n = o[e(650)], a = this[e(732)](o[e(785)]);
      a[e(445)] <= 0 && this[e(787)](o[e(785)])[e(562)]((g) => {
        a[e(483)](g);
      });
      const c = this[e(563)](a), l = new d[e(695)]();
      c[e(693)](l);
      const b = new d.Vector3();
      c[e(484)](b), x[s][e(465)] = n, x[s].lookAtTargetBox = c, x[s][e(830)] = b, x[s][e(610)] = l;
    }
    this.wrappedSceneZones = x;
  }
  [i(645)](t) {
    const e = i;
    let x = null;
    return this[e(719)].forEach((s) => {
      s[e(469)] === t && (x = s);
    }), x;
  }
  [i(549)](t) {
    const e = i;
    let x = null, s = null;
    return this[e(719)][e(562)]((o) => {
      o[e(785)] === t && (x = o);
    }), { zoneBox: x, index: s };
  }
  [i(731)]() {
    const t = i, e = { looping: [] };
    return this.wrappedAnimations[t(667)][t(562)]((x) => {
      const s = t;
      x[s(743)][s(562)]((o) => {
        const n = s;
        e[n(667)][n(483)](o);
      });
    }), e;
  }
  [i(668)]() {
    return this[i(806)];
  }
  [i(822)]() {
    const t = i;
    return this[t(580)][t(813)];
  }
  getInteractables() {
    const t = i;
    return this.wrappedModels[t(755)];
  }
  [i(602)](t) {
    const e = i, x = [];
    for (let s = 0; s < this[e(580)][e(755)][e(445)]; s++) {
      const o = this.wrappedModels.interactables[s];
      o[e(785)] === t && x.push(o);
    }
    return x;
  }
  getInteractableModelsByZone(t) {
    const e = i, x = [];
    for (let s = 0; s < this[e(580)][e(755)][e(445)]; s++) {
      const o = this.wrappedModels.interactables[s];
      o.zone === t && x[e(483)](o.element.model);
    }
    return x;
  }
  [i(787)](t) {
    const e = i, x = [];
    for (let s = 0; s < this[e(580)].bgMesh[e(445)]; s++) {
      const o = this[e(580)].bgMesh[s];
      o.type === e(771) ? o[e(641)][e(562)]((n) => {
        const a = e;
        o[a(478)][a(785)] === t && x[a(483)](n);
      }) : o[e(478)][e(785)] === t && x[e(483)](o);
    }
    return x;
  }
  [i(563)](t) {
    const e = i, x = new d[e(577)]();
    t[e(696)] === e(771) && (t = [...t.children]);
    for (let s = 0; s < t[e(445)]; s++) {
      const o = t[s];
      x[e(661)](o);
    }
    return x;
  }
  [i(662)](t) {
    const e = i;
    for (let x = 0; x < this[e(556)][e(445)]; x++) {
      const s = this[e(556)][x][e(761)];
      if (s.name === t)
        return s;
    }
    return null;
  }
  getAnimation(t) {
    const e = i;
    for (let x = 0; x < this[e(743)][e(445)]; x++) {
      const s = this[e(743)][x];
      if (s.name === t)
        return s;
    }
    return null;
  }
  [i(682)](t) {
    const e = i, x = t[e(777)](","), s = [];
    for (let o = 0; o < x[e(445)]; o++) {
      const n = x[o];
      s[e(483)](this.getAnimation(n));
    }
    return s;
  }
  getAnimationTrack(t, e) {
    const x = i;
    for (let s = 0; s < t[x(688)][x(445)]; s++)
      if (t[x(688)][s][x(669)] === e)
        return t[x(688)][s];
    return null;
  }
  getCameraAnimationStart(t) {
    const e = i, x = { position: null, rotation: null };
    for (let s = 0; s < t[e(653)][e(445)]; s++) {
      const o = t[e(653)][s];
      for (let n = 0; n < o[e(688)][e(445)]; n++) {
        const a = o[e(688)][n];
        if (a[e(669)][e(551)](".position"))
          x[e(650)] = new d.Vector3(a[e(597)][0], a.values[1], a[e(597)][2]);
        else if (a.name.includes(e(764))) {
          const c = new d.Quaternion(a[e(597)][0], a[e(597)][1], a[e(597)][2], a[e(597)][3]);
          x[e(559)] = c;
        }
      }
    }
    return x;
  }
  getAnimations(t, e) {
    const x = i;
    let s = null, o = null, n = null, a = null;
    return "loopAnimations" in t && (s = this.getAnimationsFromCSV(t[x(448)]), this[x(806)][x(667)][x(483)]({ name: e, animations: s })), x(523) in t && (o = this.getAnimationsFromCSV(t[x(523)]), this[x(806)][x(803)].push({ name: e, animations: o })), x(647) in t && (n = this[x(682)](t.onHoverAnimations), this[x(806)].onHover[x(483)]({ name: e, animations: n })), "cameraAnimations" in t && (a = this[x(682)](t[x(627)]), this[x(806)][x(653)].push({ name: e, animations: a })), { loopAnimations: s, onHoverAnimations: n, onClickAnimations: o, cameraAnimations: a };
  }
  [i(745)](t, e, x) {
    const s = i, o = this[s(778)](e[s(524)]), n = { name: t[s(669)], raycastTarget: o, element: t, animations: {}, zone: e[s(785)] };
    return x[s(647)] !== null && (n[s(743)][s(516)] = x.onHoverAnimations), x[s(523)] !== null && (n[s(743)][s(803)] = x[s(523)]), x[s(627)] !== null && (n.animations[s(653)] = x[s(627)]), n;
  }
  [i(775)](t, e) {
    const x = i, s = { zone: e[x(785)], index: parseInt(e[x(469)], 10), position: t.model.position };
    return t[x(761)].visible = ![], s;
  }
  getRaycastTarget(t) {
    const e = i, x = this[e(662)](t);
    return x == null ? (console[e(550)](e(710), t), null) : (x[e(769)][e(712)] = d[e(521)], x[e(769)][e(826)] = ![], x);
  }
}
class V {
  async parse(t) {
    const e = i;
    let x = null;
    return await fetch(t)[e(707)]((s) => s.json())[e(707)]((s) => {
      x = s;
    }), x;
  }
}
class X {
  constructor(t, e, x) {
    const s = i;
    this[s(638)] = t, this.renderer = e, this.jsonPath = x, this[s(691)];
    const o = new H();
    if (o.setDecoderPath(s(462)), this[s(558)] = new j(), this[s(558)].setDRACOLoader(o), window.DEBUG) {
      const n = new d.AxesHelper(5e3);
      this[s(638)].add(n);
    }
  }
  [i(816)]() {
    return this.sceneWrapper;
  }
  async [i(459)]() {
    const t = i;
    return await new V().parse(this[t(537)]);
  }
  async build(t) {
    const e = i, x = await this[e(459)](), s = [], o = [], n = await this[e(453)](x[e(556)], t), a = this[e(454)](x[e(487)]);
    return a.push(...n[e(487)]), s[e(483)](...n[e(556)]), o[e(483)](...n[e(743)]), this.sceneWrapper = new U(s, a, o), this[e(691)];
  }
  async [i(453)](t, e) {
    const x = i, s = [], o = [], n = [];
    for (let a = 0; a < t[x(445)]; a++) {
      const c = t[a], l = function(b) {
        const f = x;
        e(a + 1, t[f(445)], 100 * b.loaded / b.total);
      };
      await this[x(634)](c, l)[x(707)]((b) => {
        const f = x;
        window[f(553)] && console.log("gltf children :>> ", [...b[f(532)][f(638)][f(641)]]);
        const g = this.processModel(b);
        s[f(483)](...g[f(556)]), o[f(483)](...g[f(487)]), n[f(483)](...g[f(743)]);
      });
    }
    return { models: s, lights: o, animations: n };
  }
  getModel(t, e) {
    const x = i;
    for (let s = 0; s < t.length; s++) {
      const o = t[s];
      if (o[x(669)] === e)
        return o;
    }
    return null;
  }
  [i(613)](t, e) {
    const x = i, s = { name: t[x(669)], model: t };
    switch (this.setModelMatrixData(t, e), t.castShadow = e.castShadow, t.receiveShadow = e.receiveShadow, t.userData[x(696)]) {
      case "bgMesh":
        break;
      case x(604):
        const o = this[x(794)](e, t[x(669)]);
        s.contentType = o[x(696)], s.content = o[x(655)];
        break;
    }
    return s;
  }
  [i(463)](t, e) {
    return { type: t, light: e };
  }
  [i(476)](t) {
    const e = i, x = [...t[e(532)].scene[e(641)]], s = t[e(532)][e(743)], o = [], n = [], a = 1e5;
    for (let c = 0; c < x.length; c++) {
      const l = x[c];
      switch (l[e(452)].enableAll(), l[e(696)]) {
        case e(581):
          o[e(483)](this[e(613)](l, t[e(736)]));
          break;
        case e(771):
          l[e(641)][e(562)]((b) => {
            const f = e;
            this[f(629)](b, t[f(736)]);
          }), o[e(483)](this[e(613)](l, t[e(736)]));
          break;
        case e(828):
          o[e(483)](this.createModelContainer(l, t[e(736)]));
          break;
        case e(510):
          l[e(449)] /= a, n.push(this[e(463)](e(526), l));
          break;
        case "DirectionalLight":
          l[e(449)] /= a, n[e(483)](this.createLightContainer(e(784), l));
          break;
        case e(686):
          l[e(449)] /= a, n.push(this.createLightContainer(e(702), l));
          break;
        default:
          console.log(e(573), l);
          break;
      }
      this[e(638)][e(616)](l);
    }
    return { models: o, lights: n, animations: s };
  }
  [i(629)](t, e) {
    const x = i;
    t.position.set(t[x(650)].x + e[x(650)].x, t[x(650)].y + e.position.y, t.position.z + e[x(650)].z), t[x(679)][x(508)](e[x(559)].x, e[x(559)].y, e.rotation.z, e[x(559)].w), t.scale[x(508)](e.scale.x, e.scale.y, e[x(566)].z);
  }
  [i(794)](t, e) {
    const x = i, s = this[x(756)](t, e);
    if (s[x(655)] !== void 0)
      return s[x(696)] === x(721) && (s[x(655)] = '<iframe id="z3d-fullscreen" src="' + s[x(655)] + '"></iframe>'), s;
  }
  [i(756)](t, e) {
    const x = i, s = t[x(663)];
    for (let o = 0; o < s[x(445)]; o++) {
      const n = s[o];
      if (n.modelName === e)
        return n;
    }
    return null;
  }
  async [i(634)](t, e) {
    return new Promise((x) => {
      const s = S;
      return this[s(558)][s(675)](".." + t[s(798)], function(o) {
        x({ gltf: o, jsonData: t });
      }, e, function(o) {
        const n = s;
        console[n(550)](n(568) + o);
      });
    });
  }
  [i(454)](t) {
    const e = i, x = [];
    for (let s = 0; s < t[e(445)]; s++) {
      const o = t[s];
      let n, a;
      const c = { type: null, light: null };
      switch (o[e(696)]) {
        case e(612):
          this[e(779)](o[e(798)], o[e(626)], o[e(772)]);
          break;
        case e(632):
          this[e(740)](o[e(798)], o[e(626)], o[e(772)]);
          break;
        case "pointLight":
          n = new d.Vector3(o[e(650)].x, o[e(650)].y, o[e(650)].z), a = this[e(546)](n, o[e(489)], o[e(449)], o[e(557)], o[e(703)]), c.type = e(678), c[e(617)] = a;
          break;
        case e(725):
          n = new d.Vector3(o[e(650)].x, o[e(650)].y, o[e(650)].z);
          const l = new d[e(695)](o.target.x, o[e(501)].y, o[e(501)].z);
          a = this[e(474)](n, l, o.color, o[e(449)], o[e(703)]), c[e(696)] = "directionalLight", c[e(617)] = a;
          break;
        case e(531):
          a = this.addAmbientLight(o.color, o[e(449)]), c[e(696)] = e(531), c.light = a;
          break;
      }
      x[e(483)](c);
    }
    return x;
  }
  [i(546)](t, e = 0, x = 1, s = 1500, o = ![]) {
    const n = i, a = new d[n(510)](e, x, s);
    if (a.position[n(751)](t, 1), a.castShadow = o, a[n(450)] = 0.1, this[n(638)][n(616)](a), window[n(553)]) {
      const c = new d.PointLightHelper(a, 0.25);
      this[n(638)][n(616)](c);
    }
    return a;
  }
  [i(799)](t = 0, e = 1) {
    const x = i, s = new d[x(739)](t, e);
    return this.scene[x(616)](s), s;
  }
  [i(474)](t, e = new d[i(695)](0, 0, 0), x = 16777215, s = 2, o = ![]) {
    const n = i, a = new d.DirectionalLight(x, s);
    if (a[n(650)].lerp(t, 1), a.target.position[n(751)](e, 1), a.castShadow = o, a[n(450)] = 0.1, this.scene[n(616)](a), this[n(638)][n(616)](a[n(501)]), window[n(553)]) {
      const c = new d[n(561)](a);
      this[n(638)].add(c);
    }
    return a;
  }
  addHDR(t, e, x) {
    const s = i, o = new d[s(565)](this[s(657)]);
    o[s(547)]();
    let n;
    new G()[s(675)](".." + t, (a) => {
      const c = s;
      n = o[c(514)](a)[c(823)], this[c(638)][c(499)] = n, this[c(638)][c(728)] = n, this.scene.backgroundIntensity = e, this[c(638)][c(772)] = x, a[c(520)](), o.dispose();
    });
  }
  [i(740)](t, e, x) {
    const s = i, o = new d.PMREMGenerator(this[s(657)]);
    o[s(547)]();
    let n;
    new W()[s(675)](".." + t, (a) => {
      const c = s;
      a[c(735)] = d[c(770)], n = o[c(514)](a)[c(823)], this[c(638)][c(499)] = n, this.scene[c(728)] = n, this.scene[c(626)] = e, this[c(638)].backgroundBlurriness = x, a[c(520)](), o[c(520)]();
    });
  }
}
class Y {
  constructor(t, e) {
    const x = i;
    d[x(730)][x(652)] = !![], this[x(496)] = document[x(749)](t), !this[x(496)] && console[x(622)]("Canvas not found. Make sure this returns the correct element: document.GetElementByID(", t, x(614)), this[x(515)] = e, this[x(793)] = e[x(502)][x(570)], this[x(821)] = this[x(496)].scrollWidth, this.height = this[x(496)][x(791)], this[x(653)] = new d.PerspectiveCamera(this[x(515)].fov, this[x(821)] / this.height, 0.1, 1e4), this[x(653)][x(669)] = x(699), this[x(638)] = new d[x(758)](), this.renderer, this[x(575)], this[x(664)], this[x(534)] = e[x(502)][x(652)], this[x(781)](), this[x(534)] && this[x(491)]();
  }
  [i(507)]() {
    return this[i(653)];
  }
  [i(589)]() {
    return this[i(638)];
  }
  [i(797)]() {
    return this[i(657)];
  }
  [i(781)]() {
    const t = i;
    this.renderer = new d[t(660)]({ canvas: this.canvas, antialias: !![], powerPreference: t(737), failIfMajorPerformanceCaveat: !![] }), this[t(657)].shadowMap[t(652)] = !![], this[t(653)][t(452)][t(539)](), this[t(657)].setSize(this[t(821)], this.height), this[t(657)][t(676)] = d[t(782)], this.renderer.toneMappingExposure = Math.pow(this[t(793)][t(530)], 4), this[t(657)].gammaFactor = 4;
  }
  [i(491)]() {
    const t = i, e = new N(this[t(638)], this[t(653)]), x = new F(new d[t(648)](this[t(821)], this[t(659)]), this[t(793)].strength, this.bloomParams[t(818)], this[t(793)].threshold);
    x[t(530)] = this[t(793)][t(530)], x[t(572)] = this[t(793)][t(572)], x[t(623)] = this[t(793)][t(623)], x.radius = this[t(793)].radius, this[t(575)] = new q(this[t(657)]), this.finalComposer.setSize(this[t(821)], this[t(659)]), this.finalComposer[t(455)](e), this[t(575)].addPass(x);
  }
  onWindowResized() {
    const t = i;
    this[t(821)] = this[t(496)][t(457)], this[t(659)] = this[t(496)][t(791)], this[t(653)][t(560)] = this[t(821)] / this[t(659)], this[t(653)][t(636)](), this[t(657)][t(709)](this.width, this[t(659)]), this[t(534)] && this[t(575)][t(709)](this[t(821)], this[t(659)]);
  }
  [i(513)]() {
    this[i(564)]();
  }
  [i(503)]() {
    const t = i;
    this[t(534)] ? this[t(575)][t(503)]() : this[t(657)].render(this.scene, this[t(653)]);
  }
}
const L = new d[i(535)]();
class J extends d[i(488)] {
  constructor(t, e, x) {
    const s = i;
    super(), this[s(578)] = t, this._camera = e, this[s(698)] = x, this._selected = null, this[s(529)] = null, this[s(809)] = [], this[s(674)] = 30, this.enabled = !![], this[s(817)] = ![], this.halfWindowWidth = window[s(509)] / 2, this.halfWindowWidth = window.innerHeight / 2, this[s(796)] = 0, this.minStaticFrames = this.fps, this[s(689)] = this[s(517)](this[s(578)]), this[s(625)] = new d[s(648)](), this[s(642)] = (o) => {
      const n = s;
      if (this[n(652)] !== ![] && (this.frame += 1, this[n(796)] > Number.MAX_SAFE_INTEGER && (this.frame = 0), this.updatePointer(o), L[n(624)](this[n(625)], this[n(621)]), this[n(689)] == null && (this[n(689)] = getIntersectableObjects(this[n(578)])), o.pointerType === n(554) || o.pointerType === "pen" || o.pointerType === n(555)))
        if (this._intersections[n(445)] = 0, L[n(624)](this[n(625)], this[n(621)]), L[n(611)](this.intersectableObjects, ![], this._intersections), this[n(809)].length > 0) {
          let a = this[n(809)][0][n(511)];
          a = this[n(672)](a.name), this[n(529)] !== a && this[n(529)] !== null && (this[n(807)]({ type: n(708), object: this._hovered }), this[n(698)][n(506)][n(683)] = n(744), this[n(529)] = null), this[n(529)] !== a && (this[n(807)]({ type: n(485), object: a }), this._domElement[n(506)][n(683)] = n(625), this[n(529)] = a);
        } else
          this[n(529)] !== null && (this[n(807)]({ type: "hoveroff", object: this[n(529)] }), this[n(698)][n(506)][n(683)] = "auto", this._hovered = null);
    }, this[s(492)] = (o) => {
      const n = s;
      if (this[n(652)] !== ![] && !(typeof o === TouchEvent && o.touches[n(445)] > 1)) {
        if (this[n(796)] > Math[n(713)](this.fps * 2, 20)) {
          this[n(796)] = 0;
          return;
        }
        if (this[n(796)] = 0, (this[n(689)] == null || this[n(689)] == null) && (this[n(689)] = getIntersectableObjects(this[n(578)])), this[n(698)][n(506)].touchAction = n(748), this[n(605)](o), this[n(809)][n(445)] = 0, L[n(624)](this[n(625)], this[n(621)]), L[n(611)](this[n(689)], ![], this[n(809)]), this._intersections[n(445)] > 0) {
          const a = this[n(809)][0][n(511)];
          this[n(825)] = this[n(672)](a[n(669)]), this.dispatchEvent({ type: n(752), object: this[n(825)] }), this[n(529)] = this[n(825)];
        }
      }
    }, this.activate();
  }
  [i(495)]() {
    const t = i;
    this[t(698)].addEventListener(t(541), this[t(642)]), this[t(698)][t(768)]("touchend", this.onPointerUp), this[t(698)][t(768)]("mouseup", this[t(492)]);
  }
  deactivate() {
    const t = i;
    this[t(698)].removeEventListener(t(541), this.onPointerMove), this._domElement[t(811)](t(670), this[t(492)]), this._domElement.removeEventListener(t(665), this[t(492)]), this[t(698)][t(506)][t(683)] = "";
  }
  [i(605)](t) {
    const e = i, x = this[e(698)].getBoundingClientRect();
    this.pointer.x = (t[e(705)] - x.left) / x[e(821)] * 2 - 1, this.pointer.y = -(t[e(726)] - x.top) / x[e(659)] * 2 + 1;
  }
  [i(520)]() {
    this[i(680)]();
  }
  [i(643)]() {
    return this[i(578)];
  }
  [i(517)](t) {
    const e = i, x = [];
    for (let s = 0; s < t[e(445)]; s++) {
      const o = t[s];
      x[e(483)](o[e(524)]);
    }
    return x;
  }
  [i(672)](t) {
    const e = i;
    for (let x = 0; x < this[e(578)][e(445)]; x++) {
      const s = this._objects[x];
      if (s.raycastTarget[e(669)] === t)
        return s;
    }
    return null;
  }
}
class K {
  constructor(t, e) {
    const x = i;
    CameraControls.install({ THREE: t }), this[x(652)] = !![], this[x(545)] = ![], this[x(533)], this.controls, this[x(653)], this[x(582)], this.pointerDownCallback, this[x(691)], this.activeSceneZone, this[x(574)] = 0.05, this[x(738)] = 0.05, this[x(515)] = e, this[x(666)] = 0, this[x(717)] = 0, this[x(458)] = 0, this[x(481)] = 512, this[x(754)] = new Array(this.maxGyroSignals)[x(742)](0), this.tiltYArr = new Array(this.maxGyroSignals)[x(742)](0), this[x(480)] = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i[x(786)](navigator.userAgent), this.fitCameraOffset = this.isMobileDevice ? 1.5 : 3, this[x(692)] = new d[x(648)]();
  }
  [i(493)](t, e, x, s, o, n) {
    const a = i;
    this[a(657)] = t, this[a(653)] = e, this[a(691)] = x, this.pointerDownCallback = s, this[a(603)] = o, this.hoverOffCallback = n, this[a(644)] = this[a(691)][a(645)](this.activeZoneIndex), this.setupGyro(), this[a(658)](), this[a(470)](), this[a(760)]();
  }
  [i(763)]() {
    const t = i;
    if (this.cameraParams[t(729)])
      try {
        let e = new Gyroscope({ frequency: 15 });
        e[t(768)](t(518), (x) => {
          const s = t;
          this[s(754)][s(483)](e.y * 2), this.tiltYArr[s(483)](e.x * 2), this[s(717)] = z[s(733)](this[s(754)]), this.tiltY = z[s(733)](this[s(767)]), this[s(754)][s(445)] > this[s(481)] && (this[s(754)][s(618)](), this[s(767)].pop());
        }), e[t(704)]();
      } catch (e) {
        console[t(550)](t(722), e);
      }
  }
  [i(658)]() {
    const t = i;
    this[t(653)][t(650)][t(751)](this[t(644)][t(465)], 1), this[t(653)][t(804)](this[t(644)][t(610)]), this[t(490)](this[t(780)]), this[t(620)] && this[t(620)][t(520)](), this[t(620)] = new CameraControls(this[t(653)], this[t(657)].domElement), this[t(620)].restThreshold = 0.1, this[t(673)]();
  }
  resetControlsLimits() {
    const t = i;
    this.cameraParams[t(747)] !== !![] && (this[t(620)][t(494)][t(592)] = CameraControls[t(579)][t(543)], this[t(620)][t(790)][t(714)] = CameraControls.ACTION[t(819)], this[t(620)][t(505)] = this.controls.azimuthAngle + this.defaultRotationDistance, this[t(620)][t(795)] = this[t(620)][t(810)] - this[t(738)], this[t(620)][t(827)] = this.controls.polarAngle + this.defaultRotationDistance, this[t(620)][t(583)] = this.controls[t(601)] - this.defaultRotationDistance, this[t(620)].maxDistance = this[t(620)][t(697)] * 2, this[t(620)][t(609)] = this[t(620)][t(697)] * 2, this[t(692)] = new d[t(648)](this[t(620)][t(810)], this[t(620)][t(601)]));
  }
  [i(470)]() {
    const t = i;
    this.raycastManager && this[t(533)][t(520)]();
    const e = this[t(691)].getInteractablesByZone(this.activeSceneZone[t(785)]);
    this[t(533)] = new J(e, this[t(653)], this.renderer[t(615)]), this[t(533)][t(768)]("pointerdown", this.onPointerDown[t(637)](this)), this[t(533)][t(768)](t(485), this[t(706)][t(637)](this)), this[t(533)][t(768)](t(708), this[t(651)][t(637)](this));
  }
  nextSceneZone() {
    const t = i;
    this.activeZoneIndex += 1, this[t(691)].wrappedSceneZones[t(445)] <= this.activeZoneIndex && (this[t(666)] = 0), this.changeSceneZoneByIndex(this[t(666)]);
  }
  [i(456)](t, e = 0.01) {
    const x = i, s = this[x(691)][x(645)](t);
    this.activeZoneIndex = t, this[x(788)](s, e);
  }
  [i(619)](t, e = 0.01) {
    const x = i, s = this[x(691)].getSceneZoneByName(t);
    this[x(666)] = s[x(469)], this.changeCameraZone(s[x(500)], e);
  }
  [i(788)](t, e = 0.01) {
    const x = i;
    this[x(644)] = t;
    const s = this.fitCameraToZone(this[x(780)]);
    this[x(677)](![]), this[x(724)](t[x(465)], t[x(610)], s, e)[x(707)](() => {
      const o = x;
      this[o(620)][o(596)](), this[o(673)](), this[o(677)](!![]);
    }), this[x(470)]();
  }
  [i(490)](t = 3) {
    const e = i, x = Math.max(this[e(644)][e(830)].x, this.activeSceneZone[e(830)].y, this[e(644)].lookAtTargetSize.z), s = x / (2 * Math[e(584)](Math.PI * this[e(653)][e(600)] / 360)), o = s / this.camera[e(560)], n = t * Math[e(606)](s, o), a = this.activeSceneZone[e(610)].clone()[e(590)](this[e(653)][e(650)]).normalize()[e(649)](n);
    return this[e(653)][e(650)][e(472)](this.activeSceneZone.lookAtTarget).sub(a), this[e(653)].lookAt(this[e(644)][e(610)]), this[e(653)].position.distanceTo(this[e(644)].lookAtTarget);
  }
  [i(677)](t) {
    const e = i;
    this.enabled = t, this[e(533)].enabled = t, this[e(620)][e(652)] = t;
  }
  [i(497)](t) {
    const e = i;
    this.paused = t, this[e(652)] = !t, this[e(533)][e(652)] = !t;
  }
  resetCamera(t = !![]) {
    const e = i;
    this[e(652)] && (this[e(774)](this[e(644)][e(465)], t), this[e(460)](this[e(644)][e(465)], this[e(644)].lookAtTarget, t), this[e(620)].reset(t));
  }
  [i(812)](t = 0.05) {
    const e = i;
    this[e(620)][e(690)] = t * 50;
  }
  [i(540)](t, e = !![]) {
    this.controls.zoomTo(t, e);
  }
  [i(460)](t, e, x = !![]) {
    const s = i;
    return this[s(620)][s(460)](t.x, t.y, t.z, e.x, e.y, e.z, x);
  }
  [i(774)](t, e = !![]) {
    const x = i;
    return this.controls[x(656)](t.x, t.y, t.z, !![]);
  }
  [i(801)](t) {
    const e = i;
    this[e(653)][e(587)] = t, this[e(653)][e(636)]();
  }
  [i(724)](t, e, x, s = 0.04, o = !![]) {
    const n = i;
    return t = t[n(590)](e).setLength(x)[n(616)](e), this[n(812)](s), this[n(620)][n(460)](t.x, t.y, t.z, e.x, e.y, e.z, o);
  }
  onPointerDown(t) {
    const e = i;
    t.object === null || !this.enabled || (this[e(533)][e(652)] = ![], this[e(711)](t[e(511)]));
  }
  [i(706)](t) {
    const e = i;
    t[e(511)] !== null && this[e(603)](t[e(511)]);
  }
  [i(651)](t) {
    t.object !== null && this.hoverOffCallback(t.object);
  }
  [i(765)]() {
    const t = i;
    if (this[t(620)][t(815)] || this[t(515)][t(747)])
      return;
    const e = this[t(620)][t(466)] == 32 || this[t(620)][t(466)] == 1;
    let x = -1, s = 1;
    !e && (this[t(515)][t(746)] && this.raycastManager.pointer.x && (this[t(692)].x = this[t(533)][t(625)].x + this[t(620)][t(810)], this[t(692)].y = -this[t(533)].pointer.y + this[t(620)].polarAngle, this[t(692)].x = z[t(716)](this[t(692)].x, this[t(620)][t(810)] + x, this[t(620)][t(810)] + s, this.controls[t(795)], this[t(620)][t(505)]), this[t(692)].y = z[t(716)](this[t(692)].y, this[t(620)][t(601)] + x, this[t(620)][t(601)] + s, this.controls.minPolarAngle, this[t(620)][t(827)])), this[t(480)] && this[t(515)].gyro && (this[t(692)].x = this[t(717)] + this[t(620)][t(810)], this[t(692)].y = this[t(458)] + this[t(620)][t(601)]), this.controls.rotateTo(this[t(692)].x, this[t(692)].y, ![]));
  }
  [i(630)](t) {
    const e = i;
    this[e(620)] !== null && (this[e(533)].fps = t * 1e3, !this.paused && (this[e(765)](), this[e(620)][e(630)](t)));
  }
}
class Q {
  constructor(t, e) {
    const x = i;
    this[x(538)] = ![], this[x(519)] = x(814), this[x(468)] = x(498), this[x(824)] = document[x(749)](t), this[x(593)] = document[x(749)](e), !this[x(824)] && console[x(622)](x(594), t, x(614)), !this[x(593)] && console[x(622)]("loadingScreen not found. Make sure this returns the correct element: document.getElementById(", e, x(614));
  }
  [i(522)](t, e = null) {
    const x = i;
    this.isOverlayActive = t, t == !![] || this.loadingScreen[x(805)](), e != null && (this.loadingScreen[x(805)](), e());
  }
  [i(599)](t = "", e = !![]) {
    const x = i;
    window[x(552)][x(783)] && e ? window[x(552)][x(783)](null, null, t) : location[x(720)] = t;
  }
  showDynamicHTML(t = !![]) {
    const e = i;
    this[e(538)] = t, t ? (this[e(824)][e(640)][e(616)](this[e(468)]), this[e(824)][e(640)].remove(this[e(519)])) : (this[e(824)][e(640)].add(this[e(519)]), this[e(824)][e(640)][e(805)](this[e(468)]), this[e(599)]("", ![]));
  }
  [i(512)](t) {
    const e = i;
    this[e(824)].innerHTML = t;
  }
  addDynamicCloseButton(t) {
    const e = i;
    let x = e(654);
    this[e(824)][e(585)](e(792), x), x = this[e(824)].querySelector(e(750)), x[e(768)](e(715), () => {
      this[e(776)](![]), t();
    });
  }
  [i(527)](t, e, x) {
    const s = i;
    this[s(512)](t), this[s(635)](e), this[s(599)](x);
  }
  [i(701)](t) {
    window[i(639)](t);
  }
  [i(808)](t) {
    const e = i;
    this[e(824)].querySelector(e(694)) && (t(), this.contentContainer[e(567)] = "");
  }
}
class r0 {
  constructor(t) {
    const e = i;
    let x = this, s = null, o, n, a, c, l, b, f = null, g, y;
    window[e(553)] = t[e(671)];
    async function T() {
      const r = e;
      s = new Y(t.domElements[r(633)], t[r(653)]), o = new K(d, t[r(653)]), n = new Q(t[r(800)][r(608)], t[r(800)][r(464)]), n.showLoadingScreen(!![]);
      const h = s.getScene();
      f = s[r(507)]();
      const _ = s[r(797)]();
      c = await new X(h, _, t[r(537)])[r(525)]((v, w, A) => {
        const m = r;
        x[m(829)] && x[m(829)](v, w, Math[m(789)](A));
      }), g = new d[r(447)](), a = new d[r(741)](h);
      const u = c[r(731)]();
      return k(r(667), u, !![]), o[r(493)](_, f, c, O, Z, B), n[r(522)](![], C), I(), P(), { camera: f, scene: h, renderer: _, sceneWrapper: c };
    }
    function I() {
      const r = e;
      window[r(685)] = function() {
        const h = r;
        location[h(720)] == "" ? n.closeDynamicContent(C) : window[h(552)][h(757)] && window.history[h(757)]();
      }, window[r(768)](r(759), () => {
        C();
      }, ![]);
    }
    function P() {
      const r = e;
      requestAnimationFrame(P), !n[r(538)] && (y = g[r(773)](), a[r(630)](y), o[r(630)](y), s[r(503)](), x.onUpdate && x[r(586)](y));
    }
    function C(r = !![]) {
      const h = e;
      s.reset(), o[h(760)](r);
    }
    async function k(r, h, _ = ![], M = ![], u = null) {
      function v(A) {
        const m = S;
        return Object[m(646)](A)[m(445)] === 0;
      }
      return v(h) === !![] || !(r in h) ? void 0 : E(h[r], u, _, M);
    }
    async function E(r, h = null, _ = ![], M = ![]) {
      const u = e;
      let v = 0;
      for (let w = 0; w < r[u(445)]; w++) {
        const A = r[w], m = a[u(762)](A, h);
        m.blendMode = d[u(598)], m[u(467)](), m[u(513)](), m.zeroSlopeAtEnd = !![], m[u(569)] = !![], !_ && (m[u(753)](d[u(723)]), m.reset()), m[u(727)] = M, m.play(), A[u(681)] > v && (v = A[u(681)]);
      }
      return new Promise((w) => setTimeout(() => {
        w();
      }, v * 1e3));
    }
    function Z(r) {
      const h = e;
      r[h(524)] == null || !o[h(652)] || (k(h(516), r[h(743)]), x[h(451)] !== null && x[h(451)](r));
    }
    function B(r) {
      const h = e;
      r.raycastTarget != null && x[h(446)] !== null && x[h(446)](r);
    }
    async function O(r) {
      const h = e;
      x[h(536)] !== null && x[h(536)](r), o[h(497)](!![]), a[h(475)]();
      const _ = k("camera", r[h(743)], ![], ![], f), M = k("onClick", r[h(743)], ![], ![]);
      await Promise[h(718)]([_, M]);
      const u = c[h(731)]();
      k("looping", u, !![]), R(r), o[h(497)](![]);
    }
    function R(r) {
      const h = e;
      switch (l = r[h(461)][h(548)], b = r[h(461)][h(655)], l) {
        case "animation":
          break;
        case h(482):
          o.nextScene(b);
          break;
        case h(631):
          o.changeSceneZoneByName(b);
          break;
        case h(721):
          n.setDynamicContent(b, C), n[h(776)]();
          break;
        case "link":
          n[h(701)](b), C();
          break;
      }
      b = null, l = null;
    }
    x.changeSceneZoneByName = function(r, h = 0.01) {
      o[e(619)](r, h);
    }, x[e(473)] = function() {
      o[e(802)]();
    }, x[e(734)] = T, x.reset = C, x[e(536)] = null, x[e(451)] = null, x[e(446)] = null, x[e(586)] = null, x.onProgressLoading = null;
  }
}
function S(p, t) {
  const e = D();
  return S = function(x, s) {
    return x = x - 445, e[x];
  }, S(p, t);
}
export {
  r0 as default
};
