/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const s = c0;
(function(d, e) {
  const x = c0, t = d();
  for (; []; )
    try {
      if (parseInt(x(2448)) / 1 * (-parseInt(x(2340)) / 2) + -parseInt(x(2312)) / 3 + -parseInt(x(1585)) / 4 + -parseInt(x(710)) / 5 * (-parseInt(x(698)) / 6) + -parseInt(x(2671)) / 7 + parseInt(x(3204)) / 8 + parseInt(x(1664)) / 9 * (parseInt(x(507)) / 10) === e)
        break;
      t.push(t.shift());
    } catch {
      t.push(t.shift());
    }
})(ba, 335454);
const pa = s(702), ef = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, tf = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, Wc = 0, Lr = 1, jc = 2, nf = 3, sf = 0, p2 = 1, Xc = 2, Ii = 3, Xe = 0, re = 1, ke = 2, af = 2, Ve = 0, ei = 1, ha = 2, Rr = 3, Pr = 4, qc = 5, jt = 100, Yc = 101, Zc = 102, Ir = 103, Dr = 104, Kc = 200, $c = 201, Jc = 202, Qc = 203, m2 = 204, g2 = 205, xd = 206, ed = 207, td = 208, id = 209, nd = 210, sd = 0, ad = 1, rd = 2, fa = 3, od = 4, cd = 5, dd = 6, hd = 7, Wn = 0, fd = 1, ld = 2, We = 0, ud = 1, _2 = 2, bd = 3, pd = 4, md = 5, ma = 300, St = 301, Tt = 302, Gi = 303, Pn = 304, Ki = 306, Et = 1e3, Zx = 1001, Hi = 1002, Bx = 1003, In = 1004, rf = 1004, Ui = 1005, of = 1005, Cx = 1006, ga = 1007, cf = 1007, qe = 1008, df = 1008, At = 1009, gd = 1010, _d = 1011, v2 = 1012, vd = 1013, _t = 1014, ae = 1015, ue = 1016, yd = 1017, wd = 1018, ti = 1020, Md = 1021, le = 1023, Sd = 1024, Td = 1025, wt = 1026, si = 1027, y2 = 1028, Ed = 1029, Ad = 1030, Cd = 1031, Ld = 1033, ia = 33776, na = 33777, sa = 33778, aa = 33779, Or = 35840, Nr = 35841, Ur = 35842, zr = 35843, Rd = 36196, Br = 37492, Fr = 37496, Gr = 37808, Hr = 37809, kr = 37810, Vr = 37811, Wr = 37812, jr = 37813, Xr = 37814, qr = 37815, Yr = 37816, Zr = 37817, Kr = 37818, $r = 37819, Jr = 37820, Qr = 37821, ra = 36492, Pd = 36283, x2 = 36284, e2 = 36285, t2 = 36286, w2 = 2200, Id = 2201, Dd = 2202, ki = 2300, ai = 2301, oa = 2302, Zt = 2400, Kt = 2401, Dn = 2402, _a = 2500, M2 = 2501, Od = 0, S2 = 1, la = 2, Ne = 3e3, _x = 3001, Nd = 3200, Ud = 3201, Rt = 0, zd = 1, hf = "", _e = s(2603), ri = "srgb-linear", T2 = s(3758), ff = 0, ca = 7680, lf = 7681, uf = 7682, bf = 7683, pf = 34055, mf = 34056, gf = 5386, _f = 512, vf = 513, yf = 514, wf = 515, Mf = 516, Sf = 517, Tf = 518, Bd = 519, On = 35044, Ef = 35048, Af = 35040, Cf = 35045, Lf = 35049, Rf = 35041, Pf = 35046, If = 35050, Df = 35042, Of = s(2081), i2 = s(1193), ua = 1035;
let Ye = class {
  addEventListener(e, x) {
    const t = s;
    this[t(2897)] === void 0 && (this[t(2897)] = {});
    const i = this[t(2897)];
    i[e] === void 0 && (i[e] = []), i[e][t(882)](x) === -1 && i[e][t(3156)](x);
  }
  [s(2131)](e, x) {
    const t = s;
    if (this[t(2897)] === void 0)
      return ![];
    const i = this[t(2897)];
    return i[e] !== void 0 && i[e][t(882)](x) !== -1;
  }
  removeEventListener(e, x) {
    const t = s;
    if (this[t(2897)] === void 0)
      return;
    const i = this[t(2897)], n = i[e];
    if (n !== void 0) {
      const a = n[t(882)](x);
      a !== -1 && n[t(1733)](a, 1);
    }
  }
  [s(3157)](e) {
    const x = s;
    if (this[x(2897)] === void 0)
      return;
    const t = this[x(2897)], i = t[e[x(566)]];
    if (i !== void 0) {
      e[x(671)] = this;
      const n = i.slice(0);
      for (let a = 0, r = n[x(3105)]; a < r; a++)
        n[a].call(this, e);
      e[x(671)] = null;
    }
  }
};
const Jx = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let ao = 1234567;
const ii = Math.PI / 180, Nn = 180 / Math.PI;
function ve() {
  const d = s, e = Math[d(3116)]() * 4294967295 | 0, x = Math[d(3116)]() * 4294967295 | 0, t = Math[d(3116)]() * 4294967295 | 0, i = Math[d(3116)]() * 4294967295 | 0;
  return (Jx[e & 255] + Jx[e >> 8 & 255] + Jx[e >> 16 & 255] + Jx[e >> 24 & 255] + "-" + Jx[x & 255] + Jx[x >> 8 & 255] + "-" + Jx[x >> 16 & 15 | 64] + Jx[x >> 24 & 255] + "-" + Jx[t & 63 | 128] + Jx[t >> 8 & 255] + "-" + Jx[t >> 16 & 255] + Jx[t >> 24 & 255] + Jx[i & 255] + Jx[i >> 8 & 255] + Jx[i >> 16 & 255] + Jx[i >> 24 & 255]).toLowerCase();
}
function Gx(d, e, x) {
  return Math.max(e, Math[s(3085)](x, d));
}
function E2(d, e) {
  return (d % e + e) % e;
}
function Nf(d, e, x, t, i) {
  return t + (d - e) * (i - t) / (x - e);
}
function Uf(d, e, x) {
  return d !== e ? (x - d) / (e - d) : 0;
}
function An(d, e, x) {
  return (1 - x) * d + x * e;
}
function zf(d, e, x, t) {
  return An(d, e, 1 - Math.exp(-x * t));
}
function Bf(d, e = 1) {
  return e - Math[s(3373)](E2(d, e * 2) - e);
}
function Ff(d, e, x) {
  return d <= e ? 0 : d >= x ? 1 : (d = (d - e) / (x - e), d * d * (3 - 2 * d));
}
function Gf(d, e, x) {
  return d <= e ? 0 : d >= x ? 1 : (d = (d - e) / (x - e), d * d * d * (d * (d * 6 - 15) + 10));
}
function Hf(d, e) {
  const x = s;
  return d + Math[x(2697)](Math[x(3116)]() * (e - d + 1));
}
function kf(d, e) {
  return d + Math[s(3116)]() * (e - d);
}
function Vf(d) {
  return d * (0.5 - Math[s(3116)]());
}
function Wf(d) {
  const e = s;
  d !== void 0 && (ao = d);
  let x = ao += 1831565813;
  return x = Math[e(965)](x ^ x >>> 15, x | 1), x ^= x + Math[e(965)](x ^ x >>> 7, x | 61), ((x ^ x >>> 14) >>> 0) / 4294967296;
}
function jf(d) {
  return d * ii;
}
function Xf(d) {
  return d * Nn;
}
function n2(d) {
  return (d & d - 1) === 0 && d !== 0;
}
function Fd(d) {
  const e = s;
  return Math[e(3196)](2, Math[e(756)](Math[e(2773)](d) / Math[e(3113)]));
}
function Gd(d) {
  const e = s;
  return Math.pow(2, Math.floor(Math[e(2773)](d) / Math[e(3113)]));
}
function qf(d, e, x, t, i) {
  const n = s, a = Math[n(2063)], r = Math.sin, o = a(x / 2), c = r(x / 2), h = a((e + t) / 2), f = r((e + t) / 2), u = a((e - t) / 2), l = r((e - t) / 2), _ = a((t - e) / 2), p = r((t - e) / 2);
  switch (i) {
    case n(1100):
      d[n(1260)](o * f, c * u, c * l, o * h);
      break;
    case n(1791):
      d[n(1260)](c * l, o * f, c * u, o * h);
      break;
    case "ZXZ":
      d[n(1260)](c * u, c * l, o * f, o * h);
      break;
    case n(603):
      d[n(1260)](o * f, c * p, c * _, o * h);
      break;
    case n(746):
      d[n(1260)](c * _, o * f, c * p, o * h);
      break;
    case n(2331):
      d.set(c * p, c * _, o * f, o * h);
      break;
    default:
      console[n(3629)](n(2485) + i);
  }
}
function it(d, e) {
  const x = s;
  switch (e[x(2787)]) {
    case Float32Array:
      return d;
    case Uint16Array:
      return d / 65535;
    case Uint8Array:
      return d / 255;
    case Int16Array:
      return Math.max(d / 32767, -1);
    case Int8Array:
      return Math[x(1803)](d / 127, -1);
    default:
      throw new Error(x(636));
  }
}
function Ax(d, e) {
  const x = s;
  switch (e.constructor) {
    case Float32Array:
      return d;
    case Uint16Array:
      return Math.round(d * 65535);
    case Uint8Array:
      return Math[x(1981)](d * 255);
    case Int16Array:
      return Math[x(1981)](d * 32767);
    case Int8Array:
      return Math.round(d * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const Hd = { DEG2RAD: ii, RAD2DEG: Nn, generateUUID: ve, clamp: Gx, euclideanModulo: E2, mapLinear: Nf, inverseLerp: Uf, lerp: An, damp: zf, pingpong: Bf, smoothstep: Ff, smootherstep: Gf, randInt: Hf, randFloat: kf, randFloatSpread: Vf, seededRandom: Wf, degToRad: jf, radToDeg: Xf, isPowerOfTwo: n2, ceilPowerOfTwo: Fd, floorPowerOfTwo: Gd, setQuaternionFromProperEuler: qf, normalize: Ax, denormalize: it };
class d0 {
  constructor(e = 0, x = 0) {
    const t = s;
    d0[t(2028)][t(2134)] = !![], this.x = e, this.y = x;
  }
  get [s(1631)]() {
    return this.x;
  }
  set [s(1631)](e) {
    this.x = e;
  }
  get [s(1674)]() {
    return this.y;
  }
  set [s(1674)](e) {
    this.y = e;
  }
  [s(1260)](e, x) {
    return this.x = e, this.y = x, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  [s(3612)](e, x) {
    const t = s;
    switch (e) {
      case 0:
        this.x = x;
        break;
      case 1:
        this.y = x;
        break;
      default:
        throw new Error(t(3182) + e);
    }
    return this;
  }
  [s(788)](e) {
    const x = s;
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error(x(3182) + e);
    }
  }
  [s(2272)]() {
    const e = s;
    return new this[e(2787)](this.x, this.y);
  }
  [s(2875)](e) {
    return this.x = e.x, this.y = e.y, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  [s(3688)](e) {
    return this.x += e, this.y += e, this;
  }
  addVectors(e, x) {
    return this.x = e.x + x.x, this.y = e.y + x.y, this;
  }
  [s(1990)](e, x) {
    return this.x += e.x * x, this.y += e.y * x, this;
  }
  [s(1943)](e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  subVectors(e, x) {
    return this.x = e.x - x.x, this.y = e.y - x.y, this;
  }
  [s(2246)](e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  [s(580)](e) {
    return this.x *= e, this.y *= e, this;
  }
  [s(1023)](e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  divideScalar(e) {
    return this[s(580)](1 / e);
  }
  applyMatrix3(e) {
    const x = s, t = this.x, i = this.y, n = e[x(717)];
    return this.x = n[0] * t + n[3] * i + n[6], this.y = n[1] * t + n[4] * i + n[7], this;
  }
  [s(3085)](e) {
    const x = s;
    return this.x = Math[x(3085)](this.x, e.x), this.y = Math[x(3085)](this.y, e.y), this;
  }
  [s(1803)](e) {
    const x = s;
    return this.x = Math[x(1803)](this.x, e.x), this.y = Math[x(1803)](this.y, e.y), this;
  }
  [s(3135)](e, x) {
    const t = s;
    return this.x = Math.max(e.x, Math[t(3085)](x.x, this.x)), this.y = Math[t(1803)](e.y, Math.min(x.y, this.y)), this;
  }
  [s(2699)](e, x) {
    const t = s;
    return this.x = Math[t(1803)](e, Math[t(3085)](x, this.x)), this.y = Math[t(1803)](e, Math[t(3085)](x, this.y)), this;
  }
  clampLength(e, x) {
    const t = s, i = this.length();
    return this[t(3349)](i || 1)[t(580)](Math[t(1803)](e, Math.min(x, i)));
  }
  [s(2697)]() {
    const e = s;
    return this.x = Math.floor(this.x), this.y = Math[e(2697)](this.y), this;
  }
  [s(756)]() {
    const e = s;
    return this.x = Math[e(756)](this.x), this.y = Math.ceil(this.y), this;
  }
  [s(1981)]() {
    const e = s;
    return this.x = Math[e(1981)](this.x), this.y = Math[e(1981)](this.y), this;
  }
  roundToZero() {
    const e = s;
    return this.x = this.x < 0 ? Math[e(756)](this.x) : Math[e(2697)](this.x), this.y = this.y < 0 ? Math[e(756)](this.y) : Math.floor(this.y), this;
  }
  [s(3515)]() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  [s(1454)](e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  [s(3105)]() {
    return Math[s(713)](this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  [s(608)]() {
    const e = s;
    return this[e(3349)](this[e(3105)]() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  [s(3570)](e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const x = this.x - e.x, t = this.y - e.y;
    return x * x + t * t;
  }
  [s(1164)](e) {
    const x = s;
    return Math.abs(this.x - e.x) + Math[x(3373)](this.y - e.y);
  }
  [s(3399)](e) {
    const x = s;
    return this[x(608)]()[x(580)](e);
  }
  [s(2841)](e, x) {
    return this.x += (e.x - this.x) * x, this.y += (e.y - this.y) * x, this;
  }
  [s(2979)](e, x, t) {
    return this.x = e.x + (x.x - e.x) * t, this.y = e.y + (x.y - e.y) * t, this;
  }
  [s(2828)](e) {
    return e.x === this.x && e.y === this.y;
  }
  [s(666)](e, x = 0) {
    return this.x = e[x], this.y = e[x + 1], this;
  }
  [s(1496)](e = [], x = 0) {
    return e[x] = this.x, e[x + 1] = this.y, e;
  }
  [s(804)](e, x) {
    const t = s;
    return this.x = e[t(781)](x), this.y = e[t(2459)](x), this;
  }
  rotateAround(e, x) {
    const t = s, i = Math[t(2063)](x), n = Math[t(2626)](x), a = this.x - e.x, r = this.y - e.y;
    return this.x = a * i - r * n + e.x, this.y = a * n + r * i + e.y, this;
  }
  [s(3116)]() {
    const e = s;
    return this.x = Math[e(3116)](), this.y = Math[e(3116)](), this;
  }
  *[Symbol[s(3445)]]() {
    yield this.x, yield this.y;
  }
}
class Kx {
  constructor() {
    const e = s;
    Kx[e(2028)][e(3788)] = !![], this[e(717)] = [1, 0, 0, 0, 1, 0, 0, 0, 1];
  }
  [s(1260)](e, x, t, i, n, a, r, o, c) {
    const h = s, f = this[h(717)];
    return f[0] = e, f[1] = i, f[2] = r, f[3] = x, f[4] = n, f[5] = o, f[6] = t, f[7] = a, f[8] = c, this;
  }
  [s(836)]() {
    return this[s(1260)](1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  [s(2875)](e) {
    const x = s, t = this[x(717)], i = e[x(717)];
    return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], this;
  }
  [s(2014)](e, x, t) {
    const i = s;
    return e.setFromMatrix3Column(this, 0), x[i(1772)](this, 1), t[i(1772)](this, 2), this;
  }
  [s(737)](e) {
    const x = s, t = e[x(717)];
    return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this;
  }
  [s(2246)](e) {
    return this[s(3117)](this, e);
  }
  [s(3272)](e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, x) {
    const t = s, i = e[t(717)], n = x[t(717)], a = this[t(717)], r = i[0], o = i[3], c = i[6], h = i[1], f = i[4], u = i[7], l = i[2], _ = i[5], p = i[8], m = n[0], y = n[3], v = n[6], g = n[1], b = n[4], M = n[7], A = n[2], L = n[5], P = n[8];
    return a[0] = r * m + o * g + c * A, a[3] = r * y + o * b + c * L, a[6] = r * v + o * M + c * P, a[1] = h * m + f * g + u * A, a[4] = h * y + f * b + u * L, a[7] = h * v + f * M + u * P, a[2] = l * m + _ * g + p * A, a[5] = l * y + _ * b + p * L, a[8] = l * v + _ * M + p * P, this;
  }
  multiplyScalar(e) {
    const x = s, t = this[x(717)];
    return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
  }
  [s(3314)]() {
    const e = s, x = this[e(717)], t = x[0], i = x[1], n = x[2], a = x[3], r = x[4], o = x[5], c = x[6], h = x[7], f = x[8];
    return t * r * f - t * o * h - i * a * f + i * o * c + n * a * h - n * r * c;
  }
  [s(1525)]() {
    const e = s, x = this[e(717)], t = x[0], i = x[1], n = x[2], a = x[3], r = x[4], o = x[5], c = x[6], h = x[7], f = x[8], u = f * r - o * h, l = o * c - f * a, _ = h * a - r * c, p = t * u + i * l + n * _;
    if (p === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const m = 1 / p;
    return x[0] = u * m, x[1] = (n * h - f * i) * m, x[2] = (o * i - n * r) * m, x[3] = l * m, x[4] = (f * t - n * c) * m, x[5] = (n * a - o * t) * m, x[6] = _ * m, x[7] = (i * c - h * t) * m, x[8] = (r * t - i * a) * m, this;
  }
  [s(2921)]() {
    const e = s;
    let x;
    const t = this[e(717)];
    return x = t[1], t[1] = t[3], t[3] = x, x = t[2], t[2] = t[6], t[6] = x, x = t[5], t[5] = t[7], t[7] = x, this;
  }
  getNormalMatrix(e) {
    const x = s;
    return this[x(737)](e)[x(1525)]()[x(2921)]();
  }
  [s(2375)](e) {
    const x = s, t = this[x(717)];
    return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
  }
  [s(2988)](e, x, t, i, n, a, r) {
    const o = s, c = Math[o(2063)](n), h = Math[o(2626)](n);
    return this[o(1260)](t * c, t * h, -t * (c * a + h * r) + a + e, -i * h, i * c, -i * (-h * a + c * r) + r + x, 0, 0, 1), this;
  }
  scale(e, x) {
    return this[s(3272)](Fa.makeScale(e, x)), this;
  }
  rotate(e) {
    return this.premultiply(Fa.makeRotation(-e)), this;
  }
  [s(864)](e, x) {
    const t = s;
    return this[t(3272)](Fa[t(2381)](e, x)), this;
  }
  makeTranslation(e, x) {
    return this[s(1260)](1, 0, e, 0, 1, x, 0, 0, 1), this;
  }
  [s(432)](e) {
    const x = s, t = Math[x(2063)](e), i = Math[x(2626)](e);
    return this[x(1260)](t, -i, 0, i, t, 0, 0, 0, 1), this;
  }
  [s(1018)](e, x) {
    return this[s(1260)](e, 0, 0, 0, x, 0, 0, 0, 1), this;
  }
  [s(2828)](e) {
    const x = s, t = this[x(717)], i = e[x(717)];
    for (let n = 0; n < 9; n++)
      if (t[n] !== i[n])
        return ![];
    return !![];
  }
  [s(666)](e, x = 0) {
    const t = s;
    for (let i = 0; i < 9; i++)
      this[t(717)][i] = e[i + x];
    return this;
  }
  [s(1496)](e = [], x = 0) {
    const t = this.elements;
    return e[x] = t[0], e[x + 1] = t[1], e[x + 2] = t[2], e[x + 3] = t[3], e[x + 4] = t[4], e[x + 5] = t[5], e[x + 6] = t[6], e[x + 7] = t[7], e[x + 8] = t[8], e;
  }
  [s(2272)]() {
    const e = s;
    return new this.constructor()[e(666)](this[e(717)]);
  }
}
const Fa = new Kx();
function kd(d) {
  const e = s;
  for (let x = d[e(3105)] - 1; x >= 0; --x)
    if (d[x] >= 65535)
      return !![];
  return ![];
}
const Yf = { Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array };
function Di(d, e) {
  return new Yf[d](e);
}
function Un(d) {
  const e = s;
  return document.createElementNS(e(937), d);
}
class $x {
  constructor(e = 0, x = 0, t = 0, i = 1) {
    const n = s;
    this[n(3141)] = !![], this._x = e, this._y = x, this._z = t, this._w = i;
  }
  static [s(3555)](e, x, t, i, n, a, r) {
    const o = s;
    let c = t[i + 0], h = t[i + 1], f = t[i + 2], u = t[i + 3];
    const l = n[a + 0], _ = n[a + 1], p = n[a + 2], m = n[a + 3];
    if (r === 0) {
      e[x + 0] = c, e[x + 1] = h, e[x + 2] = f, e[x + 3] = u;
      return;
    }
    if (r === 1) {
      e[x + 0] = l, e[x + 1] = _, e[x + 2] = p, e[x + 3] = m;
      return;
    }
    if (u !== m || c !== l || h !== _ || f !== p) {
      let y = 1 - r;
      const v = c * l + h * _ + f * p + u * m, g = v >= 0 ? 1 : -1, b = 1 - v * v;
      if (b > Number.EPSILON) {
        const A = Math[o(713)](b), L = Math.atan2(A, v * g);
        y = Math.sin(y * L) / A, r = Math[o(2626)](r * L) / A;
      }
      const M = r * g;
      if (c = c * y + l * M, h = h * y + _ * M, f = f * y + p * M, u = u * y + m * M, y === 1 - r) {
        const A = 1 / Math[o(713)](c * c + h * h + f * f + u * u);
        c *= A, h *= A, f *= A, u *= A;
      }
    }
    e[x] = c, e[x + 1] = h, e[x + 2] = f, e[x + 3] = u;
  }
  static multiplyQuaternionsFlat(e, x, t, i, n, a) {
    const r = t[i], o = t[i + 1], c = t[i + 2], h = t[i + 3], f = n[a], u = n[a + 1], l = n[a + 2], _ = n[a + 3];
    return e[x] = r * _ + h * f + o * l - c * u, e[x + 1] = o * _ + h * u + c * f - r * l, e[x + 2] = c * _ + h * l + r * u - o * f, e[x + 3] = h * _ - r * f - o * u - c * l, e;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    const x = s;
    this._x = e, this[x(2639)]();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    const x = s;
    this._y = e, this[x(2639)]();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    const x = s;
    this._w = e, this[x(2639)]();
  }
  [s(1260)](e, x, t, i) {
    return this._x = e, this._y = x, this._z = t, this._w = i, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  [s(2875)](e) {
    const x = s;
    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this[x(2639)](), this;
  }
  setFromEuler(e, x) {
    const t = s, i = e._x, n = e._y, a = e._z, r = e._order, o = Math[t(2063)], c = Math[t(2626)], h = o(i / 2), f = o(n / 2), u = o(a / 2), l = c(i / 2), _ = c(n / 2), p = c(a / 2);
    switch (r) {
      case t(884):
        this._x = l * f * u + h * _ * p, this._y = h * _ * u - l * f * p, this._z = h * f * p + l * _ * u, this._w = h * f * u - l * _ * p;
        break;
      case t(2157):
        this._x = l * f * u + h * _ * p, this._y = h * _ * u - l * f * p, this._z = h * f * p - l * _ * u, this._w = h * f * u + l * _ * p;
        break;
      case "ZXY":
        this._x = l * f * u - h * _ * p, this._y = h * _ * u + l * f * p, this._z = h * f * p + l * _ * u, this._w = h * f * u - l * _ * p;
        break;
      case t(1387):
        this._x = l * f * u - h * _ * p, this._y = h * _ * u + l * f * p, this._z = h * f * p - l * _ * u, this._w = h * f * u + l * _ * p;
        break;
      case t(964):
        this._x = l * f * u + h * _ * p, this._y = h * _ * u + l * f * p, this._z = h * f * p - l * _ * u, this._w = h * f * u - l * _ * p;
        break;
      case t(3140):
        this._x = l * f * u - h * _ * p, this._y = h * _ * u - l * f * p, this._z = h * f * p + l * _ * u, this._w = h * f * u + l * _ * p;
        break;
      default:
        console[t(3629)](t(3485) + r);
    }
    return x !== ![] && this._onChangeCallback(), this;
  }
  [s(1241)](e, x) {
    const t = s, i = x / 2, n = Math[t(2626)](i);
    return this._x = e.x * n, this._y = e.y * n, this._z = e.z * n, this._w = Math[t(2063)](i), this[t(2639)](), this;
  }
  [s(2225)](e) {
    const x = s, t = e[x(717)], i = t[0], n = t[4], a = t[8], r = t[1], o = t[5], c = t[9], h = t[2], f = t[6], u = t[10], l = i + o + u;
    if (l > 0) {
      const _ = 0.5 / Math[x(713)](l + 1);
      this._w = 0.25 / _, this._x = (f - c) * _, this._y = (a - h) * _, this._z = (r - n) * _;
    } else if (i > o && i > u) {
      const _ = 2 * Math.sqrt(1 + i - o - u);
      this._w = (f - c) / _, this._x = 0.25 * _, this._y = (n + r) / _, this._z = (a + h) / _;
    } else if (o > u) {
      const _ = 2 * Math.sqrt(1 + o - i - u);
      this._w = (a - h) / _, this._x = (n + r) / _, this._y = 0.25 * _, this._z = (c + f) / _;
    } else {
      const _ = 2 * Math[x(713)](1 + u - i - o);
      this._w = (r - n) / _, this._x = (a + h) / _, this._y = (c + f) / _, this._z = 0.25 * _;
    }
    return this[x(2639)](), this;
  }
  setFromUnitVectors(e, x) {
    const t = s;
    let i = e[t(1454)](x) + 1;
    return i < Number.EPSILON ? (i = 0, Math[t(3373)](e.x) > Math[t(3373)](e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = i) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = i)) : (this._x = e.y * x.z - e.z * x.y, this._y = e.z * x.x - e.x * x.z, this._z = e.x * x.y - e.y * x.x, this._w = i), this[t(608)]();
  }
  angleTo(e) {
    const x = s;
    return 2 * Math[x(2765)](Math[x(3373)](Gx(this.dot(e), -1, 1)));
  }
  [s(2550)](e, x) {
    const t = s, i = this.angleTo(e);
    if (i === 0)
      return this;
    const n = Math[t(3085)](1, x / i);
    return this[t(754)](e, n), this;
  }
  [s(836)]() {
    return this[s(1260)](0, 0, 0, 1);
  }
  [s(1525)]() {
    return this[s(2500)]();
  }
  conjugate() {
    const e = s;
    return this._x *= -1, this._y *= -1, this._z *= -1, this[e(2639)](), this;
  }
  [s(1454)](e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  [s(2296)]() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  [s(3105)]() {
    return Math[s(713)](this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  [s(608)]() {
    const e = s;
    let x = this[e(3105)]();
    return x === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (x = 1 / x, this._x = this._x * x, this._y = this._y * x, this._z = this._z * x, this._w = this._w * x), this[e(2639)](), this;
  }
  multiply(e) {
    return this[s(3356)](this, e);
  }
  [s(3272)](e) {
    return this.multiplyQuaternions(e, this);
  }
  [s(3356)](e, x) {
    const t = s, i = e._x, n = e._y, a = e._z, r = e._w, o = x._x, c = x._y, h = x._z, f = x._w;
    return this._x = i * f + r * o + n * h - a * c, this._y = n * f + r * c + a * o - i * h, this._z = a * f + r * h + i * c - n * o, this._w = r * f - i * o - n * c - a * h, this[t(2639)](), this;
  }
  [s(754)](e, x) {
    const t = s;
    if (x === 0)
      return this;
    if (x === 1)
      return this[t(2875)](e);
    const i = this._x, n = this._y, a = this._z, r = this._w;
    let o = r * e._w + i * e._x + n * e._y + a * e._z;
    if (o < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, o = -o) : this[t(2875)](e), o >= 1)
      return this._w = r, this._x = i, this._y = n, this._z = a, this;
    const c = 1 - o * o;
    if (c <= Number[t(633)]) {
      const _ = 1 - x;
      return this._w = _ * r + x * this._w, this._x = _ * i + x * this._x, this._y = _ * n + x * this._y, this._z = _ * a + x * this._z, this.normalize(), this[t(2639)](), this;
    }
    const h = Math[t(713)](c), f = Math.atan2(h, o), u = Math[t(2626)]((1 - x) * f) / h, l = Math.sin(x * f) / h;
    return this._w = r * u + this._w * l, this._x = i * u + this._x * l, this._y = n * u + this._y * l, this._z = a * u + this._z * l, this[t(2639)](), this;
  }
  [s(2822)](e, x, t) {
    const i = s;
    return this[i(2875)](e)[i(754)](x, t);
  }
  random() {
    const e = s, x = Math[e(3116)](), t = Math.sqrt(1 - x), i = Math.sqrt(x), n = 2 * Math.PI * Math[e(3116)](), a = 2 * Math.PI * Math.random();
    return this[e(1260)](t * Math[e(2063)](n), i * Math[e(2626)](a), i * Math[e(2063)](a), t * Math[e(2626)](n));
  }
  [s(2828)](e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
  }
  [s(666)](e, x = 0) {
    const t = s;
    return this._x = e[x], this._y = e[x + 1], this._z = e[x + 2], this._w = e[x + 3], this[t(2639)](), this;
  }
  [s(1496)](e = [], x = 0) {
    return e[x] = this._x, e[x + 1] = this._y, e[x + 2] = this._z, e[x + 3] = this._w, e;
  }
  [s(804)](e, x) {
    const t = s;
    return this._x = e[t(781)](x), this._y = e[t(2459)](x), this._z = e[t(1341)](x), this._w = e[t(3549)](x), this;
  }
  _onChange(e) {
    const x = s;
    return this[x(2639)] = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol[s(3445)]]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class z {
  constructor(e = 0, x = 0, t = 0) {
    const i = s;
    z[i(2028)].isVector3 = !![], this.x = e, this.y = x, this.z = t;
  }
  set(e, x, t) {
    return t === void 0 && (t = this.z), this.x = e, this.y = x, this.z = t, this;
  }
  [s(3417)](e) {
    return this.x = e, this.y = e, this.z = e, this;
  }
  [s(2357)](e) {
    return this.x = e, this;
  }
  [s(712)](e) {
    return this.y = e, this;
  }
  [s(3096)](e) {
    return this.z = e, this;
  }
  [s(3612)](e, x) {
    const t = s;
    switch (e) {
      case 0:
        this.x = x;
        break;
      case 1:
        this.y = x;
        break;
      case 2:
        this.z = x;
        break;
      default:
        throw new Error(t(3182) + e);
    }
    return this;
  }
  [s(788)](e) {
    const x = s;
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error(x(3182) + e);
    }
  }
  [s(2272)]() {
    const e = s;
    return new this[e(2787)](this.x, this.y, this.z);
  }
  [s(2875)](e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  [s(3026)](e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this;
  }
  [s(3688)](e) {
    return this.x += e, this.y += e, this.z += e, this;
  }
  [s(1168)](e, x) {
    return this.x = e.x + x.x, this.y = e.y + x.y, this.z = e.z + x.z, this;
  }
  [s(1990)](e, x) {
    return this.x += e.x * x, this.y += e.y * x, this.z += e.z * x, this;
  }
  [s(1943)](e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
  }
  [s(3395)](e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  }
  [s(1061)](e, x) {
    return this.x = e.x - x.x, this.y = e.y - x.y, this.z = e.z - x.z, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
  }
  [s(580)](e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  multiplyVectors(e, x) {
    return this.x = e.x * x.x, this.y = e.y * x.y, this.z = e.z * x.z, this;
  }
  applyEuler(e) {
    const x = s;
    return this[x(718)](ro[x(2790)](e));
  }
  applyAxisAngle(e, x) {
    const t = s;
    return this[t(718)](ro[t(1241)](e, x));
  }
  [s(1904)](e) {
    const x = this.x, t = this.y, i = this.z, n = e.elements;
    return this.x = n[0] * x + n[3] * t + n[6] * i, this.y = n[1] * x + n[4] * t + n[7] * i, this.z = n[2] * x + n[5] * t + n[8] * i, this;
  }
  [s(1258)](e) {
    const x = s;
    return this.applyMatrix3(e)[x(608)]();
  }
  [s(2442)](e) {
    const x = this.x, t = this.y, i = this.z, n = e.elements, a = 1 / (n[3] * x + n[7] * t + n[11] * i + n[15]);
    return this.x = (n[0] * x + n[4] * t + n[8] * i + n[12]) * a, this.y = (n[1] * x + n[5] * t + n[9] * i + n[13]) * a, this.z = (n[2] * x + n[6] * t + n[10] * i + n[14]) * a, this;
  }
  [s(718)](e) {
    const x = this.x, t = this.y, i = this.z, n = e.x, a = e.y, r = e.z, o = e.w, c = o * x + a * i - r * t, h = o * t + r * x - n * i, f = o * i + n * t - a * x, u = -n * x - a * t - r * i;
    return this.x = c * o + u * -n + h * -r - f * -a, this.y = h * o + u * -a + f * -n - c * -r, this.z = f * o + u * -r + c * -a - h * -n, this;
  }
  [s(2716)](e) {
    const x = s;
    return this.applyMatrix4(e[x(1874)])[x(2442)](e.projectionMatrix);
  }
  [s(1603)](e) {
    const x = s;
    return this[x(2442)](e[x(583)]).applyMatrix4(e.matrixWorld);
  }
  transformDirection(e) {
    const x = s, t = this.x, i = this.y, n = this.z, a = e[x(717)];
    return this.x = a[0] * t + a[4] * i + a[8] * n, this.y = a[1] * t + a[5] * i + a[9] * n, this.z = a[2] * t + a[6] * i + a[10] * n, this[x(608)]();
  }
  [s(1023)](e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  }
  [s(3349)](e) {
    return this.multiplyScalar(1 / e);
  }
  [s(3085)](e) {
    const x = s;
    return this.x = Math[x(3085)](this.x, e.x), this.y = Math[x(3085)](this.y, e.y), this.z = Math[x(3085)](this.z, e.z), this;
  }
  [s(1803)](e) {
    const x = s;
    return this.x = Math.max(this.x, e.x), this.y = Math[x(1803)](this.y, e.y), this.z = Math[x(1803)](this.z, e.z), this;
  }
  [s(3135)](e, x) {
    const t = s;
    return this.x = Math[t(1803)](e.x, Math.min(x.x, this.x)), this.y = Math[t(1803)](e.y, Math.min(x.y, this.y)), this.z = Math[t(1803)](e.z, Math[t(3085)](x.z, this.z)), this;
  }
  [s(2699)](e, x) {
    const t = s;
    return this.x = Math[t(1803)](e, Math.min(x, this.x)), this.y = Math[t(1803)](e, Math.min(x, this.y)), this.z = Math.max(e, Math[t(3085)](x, this.z)), this;
  }
  [s(907)](e, x) {
    const t = s, i = this[t(3105)]();
    return this[t(3349)](i || 1)[t(580)](Math.max(e, Math.min(x, i)));
  }
  [s(2697)]() {
    const e = s;
    return this.x = Math[e(2697)](this.x), this.y = Math[e(2697)](this.y), this.z = Math[e(2697)](this.z), this;
  }
  [s(756)]() {
    const e = s;
    return this.x = Math[e(756)](this.x), this.y = Math[e(756)](this.y), this.z = Math[e(756)](this.z), this;
  }
  [s(1981)]() {
    const e = s;
    return this.x = Math[e(1981)](this.x), this.y = Math[e(1981)](this.y), this.z = Math[e(1981)](this.z), this;
  }
  roundToZero() {
    const e = s;
    return this.x = this.x < 0 ? Math[e(756)](this.x) : Math[e(2697)](this.x), this.y = this.y < 0 ? Math[e(756)](this.y) : Math[e(2697)](this.y), this.z = this.z < 0 ? Math[e(756)](this.z) : Math[e(2697)](this.z), this;
  }
  [s(3515)]() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  [s(1454)](e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  [s(2296)]() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  [s(3105)]() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  [s(1776)]() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  [s(608)]() {
    return this.divideScalar(this.length() || 1);
  }
  [s(3399)](e) {
    const x = s;
    return this[x(608)]()[x(580)](e);
  }
  [s(2841)](e, x) {
    return this.x += (e.x - this.x) * x, this.y += (e.y - this.y) * x, this.z += (e.z - this.z) * x, this;
  }
  [s(2979)](e, x, t) {
    return this.x = e.x + (x.x - e.x) * t, this.y = e.y + (x.y - e.y) * t, this.z = e.z + (x.z - e.z) * t, this;
  }
  cross(e) {
    return this[s(956)](this, e);
  }
  [s(956)](e, x) {
    const t = e.x, i = e.y, n = e.z, a = x.x, r = x.y, o = x.z;
    return this.x = i * o - n * r, this.y = n * a - t * o, this.z = t * r - i * a, this;
  }
  projectOnVector(e) {
    const x = s, t = e.lengthSq();
    if (t === 0)
      return this[x(1260)](0, 0, 0);
    const i = e[x(1454)](this) / t;
    return this[x(2875)](e)[x(580)](i);
  }
  [s(1840)](e) {
    const x = s;
    return Ga[x(2875)](this)[x(1890)](e), this[x(1943)](Ga);
  }
  [s(1200)](e) {
    const x = s;
    return this.sub(Ga[x(2875)](e)[x(580)](2 * this[x(1454)](e)));
  }
  [s(2953)](e) {
    const x = s, t = Math[x(713)](this[x(2296)]() * e[x(2296)]());
    if (t === 0)
      return Math.PI / 2;
    const i = this[x(1454)](e) / t;
    return Math[x(2765)](Gx(i, -1, 1));
  }
  distanceTo(e) {
    const x = s;
    return Math[x(713)](this[x(1679)](e));
  }
  [s(1679)](e) {
    const x = this.x - e.x, t = this.y - e.y, i = this.z - e.z;
    return x * x + t * t + i * i;
  }
  [s(1164)](e) {
    const x = s;
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math[x(3373)](this.z - e.z);
  }
  [s(1548)](e) {
    const x = s;
    return this.setFromSphericalCoords(e.radius, e.phi, e[x(2949)]);
  }
  setFromSphericalCoords(e, x, t) {
    const i = s, n = Math.sin(x) * e;
    return this.x = n * Math[i(2626)](t), this.y = Math[i(2063)](x) * e, this.z = n * Math[i(2063)](t), this;
  }
  [s(2341)](e) {
    const x = s;
    return this.setFromCylindricalCoords(e[x(1232)], e[x(2949)], e.y);
  }
  setFromCylindricalCoords(e, x, t) {
    const i = s;
    return this.x = e * Math[i(2626)](x), this.y = t, this.z = e * Math[i(2063)](x), this;
  }
  setFromMatrixPosition(e) {
    const x = e.elements;
    return this.x = x[12], this.y = x[13], this.z = x[14], this;
  }
  setFromMatrixScale(e) {
    const x = s, t = this[x(3531)](e, 0)[x(3105)](), i = this[x(3531)](e, 1)[x(3105)](), n = this[x(3531)](e, 2)[x(3105)]();
    return this.x = t, this.y = i, this.z = n, this;
  }
  setFromMatrixColumn(e, x) {
    const t = s;
    return this[t(666)](e[t(717)], x * 4);
  }
  [s(1772)](e, x) {
    const t = s;
    return this[t(666)](e[t(717)], x * 3);
  }
  [s(2790)](e) {
    return this.x = e._x, this.y = e._y, this.z = e._z, this;
  }
  [s(2828)](e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, x = 0) {
    return this.x = e[x], this.y = e[x + 1], this.z = e[x + 2], this;
  }
  [s(1496)](e = [], x = 0) {
    return e[x] = this.x, e[x + 1] = this.y, e[x + 2] = this.z, e;
  }
  [s(804)](e, x) {
    const t = s;
    return this.x = e[t(781)](x), this.y = e[t(2459)](x), this.z = e[t(1341)](x), this;
  }
  [s(3116)]() {
    const e = s;
    return this.x = Math[e(3116)](), this.y = Math[e(3116)](), this.z = Math[e(3116)](), this;
  }
  [s(1304)]() {
    const e = s, x = (Math[e(3116)]() - 0.5) * 2, t = Math.random() * Math.PI * 2, i = Math[e(713)](1 - x ** 2);
    return this.x = i * Math[e(2063)](t), this.y = i * Math[e(2626)](t), this.z = x, this;
  }
  *[Symbol[s(3445)]]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const Ga = new z(), ro = new $x();
function zi(d) {
  const e = s;
  return d < 0.04045 ? d * 0.0773993808 : Math[e(3196)](d * 0.9478672986 + 0.0521327014, 2.4);
}
function Ha(d) {
  const e = s;
  return d < 31308e-7 ? d * 12.92 : 1.055 * Math[e(3196)](d, 0.41666) - 0.055;
}
const Zf = new Kx()[s(666)]([0.8224621, 0.0331941, 0.0170827, 0.177538, 0.9668058, 0.0723974, -1e-7, 1e-7, 0.9105199]), Kf = new Kx().fromArray([1.2249401, -0.0420569, -0.0196376, -0.2249404, 1.0420571, -0.0786361, 1e-7, 0, 1.0982735]), vt = new z();
function $f(d) {
  const e = s;
  return d[e(1292)](), vt.set(d.r, d.g, d.b).applyMatrix3(Kf), d[e(1044)](vt.x, vt.y, vt.z);
}
function Jf(d) {
  const e = s;
  return vt[e(1260)](d.r, d.g, d.b)[e(1904)](Zf), d[e(1044)](vt.x, vt.y, vt.z)[e(3346)]();
}
const Qf = { [ri]: (d) => d, [_e]: (d) => d[s(1292)](), [T2]: $f }, xl = { [ri]: (d) => d, [_e]: (d) => d.convertLinearToSRGB(), [T2]: Jf }, xe = { enabled: ![], get legacyMode() {
  const d = s;
  return console[d(3629)](d(3179)), !this.enabled;
}, set legacyMode(d) {
  const e = s;
  console[e(3629)](e(3179)), this[e(2679)] = !d;
}, get workingColorSpace() {
  return ri;
}, set workingColorSpace(d) {
  const e = s;
  console[e(3629)](e(3790));
}, convert: function(d, e, x) {
  const t = s;
  if (this.enabled === ![] || e === x || !e || !x)
    return d;
  const i = Qf[e], n = xl[x];
  if (i === void 0 || n === void 0)
    throw new Error(t(3711) + e + '" to "' + x + '".');
  return n(i(d));
}, fromWorkingColorSpace: function(d, e) {
  const x = s;
  return this.convert(d, this[x(3124)], e);
}, toWorkingColorSpace: function(d, e) {
  const x = s;
  return this.convert(d, e, this[x(3124)]);
} };
let hi;
class A2 {
  static [s(3474)](e) {
    const x = s;
    if (/^data:/i.test(e[x(3095)]) || typeof HTMLCanvasElement == x(2011))
      return e[x(3095)];
    let t;
    if (e instanceof HTMLCanvasElement)
      t = e;
    else {
      hi === void 0 && (hi = Un(x(651))), hi[x(1631)] = e.width, hi[x(1674)] = e[x(1674)];
      const i = hi.getContext("2d");
      e instanceof ImageData ? i[x(1887)](e, 0, 0) : i.drawImage(e, 0, 0, e[x(1631)], e.height), t = hi;
    }
    return t[x(1631)] > 2048 || t[x(1674)] > 2048 ? (console[x(3629)](x(816), e), t[x(2360)]("image/jpeg", 0.6)) : t[x(2360)](x(3785));
  }
  static [s(2408)](e) {
    const x = s;
    if (typeof HTMLImageElement !== x(2011) && e instanceof HTMLImageElement || typeof HTMLCanvasElement !== x(2011) && e instanceof HTMLCanvasElement || typeof ImageBitmap !== x(2011) && e instanceof ImageBitmap) {
      const t = Un("canvas");
      t[x(1631)] = e[x(1631)], t[x(1674)] = e[x(1674)];
      const i = t[x(3271)]("2d");
      i[x(3009)](e, 0, 0, e[x(1631)], e[x(1674)]);
      const n = i[x(3793)](0, 0, e[x(1631)], e[x(1674)]), a = n[x(2416)];
      for (let r = 0; r < a[x(3105)]; r++)
        a[r] = zi(a[r] / 255) * 255;
      return i.putImageData(n, 0, 0), t;
    } else if (e[x(2416)]) {
      const t = e[x(2416)][x(3482)](0);
      for (let i = 0; i < t[x(3105)]; i++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[i] = Math.floor(zi(t[i] / 255) * 255) : t[i] = zi(t[i]);
      return { data: t, width: e.width, height: e.height };
    } else
      return console.warn(x(440)), e;
  }
}
class $t {
  constructor(e = null) {
    const x = s;
    this.isSource = !![], this[x(3104)] = ve(), this[x(2416)] = e, this[x(2185)] = 0;
  }
  set [s(3035)](e) {
    const x = s;
    e === !![] && this[x(2185)]++;
  }
  [s(3139)](e) {
    const x = s, t = e === void 0 || typeof e === x(3335);
    if (!t && e.images[this[x(3104)]] !== void 0)
      return e[x(1090)][this[x(3104)]];
    const i = { uuid: this[x(3104)], url: "" }, n = this.data;
    if (n !== null) {
      let a;
      if (Array[x(1609)](n)) {
        a = [];
        for (let r = 0, o = n[x(3105)]; r < o; r++)
          n[r][x(1120)] ? a[x(3156)](ka(n[r].image)) : a[x(3156)](ka(n[r]));
      } else
        a = ka(n);
      i.url = a;
    }
    return !t && (e[x(1090)][this[x(3104)]] = i), i;
  }
}
function ka(d) {
  const e = s;
  return typeof HTMLImageElement !== e(2011) && d instanceof HTMLImageElement || typeof HTMLCanvasElement !== e(2011) && d instanceof HTMLCanvasElement || typeof ImageBitmap !== e(2011) && d instanceof ImageBitmap ? A2[e(3474)](d) : d[e(2416)] ? { data: Array[e(2576)](d[e(2416)]), width: d[e(1631)], height: d[e(1674)], type: d[e(2416)][e(2787)][e(3710)] } : (console[e(3629)]("THREE.Texture: Unable to serialize Texture."), {});
}
let el = 0;
class Ux extends Ye {
  constructor(e = Ux[s(3006)], x = Ux.DEFAULT_MAPPING, t = Zx, i = Zx, n = Cx, a = qe, r = le, o = At, c = Ux[s(2064)], h = Ne) {
    const f = s;
    super(), this[f(1714)] = !![], Object[f(1117)](this, "id", { value: el++ }), this.uuid = ve(), this[f(3710)] = "", this[f(796)] = new $t(e), this.mipmaps = [], this[f(667)] = x, this[f(578)] = t, this[f(3221)] = i, this[f(999)] = n, this[f(991)] = a, this[f(2447)] = c, this[f(448)] = r, this[f(2060)] = null, this[f(566)] = o, this[f(592)] = new d0(0, 0), this[f(2806)] = new d0(1, 1), this[f(551)] = new d0(0, 0), this[f(591)] = 0, this[f(1126)] = !![], this[f(1067)] = new Kx(), this[f(3632)] = !![], this.premultiplyAlpha = ![], this[f(1739)] = !![], this[f(2275)] = 4, this.encoding = h, this[f(2066)] = {}, this[f(2185)] = 0, this[f(1509)] = null, this[f(546)] = ![], this.needsPMREMUpdate = ![];
  }
  get [s(450)]() {
    const e = s;
    return this[e(796)][e(2416)];
  }
  set image(e = null) {
    const x = s;
    this[x(796)][x(2416)] = e;
  }
  updateMatrix() {
    const e = s;
    this.matrix[e(2988)](this.offset.x, this[e(592)].y, this[e(2806)].x, this.repeat.y, this[e(591)], this[e(551)].x, this[e(551)].y);
  }
  [s(2272)]() {
    const e = s;
    return new this[e(2787)]()[e(2875)](this);
  }
  [s(2875)](e) {
    const x = s;
    return this[x(3710)] = e[x(3710)], this[x(796)] = e.source, this.mipmaps = e[x(2004)][x(3482)](0), this[x(667)] = e.mapping, this[x(578)] = e.wrapS, this[x(3221)] = e[x(3221)], this[x(999)] = e.magFilter, this[x(991)] = e[x(991)], this[x(2447)] = e[x(2447)], this[x(448)] = e[x(448)], this[x(2060)] = e[x(2060)], this[x(566)] = e[x(566)], this.offset[x(2875)](e[x(592)]), this[x(2806)].copy(e.repeat), this[x(551)][x(2875)](e.center), this[x(591)] = e[x(591)], this[x(1126)] = e[x(1126)], this[x(1067)].copy(e[x(1067)]), this.generateMipmaps = e[x(3632)], this[x(3003)] = e[x(3003)], this[x(1739)] = e[x(1739)], this[x(2275)] = e[x(2275)], this[x(523)] = e[x(523)], this[x(2066)] = JSON.parse(JSON[x(3338)](e[x(2066)])), this[x(3035)] = !![], this;
  }
  [s(3139)](e) {
    const x = s, t = e === void 0 || typeof e == "string";
    if (!t && e[x(1822)][this.uuid] !== void 0)
      return e[x(1822)][this[x(3104)]];
    const i = { metadata: { version: 4.5, type: x(3439), generator: x(3310) }, uuid: this[x(3104)], name: this[x(3710)], image: this[x(796)].toJSON(e)[x(3104)], mapping: this.mapping, repeat: [this[x(2806)].x, this[x(2806)].y], offset: [this[x(592)].x, this[x(592)].y], center: [this[x(551)].x, this[x(551)].y], rotation: this[x(591)], wrap: [this[x(578)], this[x(3221)]], format: this[x(448)], internalFormat: this.internalFormat, type: this[x(566)], encoding: this[x(523)], minFilter: this[x(991)], magFilter: this.magFilter, anisotropy: this[x(2447)], flipY: this.flipY, generateMipmaps: this[x(3632)], premultiplyAlpha: this[x(3003)], unpackAlignment: this[x(2275)] };
    return Object[x(2070)](this.userData)[x(3105)] > 0 && (i[x(2066)] = this[x(2066)]), !t && (e[x(1822)][this.uuid] = i), i;
  }
  [s(3387)]() {
    const e = s;
    this[e(3157)]({ type: e(3387) });
  }
  [s(2228)](e) {
    const x = s;
    if (this.mapping !== ma)
      return e;
    if (e[x(1904)](this[x(1067)]), e.x < 0 || e.x > 1)
      switch (this[x(578)]) {
        case Et:
          e.x = e.x - Math[x(2697)](e.x);
          break;
        case Zx:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case Hi:
          Math[x(3373)](Math[x(2697)](e.x) % 2) === 1 ? e.x = Math[x(756)](e.x) - e.x : e.x = e.x - Math[x(2697)](e.x);
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case Et:
          e.y = e.y - Math[x(2697)](e.y);
          break;
        case Zx:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case Hi:
          Math[x(3373)](Math[x(2697)](e.y) % 2) === 1 ? e.y = Math[x(756)](e.y) - e.y : e.y = e.y - Math[x(2697)](e.y);
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set [s(3035)](e) {
    const x = s;
    e === !![] && (this.version++, this[x(796)][x(3035)] = !![]);
  }
}
Ux[s(3006)] = null, Ux[s(2027)] = ma, Ux[s(2064)] = 1;
class Mx {
  constructor(e = 0, x = 0, t = 0, i = 1) {
    const n = s;
    Mx[n(2028)][n(703)] = !![], this.x = e, this.y = x, this.z = t, this.w = i;
  }
  get [s(1631)]() {
    return this.z;
  }
  set [s(1631)](e) {
    this.z = e;
  }
  get [s(1674)]() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  [s(1260)](e, x, t, i) {
    return this.x = e, this.y = x, this.z = t, this.w = i, this;
  }
  [s(3417)](e) {
    return this.x = e, this.y = e, this.z = e, this.w = e, this;
  }
  [s(2357)](e) {
    return this.x = e, this;
  }
  [s(712)](e) {
    return this.y = e, this;
  }
  [s(3096)](e) {
    return this.z = e, this;
  }
  [s(2934)](e) {
    return this.w = e, this;
  }
  setComponent(e, x) {
    switch (e) {
      case 0:
        this.x = x;
        break;
      case 1:
        this.y = x;
        break;
      case 2:
        this.z = x;
        break;
      case 3:
        this.w = x;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  [s(788)](e) {
    const x = s;
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error(x(3182) + e);
    }
  }
  clone() {
    const e = s;
    return new this[e(2787)](this.x, this.y, this.z, this.w);
  }
  [s(2875)](e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
  }
  [s(3688)](e) {
    return this.x += e, this.y += e, this.z += e, this.w += e, this;
  }
  addVectors(e, x) {
    return this.x = e.x + x.x, this.y = e.y + x.y, this.z = e.z + x.z, this.w = e.w + x.w, this;
  }
  addScaledVector(e, x) {
    return this.x += e.x * x, this.y += e.y * x, this.z += e.z * x, this.w += e.w * x, this;
  }
  [s(1943)](e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
  }
  [s(3395)](e) {
    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
  }
  [s(1061)](e, x) {
    return this.x = e.x - x.x, this.y = e.y - x.y, this.z = e.z - x.z, this.w = e.w - x.w, this;
  }
  [s(2246)](e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
  }
  [s(580)](e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }
  applyMatrix4(e) {
    const x = s, t = this.x, i = this.y, n = this.z, a = this.w, r = e[x(717)];
    return this.x = r[0] * t + r[4] * i + r[8] * n + r[12] * a, this.y = r[1] * t + r[5] * i + r[9] * n + r[13] * a, this.z = r[2] * t + r[6] * i + r[10] * n + r[14] * a, this.w = r[3] * t + r[7] * i + r[11] * n + r[15] * a, this;
  }
  [s(3349)](e) {
    return this[s(580)](1 / e);
  }
  [s(645)](e) {
    const x = s;
    this.w = 2 * Math.acos(e.w);
    const t = Math[x(713)](1 - e.w * e.w);
    return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this;
  }
  [s(935)](e) {
    const x = s;
    let t, i, n, a;
    const r = 0.01, o = 0.1, c = e[x(717)], h = c[0], f = c[4], u = c[8], l = c[1], _ = c[5], p = c[9], m = c[2], y = c[6], v = c[10];
    if (Math[x(3373)](f - l) < r && Math.abs(u - m) < r && Math.abs(p - y) < r) {
      if (Math[x(3373)](f + l) < o && Math[x(3373)](u + m) < o && Math[x(3373)](p + y) < o && Math.abs(h + _ + v - 3) < o)
        return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      const b = (h + 1) / 2, M = (_ + 1) / 2, A = (v + 1) / 2, L = (f + l) / 4, P = (u + m) / 4, S = (p + y) / 4;
      return b > M && b > A ? b < r ? (i = 0, n = 0.707106781, a = 0.707106781) : (i = Math[x(713)](b), n = L / i, a = P / i) : M > A ? M < r ? (i = 0.707106781, n = 0, a = 0.707106781) : (n = Math[x(713)](M), i = L / n, a = S / n) : A < r ? (i = 0.707106781, n = 0.707106781, a = 0) : (a = Math.sqrt(A), i = P / a, n = S / a), this[x(1260)](i, n, a, t), this;
    }
    let g = Math[x(713)]((y - p) * (y - p) + (u - m) * (u - m) + (l - f) * (l - f));
    return Math[x(3373)](g) < 1e-3 && (g = 1), this.x = (y - p) / g, this.y = (u - m) / g, this.z = (l - f) / g, this.w = Math.acos((h + _ + v - 1) / 2), this;
  }
  [s(3085)](e) {
    const x = s;
    return this.x = Math[x(3085)](this.x, e.x), this.y = Math[x(3085)](this.y, e.y), this.z = Math[x(3085)](this.z, e.z), this.w = Math.min(this.w, e.w), this;
  }
  [s(1803)](e) {
    const x = s;
    return this.x = Math[x(1803)](this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math[x(1803)](this.z, e.z), this.w = Math.max(this.w, e.w), this;
  }
  [s(3135)](e, x) {
    const t = s;
    return this.x = Math[t(1803)](e.x, Math[t(3085)](x.x, this.x)), this.y = Math.max(e.y, Math[t(3085)](x.y, this.y)), this.z = Math.max(e.z, Math.min(x.z, this.z)), this.w = Math[t(1803)](e.w, Math[t(3085)](x.w, this.w)), this;
  }
  clampScalar(e, x) {
    const t = s;
    return this.x = Math[t(1803)](e, Math.min(x, this.x)), this.y = Math[t(1803)](e, Math[t(3085)](x, this.y)), this.z = Math[t(1803)](e, Math.min(x, this.z)), this.w = Math[t(1803)](e, Math.min(x, this.w)), this;
  }
  [s(907)](e, x) {
    const t = s, i = this[t(3105)]();
    return this.divideScalar(i || 1).multiplyScalar(Math[t(1803)](e, Math[t(3085)](x, i)));
  }
  [s(2697)]() {
    const e = s;
    return this.x = Math[e(2697)](this.x), this.y = Math.floor(this.y), this.z = Math[e(2697)](this.z), this.w = Math[e(2697)](this.w), this;
  }
  ceil() {
    const e = s;
    return this.x = Math[e(756)](this.x), this.y = Math[e(756)](this.y), this.z = Math[e(756)](this.z), this.w = Math[e(756)](this.w), this;
  }
  [s(1981)]() {
    const e = s;
    return this.x = Math[e(1981)](this.x), this.y = Math[e(1981)](this.y), this.z = Math[e(1981)](this.z), this.w = Math[e(1981)](this.w), this;
  }
  [s(707)]() {
    const e = s;
    return this.x = this.x < 0 ? Math[e(756)](this.x) : Math[e(2697)](this.x), this.y = this.y < 0 ? Math[e(756)](this.y) : Math[e(2697)](this.y), this.z = this.z < 0 ? Math[e(756)](this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math[e(756)](this.w) : Math[e(2697)](this.w), this;
  }
  [s(3515)]() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  [s(1454)](e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  [s(2296)]() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  [s(3105)]() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    const e = s;
    return Math.abs(this.x) + Math[e(3373)](this.y) + Math.abs(this.z) + Math[e(3373)](this.w);
  }
  [s(608)]() {
    const e = s;
    return this.divideScalar(this[e(3105)]() || 1);
  }
  [s(3399)](e) {
    const x = s;
    return this[x(608)]()[x(580)](e);
  }
  [s(2841)](e, x) {
    return this.x += (e.x - this.x) * x, this.y += (e.y - this.y) * x, this.z += (e.z - this.z) * x, this.w += (e.w - this.w) * x, this;
  }
  [s(2979)](e, x, t) {
    return this.x = e.x + (x.x - e.x) * t, this.y = e.y + (x.y - e.y) * t, this.z = e.z + (x.z - e.z) * t, this.w = e.w + (x.w - e.w) * t, this;
  }
  [s(2828)](e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, x = 0) {
    return this.x = e[x], this.y = e[x + 1], this.z = e[x + 2], this.w = e[x + 3], this;
  }
  toArray(e = [], x = 0) {
    return e[x] = this.x, e[x + 1] = this.y, e[x + 2] = this.z, e[x + 3] = this.w, e;
  }
  [s(804)](e, x) {
    const t = s;
    return this.x = e.getX(x), this.y = e.getY(x), this.z = e[t(1341)](x), this.w = e[t(3549)](x), this;
  }
  [s(3116)]() {
    const e = s;
    return this.x = Math[e(3116)](), this.y = Math.random(), this.z = Math[e(3116)](), this.w = Math[e(3116)](), this;
  }
  *[Symbol[s(3445)]]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class oe extends Ye {
  constructor(e = 1, x = 1, t = {}) {
    const i = s;
    super(), this[i(426)] = !![], this[i(1631)] = e, this[i(1674)] = x, this[i(3611)] = 1, this[i(1833)] = new Mx(0, 0, e, x), this[i(1199)] = ![], this.viewport = new Mx(0, 0, e, x);
    const n = { width: e, height: x, depth: 1 };
    this[i(2431)] = new Ux(n, t.mapping, t[i(578)], t[i(3221)], t[i(999)], t[i(991)], t[i(448)], t.type, t[i(2447)], t[i(523)]), this.texture[i(546)] = !![], this[i(2431)].flipY = ![], this[i(2431)].generateMipmaps = t[i(3632)] !== void 0 ? t[i(3632)] : ![], this[i(2431)][i(2060)] = t.internalFormat !== void 0 ? t[i(2060)] : null, this[i(2431)][i(991)] = t[i(991)] !== void 0 ? t[i(991)] : Cx, this.depthBuffer = t.depthBuffer !== void 0 ? t.depthBuffer : !![], this.stencilBuffer = t[i(686)] !== void 0 ? t[i(686)] : ![], this[i(1708)] = t[i(1708)] !== void 0 ? t[i(1708)] : null, this.samples = t[i(1820)] !== void 0 ? t[i(1820)] : 0;
  }
  setSize(e, x, t = 1) {
    const i = s;
    (this[i(1631)] !== e || this.height !== x || this[i(3611)] !== t) && (this[i(1631)] = e, this.height = x, this.depth = t, this[i(2431)][i(450)][i(1631)] = e, this[i(2431)][i(450)][i(1674)] = x, this[i(2431)][i(450)][i(3611)] = t, this.dispose()), this[i(2483)][i(1260)](0, 0, e, x), this[i(1833)][i(1260)](0, 0, e, x);
  }
  [s(2272)]() {
    const e = s;
    return new this[e(2787)]().copy(this);
  }
  [s(2875)](e) {
    const x = s;
    this[x(1631)] = e.width, this[x(1674)] = e.height, this[x(3611)] = e[x(3611)], this[x(2483)][x(2875)](e[x(2483)]), this.texture = e[x(2431)][x(2272)](), this[x(2431)][x(546)] = !![];
    const t = Object[x(1188)]({}, e[x(2431)][x(450)]);
    return this[x(2431)][x(796)] = new $t(t), this[x(471)] = e[x(471)], this[x(686)] = e[x(686)], e.depthTexture !== null && (this[x(1708)] = e[x(1708)][x(2272)]()), this[x(1820)] = e.samples, this;
  }
  [s(3387)]() {
    this[s(3157)]({ type: "dispose" });
  }
}
class va extends Ux {
  constructor(e = null, x = 1, t = 1, i = 1) {
    const n = s;
    super(null), this[n(1204)] = !![], this[n(450)] = { data: e, width: x, height: t, depth: i }, this[n(999)] = Bx, this[n(991)] = Bx, this[n(1139)] = Zx, this[n(3632)] = ![], this[n(1739)] = ![], this.unpackAlignment = 1;
  }
}
function ba() {
  const d = ["addLighting", "getUint16", "postEffects", "COMPRESSED_SRGB8_ETC2", `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, "cumulativeWeightAdditive", "pushState", "_lendAction", "THREE.WebGLRenderer: Context Lost.", "analyser", "filter", "#define texture2D texture", `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`, "getPointsHoles", "_viewportCount", "pluginCallbacks", "getTargetRaySpace", "focus", "fadeOut", "renderTarget1", "addGroup", "target0", "setAttribute", "isWebGLArrayRenderTarget", "makeXRCompatible", `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, vec2 fullSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		
		vec2 lodFudge = pow( 1.95, lod ) / fullSize;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec2 fullSize = vec2( textureSize( sampler, 0 ) );
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), fullSize, floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), fullSize, ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`, "orbit", "getFilter", "pinchend", "_camera", "#define varying out", "mimeType", "toStringTag", "register", "depth", "setComponent", "computeLineDistances", "antialias", "isBox2", "setTargetAtTime", "refreshFogUniforms", "directionalLightShadows", "#define USE_NORMALMAP", "blendMode", "getObjectByProperty", "uniform2i", "THREE.ExtrudeBufferGeometry has been renamed to THREE.ExtrudeGeometry.", "COMPRESSED_RGBA_ASTC_4x4_KHR", "skinIndex", "_clearcoat", "texelWidth", "#define USE_SHADOWMAP", "warn", "mousedown", "DecodeArrayToMesh", "generateMipmaps", "uniformBlockBinding", "isBufferGeometry", "_setSize", "_createOnRestPromise", "specularColorMap", "' parameter is undefined.", "_enabled", "updateMatrixWorld", "detail", "checkShaderErrors", "dampingFactor", "map", "lastIndex", "setupCamera", "visibleSelector", "__hasExternalTextures", "TRIANGLES", "_getValue_arrayElement", "setMatrixAt", "#define MORPHTARGETS_TEXTURE_STRIDE ", "decompose", "triangulate", "refreshMaterialUniforms", "THREE.KeyframeTrack: no keyframes in track named ", "_applyPMREM", "uri", `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`, "text/javascript", "compressedTexSubImage3D", "#define UVS_VERTEX_ONLY", "THREE.Pass: .render() must be implemented in derived pass.", "setupRenderTarget", "_getNodeRef", "clearcoatTexture", "skipped", "KHR_MATERIALS_IOR", "isDepthTexture", "setTexture2D", "TOUCH_ZOOM_ROTATE", "CubeCamera", "ROTATION", "clearcoatNormalMap", "THREE.WebGLProgram: Program Info Log:", "Group", `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			 return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float R21 = R12;
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, "index", "#define USE_SPECULARINTENSITYMAP", "_removeAllEventListeners", 'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.', "rot", "StereoCamera", "int", "ktx2Loader", "phiStart", "autoClose", "addScalar", "boundingSphere", "initTexture", "far", "specularmap", "#define varying in", "bones", "sigmaRadians, ", `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, "UVGenerator", "prevZ", "Matrix4", `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, "#define texture2DLodEXT textureLod", "_bindings", "THREE.KeyframeTrack: Time is not a valid number.", "isRawShaderMaterial", "directional", "RawShaderMaterial", "DT_FLOAT32", "timeDelta", "animation_", "name", 'Unsupported color space conversion, "', "_setValue_fromArray", "#ifdef USE_INSTANCING", "modelMatrix", "KHR_DRACO_MESH_COMPRESSION", "ZIP_COMPRESSION", "THREE.GLTFLoader: Missing min/max properties for accessor POSITION.", "isInterpolantFactoryMethodGLTFCubicSpline", "isHemisphereLightProbe", "acCompressedSize", "paused", "setFromArray", "setURLModifier", "pointerId", "createRenderbuffer", ` float;
precision `, "iridescence", "KHR_binary_glTF", "_setAdditiveIdentityNumeric", "getInterpolation", "#define USE_IRIDESCENCE", "deleteFramebuffer", "getFilters", "_setValue_unavailable", " is unsupported", "loadTexture", "referenceCount", "hoveron", "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", "getError", "blurTexture5", "loadingScreenID", "_instance_", "concat", "ROTATE", "opacity", "customVertexShaderID", "_setIdentity", "_setEndings", "webkitUserSelect", "bevelEnabled", "evaluate", "mode", "_iridescence", "attachShader", "_zoomEnd", "lookInDirectionOf", "display-p3", "refractionRatio", 'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', "pixelStorei", "#ifdef USE_TANGENT", "_isUserControllingDolly", "TOUCH_DOLLY_OFFSET", "depth_vert", "mouse", "three.js r", "refs", "isShadowMaterial", "glslVersion", "rectAreaLength", "minStaticFrames", "onUploadCallback", "KHR_TEXTURE_BASISU", "len", "deleteVertexArray", "THREE.EXRLoader: unsupported type: ", "mantissaTable", "pointerLockElement", "controls", "bindFramebuffer", "connected", "getMixer", "Curve", "image/png", "distanceSqToPoint", "enableVertexAttribArray", "isMatrix3", "backgroundCube_frag", "THREE.ColorManagement: .workingColorSpace is readonly.", "mask", "node", "getImageData", "blurTexture2", "getScene", "BlurDirectionX", "setPixelRatio", "CreateFromMorphTargetSequence", "THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeBufferGeometries() instead.", "phiSegments", "renderTargetsVertical", "textureHeight", "coneOuterGain", "isVector3", "THREE.KeyframeTrack: track type undefined, can not parse", "rendererExtensionFragDepth", "removeAttribute", "samplers", "ANGLE_instanced_arrays", "isWebGLRenderTarget", "getRenderTarget", "logarithmicDepthBuffer", `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, "beforeRoot", "setStyle", "makeRotation", "style", "DT_INT8", "box2i", "preventDefault", "rgb(", "getRandomRange", "_takeBackControlInterpolant", "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.", "vertexAttribDivisor", "triangles", "localToWorld", "loadMaterial", "addScaledSH", "targetRaySpace", "alphaToCoverage", "format", "uniform3i", "image", "getWorldQuaternion", "makeBasis", "cameraParams", "install", "defineProperties", "_setValue_array", "getUV", "points_vert", "fogExp2", "revokeObjectURL", "poleAxis", "COMPRESSED_RGBA_ASTC_8x6_KHR", "_paths", "onerror", "pop", "THREE.WebGLTextures: Trying to use ", "getFocalOffset", "isAmbientLight", "isUniformsGroup", "bumpScale", "depthBuffer", "KHR_materials_ior", "lookAtTarget", "IcosahedronGeometry", "metallicRoughnessTexture", "sortObjects", "iridescenceIOR", "framebuffer", "layers", "lineDistance", "decodeAudioData", "domElement", "#define DECODE_VIDEO_TEXTURE", "linkProgram", "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.", "getUniforms", "isCubemap", "isOverlayActive", "render", "matrixWorld", "uvsVertexOnly", "decoderConfig", "OFFSET", "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ", "tiltY", "hdr", "_textureToCubeUV", "displacementBias", "tangents", "isMeshBasicMaterial", "build", "colliderMeshes", "innerRadius", "getBoneByName", "Spherical", "isClockWise", "1021660CrOPem", "onClickAnimations", "getReader", "isWebGL2", "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG", "intersectBox", "getFragmentShaderID", "SCALE", "crossFadeTo", "isSprite", "params", "hoverOverCallback", "isOrthographicCamera", "baseColorTexture", "preview", "KHR_materials_emissive_strength", "encoding", "extractRotation", "THREE.WebGLRenderer: Context Restored.", "bindBufferBase", "baseColorFactor", "decode", ") to (", "delta", "setSize", "attenuationDistance", "error", `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`, "clippingState", "pointShadow", "precision", "getPoint", "recast", "_setValue_direct", "isFog", "loopStart", "makeRotationY", "hemi", "THREE.KeyframeTrack: Unsupported typeName: ", "isRenderTargetTexture", "OES_texture_float_linear", "isInstancedBufferGeometry", "trim", "boneMatrices", "center", "Something wrong with HUF_ENCSIZE", "targetPosition", "2.3.1", "apply", "threshold", "syncWith", "_isUserControllingRotate", "cf2", "depth_frag", "getSize", "setFunc", "extensionsRequired", "clearDepth", "uniform1uiv", "type", "pose", "URL", "focalOffset0", "activeTexture", "boneInverses", "THREE.BufferAttribute: copyVector3sArray() was removed in r144.", "endingStart", "bottom", "_updateNearPlaneCorners", "THREE.SphereBufferGeometry has been renamed to THREE.SphereGeometry.", "fromEquirectangular", "wrapS", "depthSegments", "multiplyScalar", "decodePrimitive", "coneInnerAngle", "projectionMatrixInverse", "resetControlsLimits", "getRefDistance", "flipSided", "not supported, using", "blendFunc", "#ifdef USE_SKINNING", "setRequestHeader", "rotation", "offset", "THREE.Material: '", "precision mediump sampler2DArray;", "Material", "uniform2iv", "path", "setup", "session", "_grip", "TOUCH_ZOOM_TRUCK", "toneMapping", "XZX", "EQUAL", "lineWidth", "shadow_pass", "cameraCache", "normalize", "lit", "THREE.PropertyBinding: Trying to update node for track: ", "compression", "WebGLRenderer: Floating point depth texture requires WebGL2.", "resolution", "sort", "parseObject", "destination", "COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR", "distanceToPoint", "#define DOUBLE_SIDED", "		attribute vec3 morphTarget6;", "morphAttributeCount", "_workIndex", "lightMapIntensity", "premultipliedAlpha", "exec", "toneMapped", "_clock", "onError", "displacementMap", "updateWorldMatrix", "_addInactiveBinding", "uniform1ui", "EPSILON", "directionalShadowMatrix", "dTheta", "Invalid component type.", "OES_vertex_array_object", "bias", "upload", "setOptions", "absellipse", "createMaterialFromType", "#define USE_TRANSMISSION", "iridescenceThicknessMinimum", "setAxisAngleFromQuaternion", "setFromPoints", "SkinnedMesh", "shaderCache", "offsets", "stencilFunc", "canvas", "_isActiveAction", "pointShadowMatrix", "distanceRGBA", "transitionstart", "meshPerAttribute", "showDynamicHTML", "orientationZ", "HemisphereLight", "getUint8", "loadBuffer", "scene", "linearRampToValueAtTime", "emissiveFactor", "resetCamera", "fromArray", "mapping", "mipInt", "isLight", "__webglInit", "target", "getClearColor", "isSplineCurve", "resolvedProperty", "workerLimit", "parseMaterials", "decoderBinary", "setLoopEnd", "side", "specularColorTexture", "outerConeAngle", "bufferView", "setFromMatrixPosition", "translateOnAxis", "unexpected EOF", "stencilBuffer", "_localRoot", "forward", "copyPosition", `#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`, "COMPRESSED_SIGNED_RED_RGTC1_EXT", "cn1", "resetDuration", "touchend", "MOZ_EXT_texture_filter_anisotropic", "updateMorphTargets", "2537484MCGuVh", "workerNextTaskID", "activate", "average", "150", "isVector4", "renderOrder", "000000", "currentTime", "roundToZero", "bindTexture", "setMaterial", "5rfNATc", "#define TANGENTSPACE_NORMALMAP", "setY", "sqrt", "ptr", "needsLights", "copyTextureToTexture", "elements", "applyQuaternion", "morphNormal", "specularTexture", "visibilityState", "luminosityThreshold", "addHDR", "specularColorFactor", "isLine", "OES_standard_derivatives", "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", "cn2", "_bindAction", "getWorldScale", "ambientLightColor", "setScissorTest", "defaultRotationDistance", "expandByVector", "tiltXArr", "hand", "setFromMatrix4", "bumpmap", "state", "OES_texture_half_float_linear", "skeletons", "onPointerDownCallback", "OPAQUE", "autoReset", "tan", "YXY", "catch", "currentAction", "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.", "setDynamicHTML", "BindingType", "instanceColor", "useDepthPacking", "slerp", "group", "ceil", ":>> GLTF element unrecognized:", "bumpMap", "ENVMAP_MODE_REFRACTION", "ZXY", "getVertexShaderID", `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	#ifdef USE_IRIDESCENCE
		reflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );
	#else
		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, "setBuffer", `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`, "resolveURL", "__webglColorRenderbuffer", "_focalOffsetEnd", "InstancedBufferGeometry", "_targetEnd", "depthTest", "roughness", "webkitAudioContext", "THREE.MaterialLoader: Undefined texture", "locationSize", "THREE.WebGLTextures: Unsupported texture encoding:", "DecodeArrayToPointCloud", "#endif", "nMips", "numSpotLights", "THREE.ObjectLoader: Undefined geometry", "getX", "intersectsPlane", "userSelect", "planeadded", "colorMask", "#define SHADER_NAME ", "THREE.ExtrudeGeometry: vec does not exist", "getComponent", "_addInactiveAction", "pointerDownCallback", "lowp", "curveSegments", `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, "uniform1i", "detached", "source", "scrollHeight", "loadBufferView", "longitudinal", "alpha", "isGroup", "physical", "TOUCH_DOLLY_ROTATE", "fromBufferAttribute", "subscribe_", "zoneBox", "sheenColor", "pLinear", ".morphTargetInfluence[", `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, "normalMap", "containsBox", "decodeGltfBuffer", "valueSize", "LEFT", "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.", "addEventListener", "UnrealBloomPass.v", "getHand", "onload", "experimental-webgl", `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, "LTC_HALF_2", "jsonData", "Quaternion", "removeFilter", "renderTarget.depthTexture must be an instance of THREE.DepthTexture", "itemError", "texParameteri", "iframeID", "isDirectionalLightShadow", "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.", "pinching", `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, "identity", "sessionend", "cursor", "onHoverOver", "numRectAreaLights", "bevelSegments", "setColors", "isCubicBezierCurve", "minZoom", "setViewport", "getDependency", "( value )", " extension not supported.", "getProgramParameter", "setInterpolation", `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, "selectstart", "extensionDrawBuffers", "lookAtTargetSize", "getReferenceSpace", "_setValue_direct_setNeedsUpdate", "wireframeLinejoin", "HemisphereLightHelper", `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, "colorWrite", "#define USE_CLEARCOAT_ROUGHNESSMAP", "uniform2f", "THREE.GLTFLoader: Ignoring primitive type .extras, ", "translate", "isMobileDevice", "SplineCurve", "getDistanceModel", "getCamera", "isPresenting", "createBoundingSphere", "unbind", ");  ", "SHADOWMAP_TYPE_BASIC", "EdgesGeometry", "OES_texture_half_float", "terminate", "platform", "gammaFactor", "getter", "_loadLibrary", "specular", "indexOf", "deleteRenderbuffer", "XYZ", `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, "isInstancedInterleavedBuffer", "getCompositeMaterial", "bytesPerLine", "aEndAngle", "_selected", "translateY", "metalnessmap", "destroy", "setFromProjectionMatrix", "iccProfile", "isSpotLightShadow", "pointercancel", "code", "rotateY", "__cache", `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`, "resultBuffer", "halfWidth", "_halfBlur", "shaderTextureLOD", "shadowNormalBias", "clampLength", "powerPreference", "camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information.", "values", "polygonOffsetUnits", "_fromTexture", "getValueSize", "stop", "setPlugins", "getElapsedTime", "LINE_STRIP", "_nActiveControlInterpolants", "_scheduleFading", "normalMapType", "numDirectionalShadows", "high-performance", "loadModel", "Sphere", "DefaultInterpolation", "setMask", "_pingPongRenderTarget", `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`, "#define ", "blendEquationSeparate", "phiLength", "RIGHT", "sprite_vert", "B44A_COMPRESSION", "setAxisAngleFromRotationMatrix", `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, "http://www.w3.org/1999/xhtml", "getFloat32", "listener", "wrong scanline width", "gltf children :>> ", "getClearAlpha", "CameraHelper", "hemiLength", "clearcoatMap", "EquirectangularToCubeUV", "COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR", "https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/jsm/libs/draco/", "taskConfig", "toneMappingExposure", `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, "enabledAttributes", "setDecoderConfig", "_viewports", "EXT_frag_depth", "crossVectors", "TEXTURE_MAX_ANISOTROPY_EXT", "COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR", "wrappedModels", "enableAll", "envmap", "skeleton", "propertyName", "YZX", "imul", "fogDensity", "linecap", "_focalOffsetVelocity", "VALIDATE_STATUS ", "PolarGridHelper", "insertAdjacentHTML", "addHandler", "getScissorTest", "DEFAULT_ORDER", "KHR_materials_transmission", "updateSceneZones", "wireframeLinewidth", "PXR24_COMPRESSION", "renderBufferDirect", "extendParams", "selectend", "getShaderParameter", "sprite", "forceContextLoss", "onBuild", "COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT", "THREE.WebGLRenderer: Unsupported uniform value type.", "shadowSide", "metalnessMap", "setReferenceSpaceType", "minFilter", "deleteProgram", "parseGeometries", "highp", "attributesNum", "CreateClipsFromMorphTargetSequences", "uniformsGroups", "shadowMapType", "magFilter", "copyVector3sArray", "THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.", "compressedTexImage2D", "isFogExp2", "rotateX", "uniform mat4 projectionMatrix;", "move", "player", "' is not a property of this material.", "renderTargetsHorizontal", "THREE.KeyframeTrack: track name is undefined", "KHR_MATERIALS_UNLIT", "autoUpdate", "SCALAR", `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, "hierarchy", "wheel", "nodeCache", "makeScale", "nCachedObjects_", "uniformMatrix3fv", "next", "numPointLightShadows", "divide", "THREE.WebGLState: Invalid blending: ", "parseTrackName", "onProgress", "isRectAreaLight", "fromCubemap", "detectSupport", "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.", "sheen", "toHalfFloat", "touchAction", "morphAttributes", "isColor", "activeZoneIndex", "numClippingPlanes", "shiftTable", "depthPacking", "content", "pen", "setDecoderPath", `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, "setRGB", "raycastManager", "onPointerDown", "createFramebuffer", "#extension GL_OES_standard_derivatives : enable", "subarray", "copyPass", "thicknessMap", '"></iframe>', "THREE.IcosahedronBufferGeometry has been renamed to THREE.IcosahedronGeometry.", "setModelMatrixData", "exponentTable", "display", "projectionMatrix", "_domElement", "KHR_MATERIALS_SHEEN", "_blurMaterial", "subVectors", "withCredentials", "parameters", `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, "_taskLoad", "THREE.Object3D.add: object can't be added as a child of itself.", "matrix", "addColors", "COLOR_0", "files", `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, "MeshDepthMaterial", "ZOOM", "transmissionTexture", "releaseShaderCache", "setOpaqueSort", "hasLinearVelocity", "getTangentAt", "removeEventListener", "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC", "test", "getMaxScaleOnAxis", "_width", "uniform1f", "isArcCurve", "setCrossOrigin", "MIN_EXT", "phi", "clear", "images", "THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.", `#include <common>
				varying vec2 vUv;
				uniform sampler2D colorTexture;
				uniform vec2 texSize;
				uniform vec2 direction;

				float gaussianPdf(in float x, in float sigma) {
					return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;
				}
				void main() {
					vec2 invSize = 1.0 / texSize;
					float fSigma = float(SIGMA);
					float weightSum = gaussianPdf(0.0, fSigma);
					vec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;
					for( int i = 1; i < KERNEL_RADIUS; i ++ ) {
						float x = float(i);
						float w = gaussianPdf(x, fSigma);
						vec2 uvOffset = direction * invSize * x;
						vec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;
						vec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;
						diffuseSum += (sample1 + sample2) * w;
						weightSum += 2.0 * w;
					}
					gl_FragColor = vec4(diffuseSum/weightSum, 1.0);
				}`, "isSpriteMaterial", "PIZ_COMPRESSION", "getBoundingSphere", "ray", "getViewerPose", "_setAdditiveIdentityQuaternion", "OrthographicCamera", "XYX", "ready", "_zoomVelocity", "SetterByBindingTypeAndVersioning", "setValues", "#define USE_SHEENCOLORMAP", "loop", "COMPRESSED_RGB8_ETC2", "vertex", "THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.", "updateMatrices", "clearcoatNormalScale", "boxCenter", "componentType", "fileLoader", "referencePosition", "responseType", "defineProperty", "rotateTo", "DirectionalLight", "isDataTexture", "getPlaybackRate", "LOD", "texStorage3D", "wireframe", "#define USE_THICKNESSMAP", "matrixAutoUpdate", "getClip", "setupLights", "KHR_MATERIALS_EMISSIVE_STRENGTH", "isFrontFacing", "intersectTriangle", "EXT_texture_avif", "directionalShadow", "attribute", "getPlanes", "Content-Length", "ACTION", "PointCloud", "wrapR", "EntireArray", "getVolume", "isData3DTexture", "_oldClearColor", "reorder", "programtype", "__cacheIndex", "scenes", "emissiveIntensity", "origin", "decodeDracoFile", "intersectsLine", "needsPMREMUpdate", "#define attribute in", "accumulate", "invalidateFramebuffer", `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`, "uniform3ui", "isEuler", "classList", "JSON", "iridescenceTexture", "arcLengthDivisions", "clearcoatRoughness", "manhattanDistanceTo", "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.", "uv2", "setXYZ", "addVectors", "freeze", "Reinhard", "_clip", "lightmap", " - ", "blurSamples", "_callbacks", "faceIndex", "THREE.KeyframeTrack: Out of order keys.", "getViewportCount", "expandByObject", "_isUserControllingTruck", "parser", 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', "distance", "shift", `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, "expandByPoint", "setFromCartesianCoords", "assign", "updateRenderState", "#define USE_ALPHAMAP", "UnrealBloomPass.h", "maxPolarAngle", "300 es", "idx", "renderState", "entries", "points", "dataWindow", "scissorTest", "reflect", "deleteShader", "THREE.Color: Unknown color ", "mouseup", "isDataArrayTexture", "joints", "view", "pixelType", "rest", "uniform4fv", " keyframe track named ", "hiddenSelector", "probe", `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, "LatheGeometry", "mouseButtons", "createShader", "_timeScaleInterpolant", "useLegacyLights", "zoomTo", "forEach", "#define USE_MORPHCOLORS", "rgb", "#define USE_INSTANCING", "radialSegments", "nearDistance", `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`, "none", "cancel", "rectAreaLTC2", "computeFrenetFrames", "setupDepthRenderbuffer", "radius", "buttons", `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, "open", "added", "customFragmentShaderID", "extensionsUsed", "detected. Clean the caches or recreate your infrastructure when reloading scenes.", "_dispose", "setFromAxisAngle", "isInstancedBufferAttribute", "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.", "__webglMultisampledFramebuffer", "_addAllEventListeners", `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`, "matcap", `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, "LineBasicMaterial", "useMultisampledRTT", "isLightProbe", `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, "fromWorkingColorSpace", "hemisphereLights", "GetEncodedGeometryType", "WEBGL_compressed_texture_s3tc_srgb", "_mixBufferRegionAdditive", "applyNormalMatrix", "intersectsObject", "set", "shaderName", "validate", "orientationX", "readPixels", "intersectsTriangle", "writeBuffer", "count", "_targetRay", "THREE.AnimationObjectGroup: Different objects with the same UUID ", "COMPRESSED_RGBA_ASTC_5x4_KHR", "THREE.WebGLProgram: Unsupported encoding:", "drawElementsInstanced", "normals", "shininess", "uvTransform", "read", "decoderPending", "createLightContainer", "WEBGL_lose_context", "animations", "toon", "texSubImage2D", "requestHeader", "linedashed_vert", "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '", "POINT_CLOUD", "shape", "light", "CatmullRomCurve3", "updateMatrix", "_lendControlInterpolant", "convertSRGBToLinear", "diagnostics", "image/jpeg", "COMPRESSED_RGBA_BPTC_UNORM_EXT", "getLength", "projectPoint", "_propertyBindings", "onLoad", "createInterpolant", "COMPRESSED_RGBA_ASTC_12x10_KHR", "_loadLight", "#define USE_SIZEATTENUATION", "randomDirection", "#define USE_LIGHTMAP", "numClipIntersection", "failIfMajorPerformanceCaveat", "tubularSegments", "two", "vertex-colors:", "promise", "instanceMatrix", "worldToLocal", "fill", "removeFromParent", "CurvePath", "isBone", "bool", "__webglFramebuffer", "frame", "THREE.WebGLState:", `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, "ALWAYS", "attribute vec3 normal;", "DWAA_COMPRESSION", "_getValue_unbound", "getSettings_", "occlusionTexture", "meshphong_vert", "_target", "pointer", "isHemisphereLight", "nextZ", "reverse", "addLevel", "numPlanes", "spot", "blendDst", "KHR_materials_volume", "_invokeOne", "getZ", "_viewport", "TorusGeometry", "copySRGBToLinear", "catmullrom", "unbindTexture", "nodes", "BoxHelper", `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`, "setPosition", "KHR_materials_sheen", "models", "geometry", "specularIntensity", "COMPRESSED_RGBA_ASTC_5x5_KHR", "isArrayCamera", "gltfExtensions", 'THREE.GLTFLoader: Failed to load buffer "', "parse", "_focalOffset0", "_boundary", "radToDeg", "autoClear", "THREE.RGBELoader: unsupported type: ", "pos", "bevelOffset", "__size", "SHADOWMAP_TYPE_PCF", "setMimeType", "halfWindowWidth", "EXT_color_buffer_float", "BoxGeometry", "_sceneToCubeUV", "innerHTML", "onPointerUp", "top", "total", "processModel", "image/webp", "isSphericalHarmonics3", "resetState", "logDepthBufFC", "setHSL", "associations", "The gryto motion sensor is not supported on this device.", "element", "ZYX", "cacheLengths", "getEffectiveWeight", "THREE.GLTFLoader: No DRACOLoader instance provided.", "numSpotLightShadows", "getCameraBoundsObject", "getUtoTmapping", "__webglDepthbuffer", "clearcoatRoughnessTexture", "webglcontextrestored", "lerpHSL", "camera-controls: fitTo() cannot be used with an empty box. Aborting", "coneOuterAngle", `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, "_focalOffset", "clipIntersection", "_removeInactiveAction", "makeShear", "_height", "bloomTintColors", "number", "__currentAnisotropy", "tube", "lines", "coplanarPoint", "lightCache", "object", "fromEquirectangularTexture", "THREE.RingBufferGeometry has been renamed to THREE.RingGeometry.", "_frustum", "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.", "interactables", "PointerEvent", "steps", "resourcePath", "getRenderer", "box", "getNormalMatrix", "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", "_hovered", "skinning", "getIntersectableObjects", "nextSceneZone", "Custom", "halfHeight", "	attribute vec4 skinIndex;", "touch", "views", "THREE.DRACOLoader: Decoding failed: ", "getActiveMipmapLevel", "loadTextureImage", "index0AttributeName", "_targetGroup", "contentType", "SphericalGaussianBlur", "NOTEQUAL", "boolean", "isScene", "MAX_VALUE", "_accuIndex", "isMaterial", "near", "uniform bool isOrthographic;", "sourceCache", "charAt", "textureCache", "alphaMap", "dot", "customDistanceMaterial", "morphTargetsTexture", "blob", "roughnessmap", "transmissionFactor", "getEffectiveTimeScale", "directionalLights", "rotationTarget", "THREE.WebGLAttributes: Unsupported buffer data format: ", "defaultAttributeTypes", "_startedAt", "_sigmas", "clipShadows", "InterpolantFactoryMethodLinear", "#define USE_METALNESSMAP", "distanceSq", "_blur", "numSpotMaps", `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, "history", "end", "handedness", "envMap", "properties", "compile", "isPostEffectsEnabled", "_zoomInternal", "point", "minAzimuthAngle", "vector", "coneCos", "MeshMatcapMaterial", "useFog", "shadowCameraFar", "WARNING: Multiple instances of Three.js being imported.", "dollySpeed", "finalComposer", "farDistance", "XYZ3d-visible", "setType", `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, "toArray", "bgMesh", "orientationY", `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, "getInt8", "meshes", "removePass", "disable", "startTime", "COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR", "THREE.TorusBufferGeometry has been renamed to THREE.TorusGeometry.", "clientX", "InterpolantFactoryMethodSmooth", "onUpdate", "iridescenceIor", `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`, "status", "setRenderTargetFramebuffer", "lastChangedTime", "setDuration", "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat", "EXT_meshopt_compression", 'THREE.ObjectLoader: No "image" specified for', "morphTarget", "setState", "createMediaElementSource", "getAttribLocation", "getDetune", "loadAnimation", "invert", "targetObject", "TRANSLATION", "TOUCH_ROTATE", "flatShading", `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, "_lerpAdditive", "stencilRef", "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", "compositeMaterial", " samples when the maximum is set to ", "autoplay", "THREE.GLTFLoader: Image ", "vector2", "_actionsByClip", "getWireframeAttribute", "running", "WEBGL_depth_texture", "toWorkingColorSpace", "morphTargetsTextureSize", "createProgram", "supportsVertexTextures", "_sheen", "setFromSpherical", "NAMES", "KHR_TEXTURE_TRANSFORM", "getFilmWidth", "setRotationFromEuler", "	attribute vec4 skinWeight;", "setDampFactor", "orthographic", "blendEquationAlpha", "getActiveAttrib", "binding", "THREE.KeyframeTrack: Track is empty.", "isMeshToonMaterial", "light_", "COMPRESSED_RGBA_S3TC_DXT1_EXT", "drawBuffers", "THREE.WebXRManager: Cannot change reference space type while presenting.", "rotate", "_offsetPrev", "calculateInverses", "getBarycoord", "maxMip", "Float32Array", "distanceRGBA_frag", `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, "background_vert", "setFromCoplanarPoints", "nodeName", "capabilities", "toFixed", "blockCount", "translation", "calc", "specularIntensityMap", "parseSkeletons", "setColor", "THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.", "1963028hHImQF", "metalness", "loadCamera", "dollyToCursor", "standard", "BackgroundMaterial", "setFromNormalAndCoplanarPoint", "texImage3D", "_hand", "HRTF", "cameraPosition", "_cachedIndex", "KHR_draco_mesh_compression", "anonymous", "emissive", "pbrMetallicRoughness", "THREE.OctahedronBufferGeometry has been renamed to THREE.OctahedronGeometry.", "find", "unproject", "LineCurve", "shadowMapEnabled", "ZIPS_COMPRESSION", "context", "defaultDampFactor", "isArray", "AudioContext", "setFromUnitVectors", "actionByRoot", "ignoreDepthValues", "primitives", "THREE.GLTFLoader: Legacy binary file detected.", "endShadows", "setOrbitPoint", "union", "precision ", "maxZoom", "_malloc", "diffuse", "uniformsNeedUpdate", "_addNodeRef", "#define textureCubeGradEXT textureGrad", "Sprite", "HORIZONTAL_PASS", "unregister", "THREE.WebGLRenderer:", "_parsedPaths", "width", "stencil", "THREE.Skeleton: No bone found with UUID:", "onEnded", "_objects", "getSceneWrapper", "cullFace", "radiusTop", "include", "left", "newAttributes", "uniform4iv", "_allocateTargets", "setClearAlpha", ".morphTargetInfluences[", "getSceneZoneByName", "KHR_lights_punctual", "CubicBezierCurve", "_initDecoder", "getBasisAt", "createModelContainer", "EXT_MESHOPT_COMPRESSION", "play", "truckSpeed", "cameraAnimations", "call", "transformDirection", "getCenter", "getObjectsByProperty", "clearcoatRoughnessMap", "uniform2uiv", "numDirLightShadows", "timeScale", "63zhfbTa", "InterpolantFactoryMethodDiscrete", "compressedTexImage3D", "points_frag", "distanceToPlane", "envMapCubeUVHeight", "uniform4i", "boundary", "positionX", "Box3", "height", "rotateCamera", "isWebGLCubeRenderTarget", "matrixWorldNeedsUpdate", "credentials", "distanceToSquared", "uniform2ui", "offsetHSL", "boneTransform", "updatePointer", "includes", "getHitObject", "getShaderInfoLog", "skin", "toNonIndexed", "xMin", "filmOffset", "KHR_texture_basisu", "one", "addDirectionalLight", "decodeGeometry", "mapPass", "thicknessTexture", "uniform vec3 cameraPosition;", "body", "customDepthMaterial", "generateMipmap", "updateProjectionMatrix", "numPointShadows", "CircleGeometry", "onended", "#define LEGACY_LIGHTS", "missing image size specifier", "getProgramInfoLog", "depthTexture", "getControllerGrip", "isCubicBezierCurve3", "makeRotationFromQuaternion", "initCatmullRom", "hoverOffCallback", "isTexture", "widthSegments", "isQuadraticBezierCurve", "gyro", "Path", "receiveShadow", "_mixBufferRegion", "createBufferSource", "atan2", "frontFace", "VSM_SAMPLES", "curveType", "_assignVertexColorSpace", "fitCameraOffset", "uniform4ui", "moveTo", "normalizeNormals", "_updateTime", "THREE.GLTFLoader: WebP required by asset but unsupported.", "splice", "_origIndex", "Skeleton", 'THREE.GLTFLoader: Custom UV sets in "', "	attribute vec4 color;", "onClick", "flipY", "getAttribute", `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, "num_components", "infinityDolly", "seqWithValue", "MOZ_WEBGL_compressed_texture_s3tc", "uses", "planes", "elapsedTime", "THREE.PolyhedronBufferGeometry has been renamed to THREE.PolyhedronGeometry.", "fixedFoveation", "iridescenceFactor", "cameras", "getHtmlData", "stats", "parseAnimations", "arraybuffer", "loadingScreen", "instanceCount", "Decoder", "_select", "_releaseTask", `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, "statusMessage", "#define USE_LOGDEPTHBUF_EXT", "clampWhenFinished", "inputSize", "auto", "cf3", `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, "isLineDashedMaterial", "stencilZFail", "setFromMatrix3Column", "exp", "texImage2D", "_lerp", "manhattanLength", "compressedTexSubImage2D", "getPointAt", "outputChannels", "requestAnimationFrame", "THREE.RGBELoader Read Error: ", "extrudePath", "createPanner", "textureWidth", `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`, "replace", "getController", "loaded", "setFocalOffset", "MatrixWorldNeedsUpdate", "YZY", "mipmapCount", "setFilter", "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.", "ltc_2", "boneTextureSize", "THREE.EXRLoader: provided file is currently unsupported.", "intensity", "_effectiveTimeScale", "ToneMapping( color ); }", "removed", "isLineCurve", "max", "getPlane", "_nActiveActions", "uncacheRoot", "texSize", '" extension not yet supported.', "raycastTarget", "TRIANGLE_STRIP", "value", "yMin", "mousemove", "rootNode", "wrappedAnimations", "THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required.", "#define USE_SHEEN", "verticalDragToForward", "_cache", "samples", "THREE.GLTFLoader: Missing camera parameters.", "textures", "tracks", "floatView", "compose", "extensionShaderTextureLOD", "setFromMatrixScale", "#define USE_INSTANCING_COLOR", "goToNextZone", "THREE.PropertyBinding: Can not bind to material as node does not have a material.", "dashSize", "stencilFail", "scissor", "maxTextures", `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, "#define USE_MAP", "EXT_shader_texture_lod", "uniform3fv", "WEBKIT_EXT_texture_filter_anisotropic", "projectOnPlane", "copySampleValue_", "isView", "boundaryEnclosesCamera", "depthFunc", "disconnected", "renderbufferStorage", "saveOriginalState", "texParameterf", "tension", "stencilZPass", "intervalChanged_", "BlurDirectionY", "createProjectionLayer", "loadMesh", "texCoord", ".dampingFactor has been deprecated. use smoothTime (in seconds) instead.", "call to abstract method", "CubemapFromEquirect", `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`, "_slerp", "same-origin", "MeshStandardMaterial", "texelHeight", "spotShadowMap", "COMPRESSED_RGBA_ASTC_10x8_KHR", "linearVelocity", "#define VERTEX_TEXTURES", "preload", "EXT_texture_filter_anisotropic", "material", "pointShadowMap", "objectName", "seq", "matrixWorldInverse", "getDependencies", "materials", "createVertexArrayOES", `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`, "requestReferenceSpace", `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, "_interpolants", "decoded", "getInteractables", "setTexture3D", "transparent", "bindMode", "putImageData", "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.", "LTC_FLOAT_2", "projectOnVector", "knownActions", "xRadius", "instancingColor", `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, "THREE.DRACOLoader: Unexpected geometry type.", "drawBuffersWEBGL", "interactable", "Linear", "WEBGL_color_buffer_float", "ENVMAP_MODE_REFLECTION", "cn4", "isLastEnabledPass", "#define FLIP_SIDED", "applyMatrix3", "	#else", "TOUCH_ZOOM_OFFSET", "__offset", "setDetune", "_root", "phong", "EXRLoader.parse: unsupported pixelType ", "getSession", "setKTX2Loader", "texStorage2D", "sheenRoughness", "select", "start", "isSkinnedMesh", "fromCharCode", "renderLists", "setScissor", "readRenderTargetPixels", "scalar", "planeremoved", "meshlambert_frag", "COMPRESSED_SRGB_S3TC_DXT1_EXT", "THREE.TetrahedronBufferGeometry has been renamed to THREE.TetrahedronGeometry.", "minDistance", "cross", "totalSize", "makePerspective", "THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures", "#define USE_SPECULARCOLORMAP", "MeshBasicMaterial", `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`, "area", "loadNode", "INCREASING_Y", "_setValue_unbound", `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, "then", "getBaseLayer", "sub", "setupLightsView", "setupGyro", 'fetch for "', "enqueue", "offsetY", "getRoot", "setFoveation", "deleteAttribute", "CubemapToCubeUV", "meshmatcap_vert", "LTC_HALF_1", "setMaxDistance", "removeAllEventListeners", "targets", "EffectComposer.rt1", "`pan` has been renamed to `truck`", "COMPRESSED_RGBA_ASTC_10x10_KHR", "setDirection", "__autoAllocateDepthBuffer", "HAVE_CURRENT_DATA", "_byClipCacheIndex", "moveCamera", "isMeshMatcapMaterial", 'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".', "warp", "mapSize", "_onChange", "uniform1fv", "setLocked", "passes", "rectAreaLights", "cacheArcLengths", "clipping", "_mesh", "rendererExtensionShaderTextureLod", "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.", "onWindowResized", "round", "spotLightMatrix", "_cubeSize", "uniform mat4 modelViewMatrix;", "_boundaryEnclosesCamera", "geometries", "fogColor", "uniform3f", "KHR_materials_specular", "addScaledVector", "asset", "truck", "setContext", "BLEND", "preserveDrawingBuffer", "parameterPositions", "meshoptDecoder", "integer", "THREE.TorusKnotBufferGeometry has been renamed to THREE.TorusKnotGeometry.", "autoClearColor", "MAX_SAFE_INTEGER", "shapes", "_activateAction", "mipmaps", "metadata", "	attribute vec3 morphTarget0;", "reset", "acCompression", "isInterleavedBuffer", "renderTarget2", "undefined", "PerspectiveCamera", "setRotationFromQuaternion", "extractBasis", "getValue", "_cubemapMaterial", "polarAngle", "ENVMAP_BLENDING_NONE", "GetAttributeDataArrayForAllPoints", "contentContainer", "_dollyControlAmount", "useProgram", "cache", "transformGroup", "isGLBufferAttribute", "ConeGeometry", "DEFAULT_MAPPING", "prototype", "pointLength", "workerPool", "KHR_texture_transform", "setOrientation", "byteStride", "setReferenceSpace", "groundColor", `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, "linearToOutputTexel", "_elementRect", "setBoundary", "_setAdditiveIdentityOther", "_transmission", "scanlineBlockSize", "isMeshDepthMaterial", "blendSrcAlpha", "outerRadius", "__webglTexture", "#define USE_SHEENROUGHNESSMAP", "_setValue_fromArray_setMatrixWorldNeedsUpdate", "shadowsArray", "toLowerCase", "bevelSize", "THREE.GLTFLoader: JSON content not found.", `

		varying vec2 vUv;

		void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, "restoreContext", "setAnimationLoop", "headers", "meshtoon_vert", "COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR", "Curve.toJSON", "internalFormat", "decodeVideoTexture", "makeOrthographic", "cos", "DEFAULT_ANISOTROPY", "root", "userData", "setPaused", "uniform2fv", "updateRenderTargetMipmap", "keys", "supported", "morphTargetInfluences", "getOutput", "pushHashURL", "onHoverAnimations", "createObjectURL", "vector3", "sheenColorMap", "viewer", "isPlaying", "100", "customProgramCacheKey", "LineSegments", "OpenGL ES", "THREE.SkinnedMesh: Unrecognized bindMode: ", "has", "getIrradianceAt", "setMeshoptDecoder", "closed", `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, "drawArrays", "KEEP", "NO_COMPRESSION", "KHR_MATERIALS_CLEARCOAT", "spotLightMap", "fullHeight", "blur direction must be either latitudinal or longitudinal!", "afterRoot", `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, "closePath", "isCompressedArrayTexture", "LineCurve3", "morphColors", "zeroSlopeAtEnd", "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG", "Error creating WebGL context with your selected attributes.", "aoMap", " will be ignored.", "WEBKIT_WEBGL_compressed_texture_pvrtc", "oldClearAlpha", "normal", "getParameters", "ltc_1", "getUint32", "KHR_BINARY_GLTF", "#ifdef USE_INSTANCING_COLOR", "getHandSpace", "WebGL", "isVideoTexture", "planechanged", "COMPRESSED_RGBA_ASTC_10x6_KHR", `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, "transmission", "isSupported", "basic", "spotLightShadows", "blendFuncSeparate", "info", "getHandler", "CapsuleGeometry", "hasEventListener", "middle", "rendererExtensionDrawBuffers", "isVector2", "getDistanceToFitSphere", "meshbasic_vert", "getPoints", "programs", "setClear", "SHADOWMAP_TYPE_VSM", "getNormal", "fitCameraToZone", "stencilFuncMask", "tangentSpaceNormalMap", "shadow", "#define MORPHTARGETS_TEXTURE", "uncompress", "currentPoint", "renderbufferStorageMultisampleEXT", "_loadNodeShallow", "byteOffset", "vertexUvs", "getAnimationsFromCSV", "getInput", "getJointPose", "init", "YXZ", "memory", "WEBGL_compressed_texture_s3tc", "		attribute vec3 morphNormal1;", "getInteractableModelsByZone", "swapBuffers", "materialIndex", "rebindTextures", `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, "EXT_texture_webp", "ENVMAP_TYPE_CUBE", "uv2Transform", "fullWidth", "distanceToSphere", "gl_FragColor = linearToOutputTexel( gl_FragColor );", "wasmBinary", "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.", "setViewOffset", "backgroundCube_vert", "_markDefs", "instancing", "_updatedLastTime", "setInputActive", "cacheKey", "block", "isWebGL3DRenderTarget", "isSpotLight", "makeSafe", "version", "_getShaderCacheForMaterial", "setTime", "setTextureCube", "camera", `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, "additive", "fitToSphere", "morphNormals", "bloomRadius", "THREE.GLTFLoader: Unsupported normalized accessor component type.", "setOp", "normalizeSkinWeights", "isLineBasicMaterial", "data:", "_isUserControllingOffset", "invalid block type", "angle", "setIndex", "scale", "_dollyControlCoord", "intersectObjects", "KHR_materials_unlit", "getRaycastTarget", "meshnormal_vert", `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, "THREE.GLTFLoader: AVIF required by asset but unsupported.", "TRIANGLE_FAN", "wake", "rgba", "_takeBackBinding", "exr", "backgroundIntensity", "POSITION", "BufferGeometry", `
#define LOW_PRECISION`, "generateSideWallUV", `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );
#endif`, "getWorldDirection", "colorTexture", "setFromRotationMatrix", "_uuid", "emissiveTexture", "transformUv", "PMREM.cubeUv", "		attribute vec3 morphTarget5;", "absarc", "hasAttribute", "triangulateShape", "aClockwise", "zone", "EXT_texture_compression_bptc", "vertexTextures", "default", "assignTexture", "SphereGeometry", "THREE.BufferAttribute: copyVector4sArray() was removed in r144.", "_nActiveBindings", "pointLight", "isMeshDistanceMaterial", "COMPRESSED_RGB_PVRTC_4BPPV1_IMG", "multiply", "numSpotLightShadowsWithMaps", "unshift", "setValue", "Line", "isMeshLambertMaterial", "THREE.Audio: this Audio has no playback control.", "isEmpty", "holes", ".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.", "numSpotShadows", "lightPlane", "_collisionTest", "#define USE_LOGDEPTHBUF", "prev", "isPlane", "bindMatrixInverse", "COMPRESSED_RGBA_ASTC_10x5_KHR", "defines", "camera-controls is already connected.", "#version ", "controlend", `void main() {
	gl_Position = vec4( position, 1.0 );
}`, "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.", "updateRange", "getPosition", "clone", "channels", "isInteger", "unpackAlignment", "penumbra", "emissivemap", "getMatrixAt", "rolloffFactor", "shadowMapSize", "MeshToonMaterial", "lookAtTargetBox", "setOptional", "magic", "updateMultisampleRenderTarget", "setDDSLoader", "getElementById", `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`, "THREE.AnimationClip: No animation in JSONLoader data.", "ownerDocument", "getEffectiveFOV", "materialCache", "mediump", "density", "empty", "lengthSq", "parseShapes", "getAttributes", "ShaderMaterial", "THREE.WebGLProgram: Shader Error ", "hsl", "program", "extendMaterialParams", "statusText", "parsedPath", "cn3", "exposure", "aspect", "clearViewOffset", "maxTextureSize", "directionalShadowMap", "395865aGPftU", "squeezeend", "stencilWriteMask", "aRotation", "num_faces", "clearcoat", "EXRLoader.parse: unsupported channel compression", "isEnabled", "DEBUG", "clipAction", "Camera", "makeRotationX", " texture units while this GPU supports only ", "transmissionMap", "setDirectionalCone", "#define textureCubeLodEXT textureLod", "toShapes", "invalid distance", "THREE.Object3D.add: object not an instance of THREE.Object3D.", "ZYZ", "setFilters", "derivative-tangents:", "getFilmHeight", "lambert", `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`, "back", "openLink", "unsupported interpolation for ", "1618OLEHCL", "setFromCylindrical", "isInstancedMesh", `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, "_setValue_fromArray_setNeedsUpdate", "_progress", "setCount", "renderInstances", "THREE.Raycaster: Unsupported camera type: ", "readBuffer", "pinchstart", "THREE.", "normalMatrix", "binormals", "#define textureCube texture", "index-finger-tip", "#define DITHERING", "setX", "meshmatcap_frag", "cube_frag", "toDataURL", "copyVector4sArray", "uniform mat4 viewMatrix;", "copyVector2sArray", "rectArea", "addPointLight", "getCurrentLevel", `
#define MEDIUM_PRECISION`, "Missing raycast target for: ", "_spherical", "compileCubemapShader", "normalmap", "distanceRGBA_vert", "getScissor", "Vector2", "transposeIntoArray", "HALF_FLOAT_OES", "vertexShader", "parseImages", "		attribute vec3 morphNormal2;", "Unknown type: ", "makeTranslation", "THREE.FileLoader: HTTP Status 0 received.", "background_frag", "parseAsync", "controlstart", "plane", "isScheduled", "_slerpAdditive", "THREE.WebGLShadowMap:", "existingAction", "inverseBindMatrices", "setMode", "cancelAnimationFrame", "renderTarget", "equirect_vert", "createNodeAttachment", `
#define HIGH_PRECISION`, "upY", "lightMap", "extendTexture", "getHtml", "boundaryFriction", "environmentBlendMode", "blendEquation", "getAt", "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT", "valid", "sRGBToLinear", "getObjectByName", "rleCompressedSize", "domElements", "THREE.WebGLRenderer: ", "traverse", "ambientLight", "NONE", "data", "filmGauge", "getViewSubImage", "pointLights", "THREE.WebGLRenderer: Can't change size while VR device is presenting.", "Bone", "setExtensions", "quadraticCurveTo", "highPassUniforms", "DEFAULT_MATRIX_WORLD_AUTO_UPDATE", "B44_COMPRESSION", "DT_UINT16", "THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", "comments", "nodeNamesUsed", "texture", "THREE.ObjectLoader: Can't load ", "_updateTimeScale", "touches", "ShapePath", "uint32View", "isBox3", "timecode", "THREE.ImageBitmapLoader: fetch() not supported.", "_targetVelocity", "changeCameraZone", "applyMatrix4", `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, "numDirLights", "shadowMap", "GetterByBindingType", "anisotropy", "419PnCMmh", "latitudinal", "getExtension", " is missing URI and bufferView", `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, "fsQuad", "__ignoreDepthValues", "polygonOffset", "visible", `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`, "uniform mat3 normalMatrix;", "getY", "_dollyInternal", "morphTargets", "merge", "setComponents", "missing format specifier", "match", "thetaStart", "inputsourceschange", "accessors", "THREE.ObjectLoader: Undefined texture", "deleteVertexArrayOES", "renderbufferStorageMultisample", "RectAreaLight", "	attribute vec3 color;", "isBufferAttribute", "bindVertexArray", "sparse", "zoom", "acquireProgram", "stride", "isPerspectiveCamera", "doubleSided", "arrayBuffers", "viewport", "getRandomIntRange", "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ", "attached", "settings. Buffer has already been transferred.", "isShaderMaterial", "fragmentShader", "scrollWidth", "#define texture2DProjLodEXT textureProjLod", "WEBGL_draw_buffers", "loadSkin", "location", "xMax", "disconnect", "addAmbientLight", "setPlaybackRate", "drawRange", "conjugate", "yMax", "vec3 ", `#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`, "_lodPlanes", "isLineSegments", "objectSpaceNormalMap", "double", "Light", "blitFramebuffer", "__webglDepthRenderbuffer", "#define USE_BUMPMAP", "		attribute vec3 morphTarget7;", "interpolate_", "gapSize", "uniform3iv", "lastIndexOf", `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`, "makeRotationZ", "#if defined( USE_COLOR_ALPHA )", "cameraR", "MeshPhongMaterial", "setFloat32", "meshphysical_frag", "background", "bad rgbe scanline format", "addr", "#extension GL_EXT_draw_buffers : require", `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, "_state", "reflectivity", "spotShadow", "COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR", "#define USE_ALPHATEST", "float", "COMPRESSED_RGBA_S3TC_DXT5_EXT", "isDirectionalLight", "createGain", "ShadowMaterial", "#define USE_SPECULARMAP", "sourceType", "getSceneZoneByIndex", "hash", "setVolume", "webkitURL", "transmissionSamplerSize", "movementY", "setHex", "intersectsBox", "rotateTowards", `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`, "vertexAttrib2fv", "_startTime", "curves", "fogFar", "THREE.BufferAttribute: copyVector2sArray() was removed in r144.", "clearColor", "TubeGeometry", "closestPointToPoint", "DEFAULT_UP", "makeEmpty", "_maxInstanceCount", "buffers", "onAfterRender", "createAnalyser", "_alphaTest", "coefficients", "intersectsSprite", "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT", "getIndex", "_cleanup", "canvasID", "	attribute vec3 morphTarget3;", "THREE.GLTFLoader: ", "localClippingEnabled", "from", "lookAt", "isImageBitmapLoader", "Something is wrong with PIZ_COMPRESSION BITMAP_SIZE", "intersectObject", "THREE.DataUtils.toHalfFloat(): Value out of range.", "gltf", "DefaultSettings_", "specularFactor", "_isUserControllingZoom", "stencilMask", "setRotationFromAxisAngle", "setRotationFromMatrix", "isMeshStandardMaterial", "framebufferTexture2DMultisampleEXT", "isFramebufferTexture", "requestVideoFrameCallback", "ArcCurve", "use-credentials", "vertexAttribPointer", "THREE.GLTFLoader: Couldn't load texture", "substring", "WEBGL_multisampled_render_to_texture", "now", "ArrayElement", "OctahedronGeometry", "onStart", "srgb", "Something wrong with hufUnpackEncTable", "iridescenceThicknessMaximum", "getLengths", "frequencyBinCount", "accessor", "_renderer", "onBeforeCompile", "forceSinglePass", "renderToScreen", "computeBoundingSphere", "setLoop", "DOLLY", "getVertexPosition", "clippingPlanes", "offsetX", "blendDstAlpha", "WEBKIT_WEBGL_depth_texture", "times", "message", "planesdetected", "setResponseType", "THREE.ImageBitmapLoader: createImageBitmap() not supported.", "sin", "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", "normalTexture", "DefaultMaterial", "bloom", "link", "getMaxPrecision", "__THREE__", "#define TONE_MAPPING", `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, "getTarget", "_currentLevel", "zeroSlopeAtStart", "_onChangeCallback", "totalAcUncompressedCount", "steiner", "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()", "_deactivateAction", "sceneWrapper", "_truckInternal", "_connected", `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, "getBackgroundModelsByZone", "getSpacedPoints", "normalScale", "#define USE_IRIDESCENCE_THICKNESSMAP", "cf1", 'THREE.DRACOLoader: Unexpected message, "', "maxSamples", "getMidpoint", "constant", "getRGB", "_thetaVelocity", "azimuthAngle", "draggingDampingFactor", "MASK", "clientY", "itemStart", "cameraBounds", "Object", "_frameExtents", "_yAxisUpSpace", "TRIANGULAR_MESH", "data-camera-controls-version", "toString", "170275rZAfpV", "THREE.RGBELoader: Error: ", "COMPRESSED_RGB_PVRTC_2BPPV1_IMG", "skins", "THREE.CapsuleBufferGeometry has been renamed to THREE.CapsuleGeometry.", "KHR_materials_iridescence", "drawArraysInstanced", "innerConeAngle", "enabled", "webgl", "intersectLine", "#define FOG_EXP2", "ENVMAP_BLENDING_ADD", "COMPRESSED_RED_RGTC1_EXT", "setupPostEffects", "readyState", "getTangent", "_effectiveWeight", "scl", `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, "maxDistance", "decodeGltfBufferAsync", "displacementScale", "eyeSep", "_getValue_unavailable", "#define USE_UV", "floor", "targetLine", "clampScalar", "wireframeLinecap", "#define USE_FOG", "aoMapIntensity", "Fog", "restThreshold", "InstancedMesh", "/* worker */", "#define USE_TANGENT", "convert", "detectedPlanes", "vertexAttrib3fv", `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`, "array", "pointerup", "arc", "setDynamicContent", "project", "traverseVisible", `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`, "ymag", "bytesPerElement", "castShadow", "intersectSphere", "_order", "EXT_texture_compression_rgtc", `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, "setDRACOLoader", 'THREE.ObjectLoader: Unsupported geometry type "', "gltfLoader", "COMPRESSED_RGB_ETC1_WEBGL", "emissiveMap", "_getClientRect", "TEX_COORD", "isLineCurve3", "iridescenceMap", "_lodMax", "directionalLength", "addGLTFModel", "envMapMode", "znear", "#define USE_EMISSIVEMAP", "isFloat16BufferAttribute", "split", "shaderID", "draco_decoder.wasm", "bloomParams", " for ", `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, "webglcontextcreationerror", "COMPRESSED_RED_GREEN_RGTC2_EXT", "drawArraysInstancedANGLE", "groups", "THREE.Curve: .getPoint() not implemented.", "\\[\\]\\.:\\/", "uniform4uiv", " not yet supported.", "_addIndex", "textureID", `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`, "onProgressLoading", "_target0", "ENVMAP_TYPE_CUBE_UV", "modelViewMatrix", "ShapeGeometry", "isXRRenderTarget", "acos", "roughnessFactor", "gradientMap", "useUniqueIDs", "thetaLength", "buffer", "mouseButton", "Unknown depthTexture format", "log", "_takeBackAction", "bindVertexArrayOES", "_zoom", "arrayBuffer", "pushShadow", "SpotLightHelper", "spec", "getDelta", "lightsStateVersion", "sampler", "GetAttributeId", "rectAreaLTC1", "attenuationColor", "constructor", "EXRLoader.parse: ", "translateX", "setFromEuler", "RLE_COMPRESSION", "#define USE_AOMAP", "makeRotationFromEuler", "sleep", "pushLight", "closestPointToPointParameter", "connect", "THREE.WebGLRenderer: Image in DataTexture is too big (", `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`, "ambient", "position0", "THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.", "raycast", "draco:", "layout(location = 0) out highp vec4 pc_fragColor;", "repeat", "_getValue_direct", "postMessage", "setupRaycaster", "_bindingsIndicesByPath", "SpotLight", "backgroundBlurriness", "mesh_", "pointerdown", "rotateZ", "onModuleLoaded", `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`, "DT_INT32", "thumb-tip", "setDataType", "_update", "slerpQuaternions", "BYTES_PER_ELEMENT", "None", "crossOrigin", "_intersections", "needsSwap", "equals", `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, "TOUCH_DOLLY_TRUCK", "separableBlurMaterials", "getGripSpace", "uniforms", "THREE.KeyframeTrack:", "Shape", "setFromQuaternion", "aspectRatio", "		attribute vec3 morphTarget4;", "centripetal", "( vec3 color ) { return ", "lerp", "pause", "uncache", "uniform1iv", "iridescenceThicknessRange", "beginShadows", "direction", "onUpload", "DirectionalLightHelper", "delete", "numPointLights", "getBoundingBox", `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, "TRUCK", "backgroundCube", "getWrappedAnimations", "makeRotationAxis", "dcCompressedSize", "isMeshPhysicalMaterial", "linedashed_frag", "THREE.BufferAttribute: array should be a Typed Array.", "getHex", "renderer", "positionZ", "THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files", "bevelThickness", "goToZone", "Invalid table entry", "getActiveCubeFace", "hufDecode issues", " but it wasn't found.", "KHR_LIGHTS_PUNCTUAL", "elementSize", "ENVMAP_BLENDING_MULTIPLY", "copy", "squeeze", "jsonPath", "getFoveation", "_loopCount", "refDistance", "textureLoader", "setEffectiveWeight", "header", "vector4", "movementX", "storage", 'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', ".position", "focalOffset", "traverseAncestors", "stopFading", "_findPointerByMouseButton", "zfar", "detune", "input", "loadAccessor", "_listeners", 'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', "toggle", "tDiffuse", "clearStencil", "#define CUBEUV_MAX_MIP ", "multiplyQuaternionsFlat", "autoClearStencil", "deactivate", "forwardZ", "sizeAttenuation", "thickness", "loadAsync", "LightProbe", "inputSource", `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, "inputState", "polygonOffsetFactor", "hoveroff", "setUint16", "getFrustum", "__useRenderToTexture", "startAt", "Composite", "transpose", "_getValue_array", "yfov", "getMaterialType", "cumulativeWeight", "setFromBufferAttribute", "NeedsUpdate", "meshphong_frag", "cameraAutoUpdate", "boneTexture", "allocateTextureUnit", "getPose", "	attribute vec3 morphTarget2;", "setW", "intersectsSphere", "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", "WEBGL_compressed_texture_pvrtc", "wrappedSceneZones", "mesh", "stencilOp", "getInteractablesByZone", "setTest", "response", "PropertyBinding: Cannot parse trackName: ", "DT_UINT8", "addDynamicCloseButton", "THREE", "deleteBuffer", "theta", "_removeInactiveBindingsForAction", "propertyIndex", "deleteTexture", "angleTo", "dollyTo", "isPointLightShadow", "animation", "_setValue_arrayElement_setMatrixWorldNeedsUpdate", "setWithCredentials", "TetrahedronGeometry", "trunc", "TOUCH_OFFSET", "_weightPrev", "nextScene", "THREE.GLTFLoader: Unexpected light type: ", "encodings_pars_fragment", "sign", " buffer type is not supported.", "linewidth", "setRenderTarget", "xmag", "COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT", "Points", "power", "maxGyroSignals", "stencilWrite", "#define CUBEUV_TEXEL_HEIGHT ", "hysteresis", "copyLinearToSRGB", "lerpVectors", "#define texture2DGradEXT textureGrad", "parseTextures", "attributeDivisors", "KHR_MATERIALS_IRIDESCENCE", "getLoopingAnimations", "InterleavedBuffer:", "THREE.RGBELoader Write Error: ", "progress", "setUvTransform", "endingEnd", "COMPRESSED_RGBA_S3TC_DXT3_EXT", "webgl2", "sprite_frag", "getDistanceToFitBox", "meshphysical_vert", "dithering", "optimize", "combine", "THREE.BufferAttribute: copyColorsArray() was removed in r144.", "color(", "MIDDLE", `varying vec2 vUv;
				uniform sampler2D blurTexture1;
				uniform sampler2D blurTexture2;
				uniform sampler2D blurTexture3;
				uniform sampler2D blurTexture4;
				uniform sampler2D blurTexture5;
				uniform float bloomStrength;
				uniform float bloomRadius;
				uniform float bloomFactors[NUM_MIPS];
				uniform vec3 bloomTintColors[NUM_MIPS];

				float lerpBloomFactor(const in float factor) {
					float mirrorFactor = 1.2 - factor;
					return mix(factor, mirrorFactor, bloomRadius);
				}

				void main() {
					gl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +
						lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +
						lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +
						lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +
						lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );
				}`, "setXYZW", "premultiplyAlpha", "updateUBOMapping", "LTC_FLOAT_1", "DEFAULT_IMAGE", "cameraL", "_cacheIndex", "drawImage", "_actions", "setXY", "weights", "Error creating WebGL context.", "containsPoint", "meshCache", "get", "cone", "AmbientLight", "blending", "sheenRoughnessTexture", "onHover", "setLineWidth", "fitToBox", "transmissionSamplerMap", "hasPlaybackControl", "add", "OES_texture_float", "copyAt", "all", "crossFadeFrom", "KHR_materials_clearcoat", "isObject3D", `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, "_setValue_arrayElement_setNeedsUpdate", "needsUpdate", "vertices", "fromJSON", "isCubeTexture", `#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`, "drawcalls", "atan", "decodeText", "TOUCH_ZOOM", "querySelector", "maxSpeed", "_phiVelocity", "depthMask", "clearcoatRoughnessFactor", "children", "clearcoatFactor", "loadImageSource", "isMeshPhongMaterial", "__version", "lights", "quaternion", "isAnimationObjectGroup", "framebufferTexture2D", `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`, "smoothWidth", "cancelable", "Object3D", "interpolation", "clearAlpha", "details", "_lendBinding", "copyArray", "usage", "PlaneGeometry", "distanceSqToSegment", "panner", "extractPoints", "updateArcLengths", "size", "createNodeMesh", `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, "dashed", "getShaderPrecisionFormat", `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, "_compileMaterial", "uniform", "clampPoint", "time", "HEAPF32", `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, "min", "TOUCH_DOLLY", "_position0", "closeDynamicContent", "sampleValues", "isCompressedTexture", "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)", "compileEquirectangularShader", "click", "normalBias", "src", "setZ", "DEFAULT_MATRIX_AUTO_UPDATE", "PointsMaterial", "Vector3", "#define texture2DProj textureProj", "extras", "face", "createUniqueName", "uuid", "length", "/* draco decoder */", "bufferSubData", "targetNames", "getViewport", "_weightNext", "updateCameraUp", "intersect", "LN2", "isPoints", "accumulateAdditive", "random", "multiplyMatrices", "PropertyBinding: can not parse propertyName from trackName: ", "order", "onPointerMove", "setPath", "morphTargetsCount", `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, "workingColorSpace", "chordal", "groupOrder", "isWebGL1Renderer", "setFromCamera", "#define USE_TRANSMISSIONMAP", "orbitCameraTo", "#define USE_IRIDESCENCEMAP", "LineLoop", "isRunning", "_zoom0", "clamp", `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`, "remove", `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`, "toJSON", "XZY", "isQuaternion", "uniform4f", "json", "deltaX", "THREE.WebGLProgram.getParameters:", "isMatrix4", "THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", "onHoverOffCallback", "rotateOnAxis", "morphTargetsRelative", "boundingBox", "createTexture", `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, "isInterleavedBufferAttribute", "MeshNormalMaterial", "push", "dispatchEvent", "getBoundingClientRect", "RingGeometry", "rotateOnWorldAxis", "setTexture2DArray", "getAnimations", "THREE.WebGLProgram: Unsupported toneMapping:", "_nearPlaneCorners", `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, "		attribute vec3 morphNormal0;", "enable", "sheenRoughnessMap", "environment", "overrideMaterial", "pointerType", "_radiusVelocity", "materialHighPassFilter", "showLoadingScreen", "Can not resolve #include <", "envMapIntensity", "num_points", "fps", "THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150.", "#define USE_COLOR_ALPHA", "#define MORPHTARGETS_COUNT ", "index is out of range: ", "_findPointerById", "dragToOffset", "changeSceneZoneByName", "dracoLoader", "plugins", "baseTable", "TOUCH_TRUCK", "restoreOriginalState", "Mesh", "#define USE_ENVMAP", "quaternionToVector3", "setFocalLength", "getByteFrequencyData", "pow", "_bindingsByRootAndName", "indices", "lightProbe", "lineTo", "autoClearDepth", "vertexTangents", "setClearColor", "1467088UKoVZZ", "EXRHeader:", "THREE.WebXRManager: Cannot change framebuffer scale while presenting.", "isMeshGouraudMaterial", "_setValue_arrayElement", "EXT_blend_minmax", "framebufferRenderbuffer", "loadGeometries", `#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`, "roughnessMap", "drawElements", "copyTextureToTexture3D", "EXT_TEXTURE_AVIF", "saveState", "strength", "_getShaderStage", "KHR_MATERIALS_VOLUME", "wrapT", "inverse", "settings", "bindBuffer", "getObjectForDistance", "oldTime", "; }", "chromaticities", "PlaneHelper", "isWebGLMultipleRenderTargets", "debug", "numSpotLightMaps", "FogExp2", "flipEnvMap", "manager", "setFramebufferScaleFactor", "bad initial token", "AudioListener", "itemEnd", "defaultAttributeValues", "loadScene", "LINES", "onHoverOff", "calls", "getFrequencyData", "range", "byteLength", "interactablesContent", "expandByScalar", "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.", "setColorName", "ior", "gain", "disableAll", "getPixelRatio", "isCamera", "_invokeAll", "defaultAttributeIDs", "getArea", "blendSrc", "vertexColorSpace", "currentProgram", "primitiveCache", "addPass", "attributes", "isPointLight", "_equirectMaterial", "invalid length/literal", `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, "_yAxisUpSpaceInverse", "getContext", "premultiply", "segments", "setGlobalState", "numHemiLights", "observe", "control", "shadow_frag", "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.", "getCurveLengths", "iridescenceThicknessTexture", "color", "HasFromToArray", "model", "thicknessFactor", "ArrowHelper", "computeVertexNormals", "materialCopy", "sessionstart", "itemSize", "alphaMode", "findByName", `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`, "_mixer", "instead.", "parseFromString", "	attribute vec4 tangent;", "THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144.", "shadowRadius", "invalid zlib data: preset dictionaries not supported", "getBinding", "_cubeDirections", "alphaTest", "yRadius", "THREE.ObjectLoader: No skeleton found with UUID:", "fftSize", "depthWrite", `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, "#define USE_MORPHNORMALS", "Texture.toJSON", "_weightInterpolant", "output", "#extension GL_EXT_frag_depth : enable", "determinant", "img", "XYZ3d-hidden", "isCanvasTexture", "_activePointers", "line", "normalized", "stopAllAction", "tiltX", "extensions", "EXT_mesh_gpu_instancing", "setColorAt", "_rotateInternal", "ValueTypeName", "GetTrianglesUInt32Array", "_createGeometry", "shadowBias", "MeshLambertMaterial", "_hasRested", "rotatePolarTo", "pointLightShadows", "string", "forceContextRestore", "transform", "stringify", "NORMAL", "#define USE_COLOR", 'THREE.GLTFLoader: Unknown extension "', "fadeIn", "search", "OptimizedCineon", "_taskCosts", "convertLinearToSRGB", `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, "attach", "divideScalar", "isEllipseCurve", `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, "THREE.GLTFLoader: Primitive mode unsupported: ", "initNonuniformCatmullRom", "COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR", "_updateWeight", "multiplyQuaternions", "_removeInactiveBinding", ".bones[", "getBigInt64", "iridescenceThicknessMap", "three", `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, "bindMatrix", "contextmenu", "EXT_color_buffer_half_float", "hasAngularVelocity", "specularColor", "setMediaElementSource", "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.", "byteArray", "isMeshNormalMaterial", ", is too large and will clip, as it requested ", "abs", "reject", "clearcoatNormalTexture", "getMasterVolume", "sanitizeNodeName", "sheenColorFactor", "interleavedBuffers", "extractUrlBase", "polarRotateSpeed", "clearGroups", "right", "filters", "url", "displacementmap", "dispose", "workerSourceURL", "Something wrong with hufUncompress", "( vec4 value ) { return LinearTo", "__bindingPointIndex", "setFromObject", "onHoverOverCallback", "aStartAngle", "subScalar", "isLineLoop", "bindSkeletons", "morphTargetDictionary", "setLength", "getCameraAnimationStart", "_getValue_toArray", "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.", "duration", "tangent", `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, "deltaY", "perspective", "getSeperableBlurMaterial", "translateZ", "isSkeletonHelper", "decay", "autoStart", "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.", "Raycaster", "asin", "playbackRate", "setScalar", "setRenderTargetTextures", "#define USE_CLEARCOAT_NORMALMAP", "meshtoon_frag", "stopWarping", "log2", "draggingSmoothTime", "__cacheKey", "getPlayer", "ValueBufferType", "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()", "uniformsList", "_initMemoryManager", "halt", "frustumCulled", "bezierCurveTo", "minPolarAngle", "releaseStatesOfProgram", "setMediaStreamSource", "_setValue_array_setMatrixWorldNeedsUpdate", "resetTextureUnits", "fog", "Texture", "bufferViews", "skinWeight", "load", "join", "loopEnd", "iterator", "KHR_MESH_QUANTIZATION", "assignFinalMaterial", "UNSIGNED_INT_24_8_WEBGL", "offsetTable", "resolve", "vertexAlphas", "update", "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.", "setName", "subPaths", "iframe", "finished", "_cubeUps", "options", "_indicesByUUID", "maxAzimuthAngle", "wrap", "updateCamera", "isMesh", "uncacheAction", "#define CUBEUV_TEXEL_WIDTH ", "uniformMatrix2fv", "isAmbientLightProbe", "penumbraCos", "specularMap", "_getHandJoint", "_pixelRatio", "_needsUpdate", "getDataURL", "pointMap", "setTarget", "equirect_frag", "luminosityHighPass", "_encloseToBoundary", "jointName", "loopAnimations", "slice", "common", "clock", "THREE.Quaternion: .setFromEuler() encountered an unknown order: ", "#define FLAT_SHADED", "findNode", "setLookAt", "shadow_vert", "userAgent", "target.depthTexture not supported in Cube render targets", "weight", "onBeforeRender", "levels", "getHSL", "PointLight", "isOrthographic", " int;", "_sizeLods", "vec3 transformed = vec3( position );", "Versioning", "intersectableObjects", "tonemapping_pars_fragment", "	attribute mat4 instanceMatrix;", "opaque", "setFromVector3", " version ", "numIntersection", "setCameraOffset", "loadJson", "aomap", `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, "bufferData", "bloomStrength", "negate", "getParameter", "splineThru", "azimuthRotateSpeed", "openEnded", "attribute vec3 position;", "linejoin", "getContextAttributes", "smoothTime", "Scene", "REPLACE", "active", "MAX_EXT", "repetitions", "bind", "vertexColors", "setFromMatrixColumn", "copyUniforms", "THREE:ObjectLoader: Can't parse ", "resize", "THREE.ShapeBufferGeometry has been renamed to THREE.ShapeGeometry.", "text", "attribute vec2 uv;", `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, "setFromCenterAndSize", "currentPath", "Skeleton.toJSON", "setUsage", "texSubImage3D", "renderTargetBright", "activeSceneZone", "__data", "_controlInterpolants", "rational", "getW", "	#ifdef USE_MORPHNORMALS", "looping", "angularVelocity", "bindRenderbuffer", "TimeBufferType", "slerpFlat", "#define gl_FragColor pc_fragColor", "fov", "usedTimes", "sheenRoughnessFactor", "reading", "THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.", "parent", "heightSegments", "useCount", "outputEncoding", "THREE.Color: Alpha component of ", "decoderPath", "computeBoundingBox", "cf4", "distanceTo", "position", "tiltYArr", "matrixWorldAutoUpdate", "THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead.", "_sphericalEnd", "pointermove"];
  return ba = function() {
    return d;
  }, ba();
}
class tl extends oe {
  constructor(e = 1, x = 1, t = 1) {
    const i = s;
    super(e, x), this[i(3600)] = !![], this[i(3611)] = t, this[i(2431)] = new va(null, e, x, t), this[i(2431)].isRenderTargetTexture = !![];
  }
}
class C2 extends Ux {
  constructor(e = null, x = 1, t = 1, i = 1) {
    const n = s;
    super(null), this[n(1142)] = !![], this.image = { data: e, width: x, height: t, depth: i }, this[n(999)] = Bx, this[n(991)] = Bx, this[n(1139)] = Zx, this[n(3632)] = ![], this.flipY = ![], this[n(2275)] = 1;
  }
}
class il extends oe {
  constructor(e = 1, x = 1, t = 1) {
    const i = s;
    super(e, x), this[i(2182)] = !![], this.depth = t, this[i(2431)] = new C2(null, e, x, t), this[i(2431)][i(546)] = !![];
  }
}
class nl extends oe {
  constructor(e = 1, x = 1, t = 1, i = {}) {
    const n = s;
    super(e, x, i), this[n(3230)] = !![];
    const a = this.texture;
    this[n(2431)] = [];
    for (let r = 0; r < t; r++)
      this.texture[r] = a.clone(), this[n(2431)][r][n(546)] = !![];
  }
  setSize(e, x, t = 1) {
    const i = s;
    if (this[i(1631)] !== e || this[i(1674)] !== x || this[i(3611)] !== t) {
      this[i(1631)] = e, this[i(1674)] = x, this[i(3611)] = t;
      for (let n = 0, a = this.texture[i(3105)]; n < a; n++)
        this[i(2431)][n].image[i(1631)] = e, this[i(2431)][n][i(450)][i(1674)] = x, this[i(2431)][n].image[i(3611)] = t;
      this[i(3387)]();
    }
    return this.viewport[i(1260)](0, 0, e, x), this[i(1833)][i(1260)](0, 0, e, x), this;
  }
  [s(2875)](e) {
    const x = s;
    this[x(3387)](), this[x(1631)] = e[x(1631)], this[x(1674)] = e.height, this[x(3611)] = e.depth, this[x(2483)][x(1260)](0, 0, this[x(1631)], this[x(1674)]), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = e[x(471)], this[x(686)] = e[x(686)], e.depthTexture !== null && (this[x(1708)] = e[x(1708)].clone()), this.texture.length = 0;
    for (let t = 0, i = e.texture[x(3105)]; t < i; t++)
      this[x(2431)][t] = e[x(2431)][t][x(2272)](), this[x(2431)][t].isRenderTargetTexture = !![];
    return this;
  }
}
class at {
  constructor(e = new z(1 / 0, 1 / 0, 1 / 0), x = new z(-1 / 0, -1 / 0, -1 / 0)) {
    const t = s;
    this[t(2437)] = !![], this.min = e, this.max = x;
  }
  [s(1260)](e, x) {
    const t = s;
    return this[t(3085)][t(2875)](e), this[t(1803)].copy(x), this;
  }
  [s(3722)](e) {
    const x = s;
    let t = 1 / 0, i = 1 / 0, n = 1 / 0, a = -1 / 0, r = -1 / 0, o = -1 / 0;
    for (let c = 0, h = e.length; c < h; c += 3) {
      const f = e[c], u = e[c + 1], l = e[c + 2];
      f < t && (t = f), u < i && (i = u), l < n && (n = l), f > a && (a = f), u > r && (r = u), l > o && (o = l);
    }
    return this[x(3085)][x(1260)](t, i, n), this[x(1803)][x(1260)](a, r, o), this;
  }
  [s(2926)](e) {
    const x = s;
    let t = 1 / 0, i = 1 / 0, n = 1 / 0, a = -1 / 0, r = -1 / 0, o = -1 / 0;
    for (let c = 0, h = e.count; c < h; c++) {
      const f = e[x(781)](c), u = e[x(2459)](c), l = e[x(1341)](c);
      f < t && (t = f), u < i && (i = u), l < n && (n = l), f > a && (a = f), u > r && (r = u), l > o && (o = l);
    }
    return this[x(3085)][x(1260)](t, i, n), this[x(1803)][x(1260)](a, r, o), this;
  }
  [s(646)](e) {
    const x = s;
    this[x(2561)]();
    for (let t = 0, i = e[x(3105)]; t < i; t++)
      this[x(1186)](e[t]);
    return this;
  }
  [s(3539)](e, x) {
    const t = s, i = Ot[t(2875)](x)[t(580)](0.5);
    return this[t(3085)][t(2875)](e)[t(1943)](i), this[t(1803)].copy(e)[t(3026)](i), this;
  }
  [s(3392)](e, x = ![]) {
    const t = s;
    return this.makeEmpty(), this[t(1179)](e, x);
  }
  [s(2272)]() {
    const e = s;
    return new this[e(2787)]()[e(2875)](this);
  }
  [s(2875)](e) {
    const x = s;
    return this[x(3085)][x(2875)](e.min), this[x(1803)][x(2875)](e[x(1803)]), this;
  }
  [s(2561)]() {
    const e = s;
    return this[e(3085)].x = this[e(3085)].y = this[e(3085)].z = 1 / 0, this[e(1803)].x = this.max.y = this[e(1803)].z = -1 / 0, this;
  }
  [s(2253)]() {
    const e = s;
    return this[e(1803)].x < this[e(3085)].x || this.max.y < this[e(3085)].y || this[e(1803)].z < this[e(3085)].z;
  }
  [s(1658)](e) {
    const x = s;
    return this[x(2253)]() ? e[x(1260)](0, 0, 0) : e[x(1168)](this[x(3085)], this[x(1803)])[x(580)](0.5);
  }
  getSize(e) {
    const x = s;
    return this[x(2253)]() ? e[x(1260)](0, 0, 0) : e[x(1061)](this[x(1803)], this.min);
  }
  [s(1186)](e) {
    const x = s;
    return this[x(3085)][x(3085)](e), this.max[x(1803)](e), this;
  }
  [s(734)](e) {
    const x = s;
    return this[x(3085)][x(1943)](e), this[x(1803)][x(3026)](e), this;
  }
  [s(3249)](e) {
    const x = s;
    return this[x(3085)][x(3688)](-e), this.max[x(3688)](e), this;
  }
  [s(1179)](e, x = ![]) {
    const t = s;
    e[t(630)](![], ![]);
    const i = e[t(1353)];
    if (i !== void 0)
      if (x && i[t(3265)] != null && i[t(3265)][t(3571)] !== void 0) {
        const a = i.attributes[t(3571)];
        for (let r = 0, o = a.count; r < o; r++)
          Ot[t(804)](a, r)[t(2442)](e.matrixWorld), this[t(1186)](Ot);
      } else
        i[t(3151)] === null && i[t(3568)](), Va[t(2875)](i[t(3151)]), Va[t(2442)](e[t(490)]), this[t(1618)](Va);
    const n = e[t(3049)];
    for (let a = 0, r = n[t(3105)]; a < r; a++)
      this[t(1179)](n[a], x);
    return this;
  }
  containsPoint(e) {
    const x = s;
    return e.x < this.min.x || e.x > this[x(1803)].x || e.y < this[x(3085)].y || e.y > this[x(1803)].y || e.z < this[x(3085)].z || e.z > this[x(1803)].z ? ![] : !![];
  }
  [s(812)](e) {
    const x = s;
    return this[x(3085)].x <= e[x(3085)].x && e[x(1803)].x <= this[x(1803)].x && this[x(3085)].y <= e[x(3085)].y && e[x(1803)].y <= this[x(1803)].y && this[x(3085)].z <= e.min.z && e[x(1803)].z <= this.max.z;
  }
  getParameter(e, x) {
    const t = s;
    return x[t(1260)]((e.x - this[t(3085)].x) / (this[t(1803)].x - this[t(3085)].x), (e.y - this[t(3085)].y) / (this.max.y - this[t(3085)].y), (e.z - this.min.z) / (this.max.z - this[t(3085)].z));
  }
  [s(2549)](e) {
    const x = s;
    return e[x(1803)].x < this[x(3085)].x || e.min.x > this[x(1803)].x || e[x(1803)].y < this.min.y || e[x(3085)].y > this.max.y || e[x(1803)].z < this.min.z || e[x(3085)].z > this[x(1803)].z ? ![] : !![];
  }
  [s(2935)](e) {
    const x = s;
    return this[x(3081)](e[x(551)], Ot), Ot[x(1679)](e[x(551)]) <= e[x(1232)] * e[x(1232)];
  }
  intersectsPlane(e) {
    const x = s;
    let t, i;
    return e[x(2111)].x > 0 ? (t = e[x(2111)].x * this[x(3085)].x, i = e.normal.x * this.max.x) : (t = e[x(2111)].x * this[x(1803)].x, i = e[x(2111)].x * this.min.x), e[x(2111)].y > 0 ? (t += e[x(2111)].y * this.min.y, i += e.normal.y * this[x(1803)].y) : (t += e[x(2111)].y * this[x(1803)].y, i += e[x(2111)].y * this[x(3085)].y), e[x(2111)].z > 0 ? (t += e[x(2111)].z * this[x(3085)].z, i += e[x(2111)].z * this[x(1803)].z) : (t += e[x(2111)].z * this[x(1803)].z, i += e[x(2111)].z * this.min.z), t <= -e[x(2656)] && i >= -e[x(2656)];
  }
  [s(1265)](e) {
    const x = s;
    if (this[x(2253)]())
      return ![];
    this[x(1658)](rn), fs.subVectors(this[x(1803)], rn), fi[x(1061)](e.a, rn), li[x(1061)](e.b, rn), ui[x(1061)](e.c, rn), ct[x(1061)](li, fi), dt[x(1061)](ui, li), Nt[x(1061)](fi, ui);
    let t = [0, -ct.z, ct.y, 0, -dt.z, dt.y, 0, -Nt.z, Nt.y, ct.z, 0, -ct.x, dt.z, 0, -dt.x, Nt.z, 0, -Nt.x, -ct.y, ct.x, 0, -dt.y, dt.x, 0, -Nt.y, Nt.x, 0];
    return Wa(t, fi, li, ui, fs) ? (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], Wa(t, fi, li, ui, fs) ? (ls[x(956)](ct, dt), t = [ls.x, ls.y, ls.z], Wa(t, fi, li, ui, fs)) : ![]) : ![];
  }
  [s(3081)](e, x) {
    const t = s;
    return x.copy(e)[t(3135)](this[t(3085)], this.max);
  }
  [s(618)](e) {
    return this[s(3081)](e, Ot).distanceTo(e);
  }
  [s(1095)](e) {
    const x = s;
    return this.isEmpty() ? e[x(2561)]() : (this[x(1658)](e[x(551)]), e[x(1232)] = this[x(561)](Ot).length() * 0.5), e;
  }
  [s(3112)](e) {
    const x = s;
    return this[x(3085)][x(1803)](e[x(3085)]), this[x(1803)][x(3085)](e[x(1803)]), this[x(2253)]() && this[x(2561)](), this;
  }
  union(e) {
    const x = s;
    return this[x(3085)].min(e.min), this[x(1803)].max(e.max), this;
  }
  applyMatrix4(e) {
    const x = s;
    return this.isEmpty() ? this : (Ke[0][x(1260)](this[x(3085)].x, this.min.y, this.min.z)[x(2442)](e), Ke[1][x(1260)](this[x(3085)].x, this[x(3085)].y, this[x(1803)].z)[x(2442)](e), Ke[2].set(this.min.x, this[x(1803)].y, this[x(3085)].z)[x(2442)](e), Ke[3].set(this[x(3085)].x, this[x(1803)].y, this[x(1803)].z)[x(2442)](e), Ke[4].set(this[x(1803)].x, this[x(3085)].y, this.min.z)[x(2442)](e), Ke[5].set(this[x(1803)].x, this.min.y, this.max.z)[x(2442)](e), Ke[6][x(1260)](this[x(1803)].x, this.max.y, this[x(3085)].z)[x(2442)](e), Ke[7].set(this[x(1803)].x, this[x(1803)].y, this[x(1803)].z)[x(2442)](e), this[x(646)](Ke), this);
  }
  translate(e) {
    const x = s;
    return this[x(3085)][x(3026)](e), this.max[x(3026)](e), this;
  }
  [s(2828)](e) {
    const x = s;
    return e.min.equals(this[x(3085)]) && e.max[x(2828)](this[x(1803)]);
  }
}
const Ke = [new z(), new z(), new z(), new z(), new z(), new z(), new z(), new z()], Ot = new z(), Va = new at(), fi = new z(), li = new z(), ui = new z(), ct = new z(), dt = new z(), Nt = new z(), rn = new z(), fs = new z(), ls = new z(), Ut = new z();
function Wa(d, e, x, t, i) {
  const n = s;
  for (let a = 0, r = d[n(3105)] - 3; a <= r; a += 3) {
    Ut.fromArray(d, a);
    const o = i.x * Math[n(3373)](Ut.x) + i.y * Math[n(3373)](Ut.y) + i.z * Math[n(3373)](Ut.z), c = e[n(1454)](Ut), h = x[n(1454)](Ut), f = t.dot(Ut);
    if (Math[n(1803)](-Math[n(1803)](c, h, f), Math[n(3085)](c, h, f)) > o)
      return ![];
  }
  return !![];
}
const sl = new at(), on = new z(), ja = new z();
class Pt {
  constructor(e = new z(), x = -1) {
    const t = s;
    this[t(551)] = e, this[t(1232)] = x;
  }
  [s(1260)](e, x) {
    const t = s;
    return this.center[t(2875)](e), this[t(1232)] = x, this;
  }
  setFromPoints(e, x) {
    const t = s, i = this[t(551)];
    x !== void 0 ? i[t(2875)](x) : sl[t(646)](e).getCenter(i);
    let n = 0;
    for (let a = 0, r = e[t(3105)]; a < r; a++)
      n = Math.max(n, i[t(1679)](e[a]));
    return this[t(1232)] = Math[t(713)](n), this;
  }
  copy(e) {
    const x = s;
    return this.center[x(2875)](e[x(551)]), this.radius = e[x(1232)], this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  [s(2561)]() {
    const e = s;
    return this[e(551)].set(0, 0, 0), this[e(1232)] = -1, this;
  }
  containsPoint(e) {
    const x = s;
    return e[x(1679)](this[x(551)]) <= this[x(1232)] * this.radius;
  }
  [s(618)](e) {
    const x = s;
    return e[x(3570)](this[x(551)]) - this[x(1232)];
  }
  [s(2935)](e) {
    const x = s, t = this[x(1232)] + e.radius;
    return e.center[x(1679)](this[x(551)]) <= t * t;
  }
  [s(2549)](e) {
    return e[s(2935)](this);
  }
  [s(782)](e) {
    const x = s;
    return Math[x(3373)](e[x(618)](this[x(551)])) <= this[x(1232)];
  }
  [s(3081)](e, x) {
    const t = s, i = this[t(551)][t(1679)](e);
    return x[t(2875)](e), i > this[t(1232)] * this.radius && (x.sub(this[t(551)]).normalize(), x.multiplyScalar(this.radius).add(this[t(551)])), x;
  }
  [s(2852)](e) {
    const x = s;
    return this.isEmpty() ? (e[x(2561)](), e) : (e.set(this[x(551)], this[x(551)]), e.expandByScalar(this.radius), e);
  }
  [s(2442)](e) {
    const x = s;
    return this[x(551)].applyMatrix4(e), this.radius = this[x(1232)] * e[x(1082)](), this;
  }
  translate(e) {
    const x = s;
    return this[x(551)][x(3026)](e), this;
  }
  expandByPoint(e) {
    const x = s;
    if (this[x(2253)]())
      return this[x(551)][x(2875)](e), this.radius = 0, this;
    on[x(1061)](e, this[x(551)]);
    const t = on.lengthSq();
    if (t > this.radius * this[x(1232)]) {
      const i = Math[x(713)](t), n = (i - this[x(1232)]) * 0.5;
      this[x(551)][x(1990)](on, n / i), this[x(1232)] += n;
    }
    return this;
  }
  [s(1618)](e) {
    const x = s;
    return e[x(2253)]() ? this : this[x(2253)]() ? (this[x(2875)](e), this) : (this.center.equals(e[x(551)]) === !![] ? this[x(1232)] = Math[x(1803)](this[x(1232)], e[x(1232)]) : (ja[x(1061)](e[x(551)], this.center)[x(3399)](e[x(1232)]), this[x(1186)](on[x(2875)](e[x(551)])[x(3026)](ja)), this[x(1186)](on[x(2875)](e[x(551)])[x(1943)](ja))), this);
  }
  [s(2828)](e) {
    const x = s;
    return e[x(551)].equals(this[x(551)]) && e[x(1232)] === this[x(1232)];
  }
  [s(2272)]() {
    const e = s;
    return new this[e(2787)]().copy(this);
  }
}
const $e = new z(), Xa = new z(), us = new z(), ht = new z(), qa = new z(), bs = new z(), Ya = new z();
class jn {
  constructor(e = new z(), x = new z(0, 0, -1)) {
    const t = s;
    this.origin = e, this[t(2847)] = x;
  }
  [s(1260)](e, x) {
    const t = s;
    return this[t(1149)][t(2875)](e), this.direction[t(2875)](x), this;
  }
  [s(2875)](e) {
    const x = s;
    return this.origin.copy(e[x(1149)]), this[x(2847)][x(2875)](e[x(2847)]), this;
  }
  at(e, x) {
    const t = s;
    return x.copy(this.origin).addScaledVector(this[t(2847)], e);
  }
  lookAt(e) {
    const x = s;
    return this[x(2847)].copy(e)[x(1943)](this[x(1149)])[x(608)](), this;
  }
  [s(539)](e) {
    return this[s(1149)].copy(this.at(e, $e)), this;
  }
  closestPointToPoint(e, x) {
    const t = s;
    x[t(1061)](e, this[t(1149)]);
    const i = x.dot(this[t(2847)]);
    return i < 0 ? x[t(2875)](this[t(1149)]) : x[t(2875)](this[t(1149)])[t(1990)](this[t(2847)], i);
  }
  [s(618)](e) {
    const x = s;
    return Math[x(713)](this[x(3786)](e));
  }
  distanceSqToPoint(e) {
    const x = s, t = $e[x(1061)](e, this[x(1149)])[x(1454)](this.direction);
    return t < 0 ? this[x(1149)][x(1679)](e) : ($e[x(2875)](this[x(1149)]).addScaledVector(this[x(2847)], t), $e[x(1679)](e));
  }
  [s(3069)](e, x, t, i) {
    const n = s;
    Xa[n(2875)](e).add(x)[n(580)](0.5), us[n(2875)](x)[n(1943)](e)[n(608)](), ht[n(2875)](this[n(1149)])[n(1943)](Xa);
    const a = e[n(3570)](x) * 0.5, r = -this[n(2847)][n(1454)](us), o = ht[n(1454)](this[n(2847)]), c = -ht[n(1454)](us), h = ht[n(2296)](), f = Math[n(3373)](1 - r * r);
    let u, l, _, p;
    if (f > 0)
      if (u = r * c - o, l = r * o - c, p = a * f, u >= 0)
        if (l >= -p)
          if (l <= p) {
            const m = 1 / f;
            u *= m, l *= m, _ = u * (u + r * l + 2 * o) + l * (r * u + l + 2 * c) + h;
          } else
            l = a, u = Math[n(1803)](0, -(r * l + o)), _ = -u * u + l * (l + 2 * c) + h;
        else
          l = -a, u = Math[n(1803)](0, -(r * l + o)), _ = -u * u + l * (l + 2 * c) + h;
      else
        l <= -p ? (u = Math.max(0, -(-r * a + o)), l = u > 0 ? -a : Math.min(Math[n(1803)](-a, -c), a), _ = -u * u + l * (l + 2 * c) + h) : l <= p ? (u = 0, l = Math[n(3085)](Math.max(-a, -c), a), _ = l * (l + 2 * c) + h) : (u = Math[n(1803)](0, -(r * a + o)), l = u > 0 ? a : Math[n(3085)](Math[n(1803)](-a, -c), a), _ = -u * u + l * (l + 2 * c) + h);
    else
      l = r > 0 ? -a : a, u = Math.max(0, -(r * l + o)), _ = -u * u + l * (l + 2 * c) + h;
    return t && t[n(2875)](this[n(1149)]).addScaledVector(this[n(2847)], u), i && i.copy(Xa)[n(1990)](us, l), _;
  }
  intersectSphere(e, x) {
    const t = s;
    $e[t(1061)](e[t(551)], this[t(1149)]);
    const i = $e[t(1454)](this.direction), n = $e.dot($e) - i * i, a = e[t(1232)] * e[t(1232)];
    if (n > a)
      return null;
    const r = Math.sqrt(a - n), o = i - r, c = i + r;
    return c < 0 ? null : o < 0 ? this.at(c, x) : this.at(o, x);
  }
  [s(2935)](e) {
    const x = s;
    return this.distanceSqToPoint(e[x(551)]) <= e[x(1232)] * e[x(1232)];
  }
  distanceToPlane(e) {
    const x = s, t = e[x(2111)][x(1454)](this[x(2847)]);
    if (t === 0)
      return e[x(618)](this.origin) === 0 ? 0 : null;
    const i = -(this[x(1149)][x(1454)](e[x(2111)]) + e[x(2656)]) / t;
    return i >= 0 ? i : null;
  }
  intersectPlane(e, x) {
    const t = s, i = this[t(1668)](e);
    return i === null ? null : this.at(i, x);
  }
  [s(782)](e) {
    const x = s, t = e[x(618)](this.origin);
    return t === 0 ? !![] : e[x(2111)].dot(this[x(2847)]) * t < 0 ? !![] : ![];
  }
  [s(512)](e, x) {
    const t = s;
    let i, n, a, r, o, c;
    const h = 1 / this[t(2847)].x, f = 1 / this.direction.y, u = 1 / this[t(2847)].z, l = this.origin;
    return h >= 0 ? (i = (e[t(3085)].x - l.x) * h, n = (e[t(1803)].x - l.x) * h) : (i = (e[t(1803)].x - l.x) * h, n = (e[t(3085)].x - l.x) * h), f >= 0 ? (a = (e[t(3085)].y - l.y) * f, r = (e.max.y - l.y) * f) : (a = (e.max.y - l.y) * f, r = (e.min.y - l.y) * f), i > r || a > n || ((a > i || isNaN(i)) && (i = a), (r < n || isNaN(n)) && (n = r), u >= 0 ? (o = (e.min.z - l.z) * u, c = (e[t(1803)].z - l.z) * u) : (o = (e[t(1803)].z - l.z) * u, c = (e.min.z - l.z) * u), i > c || o > n) || ((o > i || i !== i) && (i = o), (c < n || n !== n) && (n = c), n < 0) ? null : this.at(i >= 0 ? i : n, x);
  }
  [s(2549)](e) {
    return this[s(512)](e, $e) !== null;
  }
  [s(1131)](e, x, t, i, n) {
    const a = s;
    qa[a(1061)](x, e), bs[a(1061)](t, e), Ya[a(956)](qa, bs);
    let r = this[a(2847)][a(1454)](Ya), o;
    if (r > 0) {
      if (i)
        return null;
      o = 1;
    } else if (r < 0)
      o = -1, r = -r;
    else
      return null;
    ht.subVectors(this[a(1149)], e);
    const c = o * this[a(2847)][a(1454)](bs[a(956)](ht, bs));
    if (c < 0)
      return null;
    const h = o * this.direction.dot(qa[a(1929)](ht));
    if (h < 0 || c + h > r)
      return null;
    const f = -o * ht.dot(Ya);
    return f < 0 ? null : this.at(f / r, n);
  }
  [s(2442)](e) {
    const x = s;
    return this[x(1149)][x(2442)](e), this[x(2847)][x(1657)](e), this;
  }
  [s(2828)](e) {
    const x = s;
    return e[x(1149)][x(2828)](this.origin) && e[x(2847)][x(2828)](this.direction);
  }
  [s(2272)]() {
    const e = s;
    return new this[e(2787)]().copy(this);
  }
}
class ix {
  constructor() {
    const e = s;
    ix[e(2028)][e(3146)] = !![], this[e(717)] = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  }
  [s(1260)](e, x, t, i, n, a, r, o, c, h, f, u, l, _, p, m) {
    const y = s, v = this[y(717)];
    return v[0] = e, v[4] = x, v[8] = t, v[12] = i, v[1] = n, v[5] = a, v[9] = r, v[13] = o, v[2] = c, v[6] = h, v[10] = f, v[14] = u, v[3] = l, v[7] = _, v[11] = p, v[15] = m, this;
  }
  [s(836)]() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    const e = s;
    return new ix().fromArray(this[e(717)]);
  }
  [s(2875)](e) {
    const x = s, t = this[x(717)], i = e.elements;
    return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], t[9] = i[9], t[10] = i[10], t[11] = i[11], t[12] = i[12], t[13] = i[13], t[14] = i[14], t[15] = i[15], this;
  }
  [s(689)](e) {
    const x = s, t = this[x(717)], i = e[x(717)];
    return t[12] = i[12], t[13] = i[13], t[14] = i[14], this;
  }
  setFromMatrix3(e) {
    const x = s, t = e[x(717)];
    return this[x(1260)](t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this;
  }
  [s(2014)](e, x, t) {
    const i = s;
    return e[i(3531)](this, 0), x[i(3531)](this, 1), t[i(3531)](this, 2), this;
  }
  [s(452)](e, x, t) {
    return this[s(1260)](e.x, x.x, t.x, 0, e.y, x.y, t.y, 0, e.z, x.z, t.z, 0, 0, 0, 0, 1), this;
  }
  [s(524)](e) {
    const x = s, t = this.elements, i = e[x(717)], n = 1 / bi[x(3531)](e, 0)[x(3105)](), a = 1 / bi[x(3531)](e, 1)[x(3105)](), r = 1 / bi[x(3531)](e, 2)[x(3105)]();
    return t[0] = i[0] * n, t[1] = i[1] * n, t[2] = i[2] * n, t[3] = 0, t[4] = i[4] * a, t[5] = i[5] * a, t[6] = i[6] * a, t[7] = 0, t[8] = i[8] * r, t[9] = i[9] * r, t[10] = i[10] * r, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  [s(2793)](e) {
    const x = s, t = this[x(717)], i = e.x, n = e.y, a = e.z, r = Math[x(2063)](i), o = Math.sin(i), c = Math[x(2063)](n), h = Math[x(2626)](n), f = Math[x(2063)](a), u = Math[x(2626)](a);
    if (e[x(3119)] === "XYZ") {
      const l = r * f, _ = r * u, p = o * f, m = o * u;
      t[0] = c * f, t[4] = -c * u, t[8] = h, t[1] = _ + p * h, t[5] = l - m * h, t[9] = -o * c, t[2] = m - l * h, t[6] = p + _ * h, t[10] = r * c;
    } else if (e[x(3119)] === x(2157)) {
      const l = c * f, _ = c * u, p = h * f, m = h * u;
      t[0] = l + m * o, t[4] = p * o - _, t[8] = r * h, t[1] = r * u, t[5] = r * f, t[9] = -o, t[2] = _ * o - p, t[6] = m + l * o, t[10] = r * c;
    } else if (e[x(3119)] === x(760)) {
      const l = c * f, _ = c * u, p = h * f, m = h * u;
      t[0] = l - m * o, t[4] = -r * u, t[8] = p + _ * o, t[1] = _ + p * o, t[5] = r * f, t[9] = m - l * o, t[2] = -r * h, t[6] = o, t[10] = r * c;
    } else if (e.order === "ZYX") {
      const l = r * f, _ = r * u, p = o * f, m = o * u;
      t[0] = c * f, t[4] = p * h - _, t[8] = l * h + m, t[1] = c * u, t[5] = m * h + l, t[9] = _ * h - p, t[2] = -h, t[6] = o * c, t[10] = r * c;
    } else if (e[x(3119)] === "YZX") {
      const l = r * c, _ = r * h, p = o * c, m = o * h;
      t[0] = c * f, t[4] = m - l * u, t[8] = p * u + _, t[1] = u, t[5] = r * f, t[9] = -o * f, t[2] = -h * f, t[6] = _ * u + p, t[10] = l - m * u;
    } else if (e.order === x(3140)) {
      const l = r * c, _ = r * h, p = o * c, m = o * h;
      t[0] = c * f, t[4] = -u, t[8] = h * f, t[1] = l * u + m, t[5] = r * f, t[9] = _ * u - p, t[2] = p * u - _, t[6] = o * f, t[10] = m * u + l;
    }
    return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromQuaternion(e) {
    return this[s(1825)](al, e, rl);
  }
  [s(2577)](e, x, t) {
    const i = s, n = this[i(717)];
    return me[i(1061)](e, x), me[i(2296)]() === 0 && (me.z = 1), me[i(608)](), ft[i(956)](t, me), ft[i(2296)]() === 0 && (Math.abs(t.z) === 1 ? me.x += 1e-4 : me.z += 1e-4, me.normalize(), ft[i(956)](t, me)), ft[i(608)](), ps[i(956)](me, ft), n[0] = ft.x, n[4] = ps.x, n[8] = me.x, n[1] = ft.y, n[5] = ps.y, n[9] = me.y, n[2] = ft.z, n[6] = ps.z, n[10] = me.z, this;
  }
  [s(2246)](e) {
    return this[s(3117)](this, e);
  }
  [s(3272)](e) {
    return this[s(3117)](e, this);
  }
  multiplyMatrices(e, x) {
    const t = s, i = e[t(717)], n = x.elements, a = this[t(717)], r = i[0], o = i[4], c = i[8], h = i[12], f = i[1], u = i[5], l = i[9], _ = i[13], p = i[2], m = i[6], y = i[10], v = i[14], g = i[3], b = i[7], M = i[11], A = i[15], L = n[0], P = n[4], S = n[8], I = n[12], C = n[1], G = n[5], $ = n[9], N = n[13], V = n[2], X = n[6], n0 = n[10], b0 = n[14], Q = n[3], r0 = n[7], l0 = n[11], v0 = n[15];
    return a[0] = r * L + o * C + c * V + h * Q, a[4] = r * P + o * G + c * X + h * r0, a[8] = r * S + o * $ + c * n0 + h * l0, a[12] = r * I + o * N + c * b0 + h * v0, a[1] = f * L + u * C + l * V + _ * Q, a[5] = f * P + u * G + l * X + _ * r0, a[9] = f * S + u * $ + l * n0 + _ * l0, a[13] = f * I + u * N + l * b0 + _ * v0, a[2] = p * L + m * C + y * V + v * Q, a[6] = p * P + m * G + y * X + v * r0, a[10] = p * S + m * $ + y * n0 + v * l0, a[14] = p * I + m * N + y * b0 + v * v0, a[3] = g * L + b * C + M * V + A * Q, a[7] = g * P + b * G + M * X + A * r0, a[11] = g * S + b * $ + M * n0 + A * l0, a[15] = g * I + b * N + M * b0 + A * v0, this;
  }
  [s(580)](e) {
    const x = s, t = this[x(717)];
    return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this;
  }
  determinant() {
    const e = s, x = this[e(717)], t = x[0], i = x[4], n = x[8], a = x[12], r = x[1], o = x[5], c = x[9], h = x[13], f = x[2], u = x[6], l = x[10], _ = x[14], p = x[3], m = x[7], y = x[11], v = x[15];
    return p * (+a * c * u - n * h * u - a * o * l + i * h * l + n * o * _ - i * c * _) + m * (+t * c * _ - t * h * l + a * r * l - n * r * _ + n * h * f - a * c * f) + y * (+t * h * u - t * o * _ - a * r * u + i * r * _ + a * o * f - i * h * f) + v * (-n * o * f - t * c * u + t * o * l + n * r * u - i * r * l + i * c * f);
  }
  [s(2921)]() {
    const e = s, x = this[e(717)];
    let t;
    return t = x[1], x[1] = x[4], x[4] = t, t = x[2], x[2] = x[8], x[8] = t, t = x[6], x[6] = x[9], x[9] = t, t = x[3], x[3] = x[12], x[12] = t, t = x[7], x[7] = x[13], x[13] = t, t = x[11], x[11] = x[14], x[14] = t, this;
  }
  [s(1350)](e, x, t) {
    const i = s, n = this[i(717)];
    return e.isVector3 ? (n[12] = e.x, n[13] = e.y, n[14] = e.z) : (n[12] = e, n[13] = x, n[14] = t), this;
  }
  [s(1525)]() {
    const e = s, x = this[e(717)], t = x[0], i = x[1], n = x[2], a = x[3], r = x[4], o = x[5], c = x[6], h = x[7], f = x[8], u = x[9], l = x[10], _ = x[11], p = x[12], m = x[13], y = x[14], v = x[15], g = u * y * h - m * l * h + m * c * _ - o * y * _ - u * c * v + o * l * v, b = p * l * h - f * y * h - p * c * _ + r * y * _ + f * c * v - r * l * v, M = f * m * h - p * u * h + p * o * _ - r * m * _ - f * o * v + r * u * v, A = p * u * c - f * m * c - p * o * l + r * m * l + f * o * y - r * u * y, L = t * g + i * b + n * M + a * A;
    if (L === 0)
      return this[e(1260)](0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const P = 1 / L;
    return x[0] = g * P, x[1] = (m * l * a - u * y * a - m * n * _ + i * y * _ + u * n * v - i * l * v) * P, x[2] = (o * y * a - m * c * a + m * n * h - i * y * h - o * n * v + i * c * v) * P, x[3] = (u * c * a - o * l * a - u * n * h + i * l * h + o * n * _ - i * c * _) * P, x[4] = b * P, x[5] = (f * y * a - p * l * a + p * n * _ - t * y * _ - f * n * v + t * l * v) * P, x[6] = (p * c * a - r * y * a - p * n * h + t * y * h + r * n * v - t * c * v) * P, x[7] = (r * l * a - f * c * a + f * n * h - t * l * h - r * n * _ + t * c * _) * P, x[8] = M * P, x[9] = (p * u * a - f * m * a - p * i * _ + t * m * _ + f * i * v - t * u * v) * P, x[10] = (r * m * a - p * o * a + p * i * h - t * m * h - r * i * v + t * o * v) * P, x[11] = (f * o * a - r * u * a - f * i * h + t * u * h + r * i * _ - t * o * _) * P, x[12] = A * P, x[13] = (f * m * n - p * u * n + p * i * l - t * m * l - f * i * y + t * u * y) * P, x[14] = (p * o * n - r * m * n - p * i * c + t * m * c + r * i * y - t * o * y) * P, x[15] = (r * u * n - f * o * n + f * i * c - t * u * c - r * i * l + t * o * l) * P, this;
  }
  scale(e) {
    const x = s, t = this[x(717)], i = e.x, n = e.y, a = e.z;
    return t[0] *= i, t[4] *= n, t[8] *= a, t[1] *= i, t[5] *= n, t[9] *= a, t[2] *= i, t[6] *= n, t[10] *= a, t[3] *= i, t[7] *= n, t[11] *= a, this;
  }
  getMaxScaleOnAxis() {
    const e = s, x = this[e(717)], t = x[0] * x[0] + x[1] * x[1] + x[2] * x[2], i = x[4] * x[4] + x[5] * x[5] + x[6] * x[6], n = x[8] * x[8] + x[9] * x[9] + x[10] * x[10];
    return Math[e(713)](Math.max(t, i, n));
  }
  makeTranslation(e, x, t) {
    return this[s(1260)](1, 0, 0, e, 0, 1, 0, x, 0, 0, 1, t, 0, 0, 0, 1), this;
  }
  [s(2323)](e) {
    const x = s, t = Math[x(2063)](e), i = Math[x(2626)](e);
    return this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1), this;
  }
  [s(543)](e) {
    const x = s, t = Math[x(2063)](e), i = Math[x(2626)](e);
    return this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1), this;
  }
  [s(2519)](e) {
    const x = s, t = Math[x(2063)](e), i = Math.sin(e);
    return this[x(1260)](t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  [s(2857)](e, x) {
    const t = s, i = Math[t(2063)](x), n = Math[t(2626)](x), a = 1 - i, r = e.x, o = e.y, c = e.z, h = a * r, f = a * o;
    return this[t(1260)](h * r + i, h * o - n * c, h * c + n * o, 0, h * o + n * c, f * o + i, f * c - n * r, 0, h * c - n * o, f * c + n * r, a * c * c + i, 0, 0, 0, 0, 1), this;
  }
  [s(1018)](e, x, t) {
    return this.set(e, 0, 0, 0, 0, x, 0, 0, 0, 0, t, 0, 0, 0, 0, 1), this;
  }
  [s(1404)](e, x, t, i, n, a) {
    return this[s(1260)](1, t, n, 0, e, 1, a, 0, x, i, 1, 0, 0, 0, 0, 1), this;
  }
  [s(1825)](e, x, t) {
    const i = s, n = this[i(717)], a = x._x, r = x._y, o = x._z, c = x._w, h = a + a, f = r + r, u = o + o, l = a * h, _ = a * f, p = a * u, m = r * f, y = r * u, v = o * u, g = c * h, b = c * f, M = c * u, A = t.x, L = t.y, P = t.z;
    return n[0] = (1 - (m + v)) * A, n[1] = (_ + M) * A, n[2] = (p - b) * A, n[3] = 0, n[4] = (_ - M) * L, n[5] = (1 - (l + v)) * L, n[6] = (y + g) * L, n[7] = 0, n[8] = (p + b) * P, n[9] = (y - g) * P, n[10] = (1 - (l + m)) * P, n[11] = 0, n[12] = e.x, n[13] = e.y, n[14] = e.z, n[15] = 1, this;
  }
  [s(3653)](e, x, t) {
    const i = s, n = this.elements;
    let a = bi[i(1260)](n[0], n[1], n[2])[i(3105)]();
    const r = bi.set(n[4], n[5], n[6])[i(3105)](), o = bi.set(n[8], n[9], n[10])[i(3105)]();
    this[i(3314)]() < 0 && (a = -a), e.x = n[12], e.y = n[13], e.z = n[14], Ce[i(2875)](this);
    const h = 1 / a, f = 1 / r, u = 1 / o;
    return Ce.elements[0] *= h, Ce[i(717)][1] *= h, Ce[i(717)][2] *= h, Ce[i(717)][4] *= f, Ce[i(717)][5] *= f, Ce.elements[6] *= f, Ce[i(717)][8] *= u, Ce.elements[9] *= u, Ce[i(717)][10] *= u, x[i(2225)](Ce), t.x = a, t.y = r, t.z = o, this;
  }
  [s(1931)](e, x, t, i, n, a) {
    const r = s, o = this[r(717)], c = 2 * n / (x - e), h = 2 * n / (t - i), f = (x + e) / (x - e), u = (t + i) / (t - i), l = -(a + n) / (a - n), _ = -2 * a * n / (a - n);
    return o[0] = c, o[4] = 0, o[8] = f, o[12] = 0, o[1] = 0, o[5] = h, o[9] = u, o[13] = 0, o[2] = 0, o[6] = 0, o[10] = l, o[14] = _, o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this;
  }
  [s(2062)](e, x, t, i, n, a) {
    const r = s, o = this[r(717)], c = 1 / (x - e), h = 1 / (t - i), f = 1 / (a - n), u = (x + e) * c, l = (t + i) * h, _ = (a + n) * f;
    return o[0] = 2 * c, o[4] = 0, o[8] = 0, o[12] = -u, o[1] = 0, o[5] = 2 * h, o[9] = 0, o[13] = -l, o[2] = 0, o[6] = 0, o[10] = -2 * f, o[14] = -_, o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this;
  }
  [s(2828)](e) {
    const x = s, t = this.elements, i = e[x(717)];
    for (let n = 0; n < 16; n++)
      if (t[n] !== i[n])
        return ![];
    return !![];
  }
  fromArray(e, x = 0) {
    const t = s;
    for (let i = 0; i < 16; i++)
      this[t(717)][i] = e[i + x];
    return this;
  }
  [s(1496)](e = [], x = 0) {
    const t = s, i = this[t(717)];
    return e[x] = i[0], e[x + 1] = i[1], e[x + 2] = i[2], e[x + 3] = i[3], e[x + 4] = i[4], e[x + 5] = i[5], e[x + 6] = i[6], e[x + 7] = i[7], e[x + 8] = i[8], e[x + 9] = i[9], e[x + 10] = i[10], e[x + 11] = i[11], e[x + 12] = i[12], e[x + 13] = i[13], e[x + 14] = i[14], e[x + 15] = i[15], e;
  }
}
const bi = new z(), Ce = new ix(), al = new z(0, 0, 0), rl = new z(1, 1, 1), ft = new z(), ps = new z(), me = new z(), oo = new ix(), co = new $x();
class Xn {
  constructor(e = 0, x = 0, t = 0, i = Xn[s(974)]) {
    const n = s;
    this[n(1158)] = !![], this._x = e, this._y = x, this._z = t, this[n(2723)] = i;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    const x = s;
    this._x = e, this[x(2639)]();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    const x = s;
    this._y = e, this[x(2639)]();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get [s(3119)]() {
    return this[s(2723)];
  }
  set [s(3119)](e) {
    const x = s;
    this._order = e, this[x(2639)]();
  }
  set(e, x, t, i = this[s(2723)]) {
    const n = s;
    return this._x = e, this._y = x, this._z = t, this[n(2723)] = i, this._onChangeCallback(), this;
  }
  [s(2272)]() {
    const e = s;
    return new this[e(2787)](this._x, this._y, this._z, this[e(2723)]);
  }
  [s(2875)](e) {
    const x = s;
    return this._x = e._x, this._y = e._y, this._z = e._z, this[x(2723)] = e[x(2723)], this[x(2639)](), this;
  }
  [s(2225)](e, x = this[s(2723)], t = !![]) {
    const i = s, n = e.elements, a = n[0], r = n[4], o = n[8], c = n[1], h = n[5], f = n[9], u = n[2], l = n[6], _ = n[10];
    switch (x) {
      case "XYZ":
        this._y = Math[i(3415)](Gx(o, -1, 1)), Math[i(3373)](o) < 0.9999999 ? (this._x = Math[i(1722)](-f, _), this._z = Math.atan2(-r, a)) : (this._x = Math[i(1722)](l, h), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-Gx(f, -1, 1)), Math.abs(f) < 0.9999999 ? (this._y = Math.atan2(o, _), this._z = Math[i(1722)](c, h)) : (this._y = Math[i(1722)](-u, a), this._z = 0);
        break;
      case i(760):
        this._x = Math.asin(Gx(l, -1, 1)), Math[i(3373)](l) < 0.9999999 ? (this._y = Math.atan2(-u, _), this._z = Math[i(1722)](-r, h)) : (this._y = 0, this._z = Math[i(1722)](c, a));
        break;
      case i(1387):
        this._y = Math[i(3415)](-Gx(u, -1, 1)), Math[i(3373)](u) < 0.9999999 ? (this._x = Math[i(1722)](l, _), this._z = Math[i(1722)](c, a)) : (this._x = 0, this._z = Math[i(1722)](-r, h));
        break;
      case i(964):
        this._z = Math[i(3415)](Gx(c, -1, 1)), Math.abs(c) < 0.9999999 ? (this._x = Math[i(1722)](-f, h), this._y = Math.atan2(-u, a)) : (this._x = 0, this._y = Math[i(1722)](o, _));
        break;
      case i(3140):
        this._z = Math.asin(-Gx(r, -1, 1)), Math.abs(r) < 0.9999999 ? (this._x = Math[i(1722)](l, h), this._y = Math[i(1722)](o, a)) : (this._x = Math[i(1722)](-f, _), this._y = 0);
        break;
      default:
        console.warn(i(494) + x);
    }
    return this[i(2723)] = x, t === !![] && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, x, t) {
    return oo[s(1711)](e), this.setFromRotationMatrix(oo, x, t);
  }
  [s(3506)](e, x = this[s(2723)]) {
    return this[s(1260)](e.x, e.y, e.z, x);
  }
  [s(1144)](e) {
    return co[s(2790)](this), this.setFromQuaternion(co, e);
  }
  [s(2828)](e) {
    const x = s;
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this[x(2723)];
  }
  [s(666)](e) {
    const x = s;
    return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this[x(2723)] = e[3]), this[x(2639)](), this;
  }
  [s(1496)](e = [], x = 0) {
    const t = s;
    return e[x] = this._x, e[x + 1] = this._y, e[x + 2] = this._z, e[x + 3] = this[t(2723)], e;
  }
  [s(1970)](e) {
    const x = s;
    return this[x(2639)] = e, this;
  }
  [s(2639)]() {
  }
  *[Symbol[s(3445)]]() {
    const e = s;
    yield this._x, yield this._y, yield this._z, yield this[e(2723)];
  }
}
Xn[s(974)] = s(884);
class ya {
  constructor() {
    const e = s;
    this[e(3791)] = 1;
  }
  [s(1260)](e) {
    const x = s;
    this[x(3791)] = (1 << e | 0) >>> 0;
  }
  [s(3167)](e) {
    this.mask |= 1 << e | 0;
  }
  enableAll() {
    const e = s;
    this[e(3791)] = -1;
  }
  [s(2899)](e) {
    const x = s;
    this[x(3791)] ^= 1 << e | 0;
  }
  disable(e) {
    const x = s;
    this[x(3791)] &= ~(1 << e | 0);
  }
  disableAll() {
    const e = s;
    this[e(3791)] = 0;
  }
  [s(1081)](e) {
    return (this[s(3791)] & e.mask) !== 0;
  }
  [s(2319)](e) {
    return (this[s(3791)] & (1 << e | 0)) !== 0;
  }
}
let ol = 0;
const ho = new z(), pi = new $x(), Je = new ix(), ms = new z(), cn = new z(), cl = new z(), dl = new $x(), fo = new z(1, 0, 0), lo = new z(0, 1, 0), uo = new z(0, 0, 1), hl = { type: s(1236) }, bo = { type: s(1801) };
class px extends Ye {
  constructor() {
    const e = s;
    super(), this[e(3032)] = !![], Object.defineProperty(this, "id", { value: ol++ }), this[e(3104)] = ve(), this.name = "", this[e(566)] = e(3061), this.parent = null, this[e(3049)] = [], this.up = px[e(2560)][e(2272)]();
    const x = new z(), t = new Xn(), i = new $x(), n = new z(1, 1, 1);
    function a() {
      i[e(2790)](t, ![]);
    }
    function r() {
      t[e(2836)](i, void 0, ![]);
    }
    t[e(1970)](a), i[e(1970)](r), Object[e(455)](this, { position: { configurable: !![], enumerable: !![], value: x }, rotation: { configurable: !![], enumerable: !![], value: t }, quaternion: { configurable: !![], enumerable: !![], value: i }, scale: { configurable: !![], enumerable: !![], value: n }, modelViewMatrix: { value: new ix() }, normalMatrix: { value: new Kx() } }), this[e(1067)] = new ix(), this[e(490)] = new ix(), this[e(1126)] = px.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldNeedsUpdate = ![], this.matrixWorldAutoUpdate = px[e(2425)], this[e(479)] = new ya(), this.visible = !![], this.castShadow = ![], this[e(1719)] = ![], this[e(3431)] = !![], this.renderOrder = 0, this[e(1280)] = [], this.userData = {};
  }
  [s(3493)]() {
  }
  [s(2564)]() {
  }
  [s(2442)](e) {
    const x = s;
    this[x(1126)] && this.updateMatrix(), this[x(1067)][x(3272)](e), this[x(1067)].decompose(this[x(3571)], this.quaternion, this[x(2204)]);
  }
  applyQuaternion(e) {
    const x = s;
    return this.quaternion[x(3272)](e), this;
  }
  [s(2587)](e, x) {
    const t = s;
    this[t(3055)][t(1241)](e, x);
  }
  [s(1552)](e) {
    const x = s;
    this.quaternion[x(2790)](e, !![]);
  }
  [s(2588)](e) {
    const x = s;
    this[x(3055)][x(2225)](e);
  }
  [s(2013)](e) {
    const x = s;
    this[x(3055)][x(2875)](e);
  }
  [s(3149)](e, x) {
    const t = s;
    return pi[t(1241)](e, x), this.quaternion[t(2246)](pi), this;
  }
  [s(3160)](e, x) {
    const t = s;
    return pi[t(1241)](e, x), this[t(3055)][t(3272)](pi), this;
  }
  [s(1004)](e) {
    return this[s(3149)](fo, e);
  }
  rotateY(e) {
    return this[s(3149)](lo, e);
  }
  [s(2815)](e) {
    return this[s(3149)](uo, e);
  }
  [s(684)](e, x) {
    const t = s;
    return ho[t(2875)](e)[t(718)](this[t(3055)]), this.position[t(3026)](ho[t(580)](x)), this;
  }
  [s(2789)](e) {
    return this[s(684)](fo, e);
  }
  [s(891)](e) {
    return this[s(684)](lo, e);
  }
  translateZ(e) {
    return this[s(684)](uo, e);
  }
  [s(443)](e) {
    const x = s;
    return this[x(630)](!![], ![]), e.applyMatrix4(this[x(490)]);
  }
  [s(1313)](e) {
    const x = s;
    return this[x(630)](!![], ![]), e.applyMatrix4(Je[x(2875)](this[x(490)])[x(1525)]());
  }
  [s(2577)](e, x, t) {
    const i = s;
    e.isVector3 ? ms[i(2875)](e) : ms.set(e, x, t);
    const n = this[i(3562)];
    this[i(630)](!![], ![]), cn[i(683)](this[i(490)]), this[i(3256)] || this[i(669)] ? Je[i(2577)](cn, ms, this.up) : Je.lookAt(ms, cn, this.up), this[i(3055)][i(2225)](Je), n && (Je[i(524)](n[i(490)]), pi[i(2225)](Je), this[i(3055)][i(3272)](pi.invert()));
  }
  add(e) {
    const x = s;
    if (arguments[x(3105)] > 1) {
      for (let t = 0; t < arguments[x(3105)]; t++)
        this[x(3026)](arguments[t]);
      return this;
    }
    return e === this ? (console[x(533)](x(1066), e), this) : (e && e[x(3032)] ? (e[x(3562)] !== null && e.parent[x(3137)](e), e[x(3562)] = this, this[x(3049)][x(3156)](e), e[x(3157)](hl)) : console.error(x(2330), e), this);
  }
  [s(3137)](e) {
    const x = s;
    if (arguments[x(3105)] > 1) {
      for (let i = 0; i < arguments[x(3105)]; i++)
        this[x(3137)](arguments[i]);
      return this;
    }
    const t = this[x(3049)][x(882)](e);
    return t !== -1 && (e[x(3562)] = null, this[x(3049)][x(1733)](t, 1), e[x(3157)](bo)), this;
  }
  [s(1315)]() {
    const e = s, x = this[e(3562)];
    return x !== null && x[e(3137)](this), this;
  }
  [s(1089)]() {
    const e = s;
    for (let x = 0; x < this[e(3049)].length; x++) {
      const t = this.children[x];
      t[e(3562)] = null, t[e(3157)](bo);
    }
    return this[e(3049)].length = 0, this;
  }
  [s(3348)](e) {
    const x = s;
    return this[x(630)](!![], ![]), Je[x(2875)](this.matrixWorld).invert(), e[x(3562)] !== null && (e[x(3562)][x(630)](!![], ![]), Je[x(2246)](e.parent.matrixWorld)), e[x(2442)](Je), this[x(3026)](e), e[x(630)](![], !![]), this;
  }
  getObjectById(e) {
    return this[s(3621)]("id", e);
  }
  [s(2409)](e) {
    return this[s(3621)]("name", e);
  }
  getObjectByProperty(e, x) {
    const t = s;
    if (this[e] === x)
      return this;
    for (let i = 0, n = this[t(3049)][t(3105)]; i < n; i++) {
      const a = this[t(3049)][i], r = a[t(3621)](e, x);
      if (r !== void 0)
        return r;
    }
  }
  [s(1659)](e, x) {
    const t = s;
    let i = [];
    this[e] === x && i[t(3156)](this);
    for (let n = 0, a = this[t(3049)][t(3105)]; n < a; n++) {
      const r = this[t(3049)][n][t(1659)](e, x);
      r[t(3105)] > 0 && (i = i.concat(r));
    }
    return i;
  }
  getWorldPosition(e) {
    const x = s;
    return this[x(630)](!![], ![]), e[x(683)](this[x(490)]);
  }
  [s(451)](e) {
    const x = s;
    return this[x(630)](!![], ![]), this[x(490)].decompose(cn, e, cl), e;
  }
  [s(730)](e) {
    return this[s(630)](!![], ![]), this.matrixWorld.decompose(cn, dl, e), e;
  }
  [s(2223)](e) {
    const x = s;
    this[x(630)](!![], ![]);
    const t = this.matrixWorld[x(717)];
    return e.set(t[8], t[9], t[10]).normalize();
  }
  [s(2803)]() {
  }
  traverse(e) {
    const x = s;
    e(this);
    const t = this[x(3049)];
    for (let i = 0, n = t[x(3105)]; i < n; i++)
      t[i][x(2413)](e);
  }
  [s(2717)](e) {
    const x = s;
    if (this[x(2456)] === ![])
      return;
    e(this);
    const t = this.children;
    for (let i = 0, n = t[x(3105)]; i < n; i++)
      t[i][x(2717)](e);
  }
  [s(2890)](e) {
    const x = this.parent;
    x !== null && (e(x), x.traverseAncestors(e));
  }
  updateMatrix() {
    const e = s;
    this[e(1067)].compose(this[e(3571)], this[e(3055)], this[e(2204)]), this[e(1677)] = !![];
  }
  [s(3640)](e) {
    const x = s;
    this[x(1126)] && this[x(1290)](), (this[x(1677)] || e) && (this[x(3562)] === null ? this[x(490)][x(2875)](this[x(1067)]) : this[x(490)][x(3117)](this[x(3562)][x(490)], this[x(1067)]), this[x(1677)] = ![], e = !![]);
    const t = this[x(3049)];
    for (let i = 0, n = t.length; i < n; i++) {
      const a = t[i];
      (a[x(3573)] === !![] || e === !![]) && a[x(3640)](e);
    }
  }
  [s(630)](e, x) {
    const t = s, i = this[t(3562)];
    if (e === !![] && i !== null && i[t(3573)] === !![] && i[t(630)](!![], ![]), this.matrixAutoUpdate && this[t(1290)](), this[t(3562)] === null ? this[t(490)][t(2875)](this[t(1067)]) : this.matrixWorld[t(3117)](this[t(3562)][t(490)], this[t(1067)]), x === !![]) {
      const n = this[t(3049)];
      for (let a = 0, r = n[t(3105)]; a < r; a++) {
        const o = n[a];
        o[t(3573)] === !![] && o.updateWorldMatrix(![], !![]);
      }
    }
  }
  [s(3139)](e) {
    const x = s, t = e === void 0 || typeof e == "string", i = {};
    t && (e = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {}, nodes: {} }, i[x(2005)] = { version: 4.5, type: x(2665), generator: "Object3D.toJSON" });
    const n = {};
    n[x(3104)] = this[x(3104)], n[x(566)] = this[x(566)], this.name !== "" && (n[x(3710)] = this[x(3710)]), this[x(2721)] === !![] && (n.castShadow = !![]), this[x(1719)] === !![] && (n.receiveShadow = !![]), this[x(2456)] === ![] && (n[x(2456)] = ![]), this[x(3431)] === ![] && (n[x(3431)] = ![]), this[x(704)] !== 0 && (n[x(704)] = this[x(704)]), Object[x(2070)](this[x(2066)])[x(3105)] > 0 && (n[x(2066)] = this[x(2066)]), n[x(479)] = this[x(479)][x(3791)], n[x(1067)] = this[x(1067)][x(1496)](), this[x(1126)] === ![] && (n[x(1126)] = ![]), this.isInstancedMesh && (n.type = x(2705), n[x(1267)] = this[x(1267)], n.instanceMatrix = this[x(1312)][x(3139)](), this[x(752)] !== null && (n[x(752)] = this[x(752)][x(3139)]()));
    function a(o, c) {
      const h = x;
      return o[c[h(3104)]] === void 0 && (o[c.uuid] = c.toJSON(e)), c[h(3104)];
    }
    if (this[x(1444)])
      this[x(2525)] && (this[x(2525)][x(1035)] ? n[x(2525)] = this[x(2525)][x(3139)]() : this[x(2525)][x(1714)] && (n[x(2525)] = this[x(2525)][x(3139)](e)[x(3104)])), this[x(3169)] && this[x(3169)][x(1714)] && this.environment.isRenderTargetTexture !== !![] && (n[x(3169)] = this[x(3169)][x(3139)](e)[x(3104)]);
    else if (this[x(3464)] || this[x(725)] || this[x(3114)]) {
      n[x(1353)] = a(e[x(1986)], this.geometry);
      const o = this[x(1353)].parameters;
      if (o !== void 0 && o[x(2002)] !== void 0) {
        const c = o[x(2002)];
        if (Array[x(1609)](c))
          for (let h = 0, f = c.length; h < f; h++) {
            const u = c[h];
            a(e[x(2002)], u);
          }
        else
          a(e[x(2002)], c);
      }
    }
    if (this.isSkinnedMesh && (n[x(1886)] = this[x(1886)], n[x(3363)] = this[x(3363)][x(1496)](), this[x(962)] !== void 0 && (a(e[x(741)], this[x(962)]), n[x(962)] = this.skeleton.uuid)), this[x(1870)] !== void 0)
      if (Array.isArray(this[x(1870)])) {
        const o = [];
        for (let c = 0, h = this[x(1870)][x(3105)]; c < h; c++)
          o[x(3156)](a(e[x(1876)], this[x(1870)][c]));
        n[x(1870)] = o;
      } else
        n.material = a(e[x(1876)], this[x(1870)]);
    if (this[x(3049)].length > 0) {
      n[x(3049)] = [];
      for (let o = 0; o < this[x(3049)][x(3105)]; o++)
        n[x(3049)].push(this[x(3049)][o][x(3139)](e)[x(1413)]);
    }
    if (this[x(1280)][x(3105)] > 0) {
      n[x(1280)] = [];
      for (let o = 0; o < this.animations.length; o++) {
        const c = this[x(1280)][o];
        n[x(1280)][x(3156)](a(e.animations, c));
      }
    }
    if (t) {
      const o = r(e[x(1986)]), c = r(e[x(1876)]), h = r(e.textures), f = r(e.images), u = r(e[x(2002)]), l = r(e[x(741)]), _ = r(e.animations), p = r(e[x(1347)]);
      o[x(3105)] > 0 && (i.geometries = o), c.length > 0 && (i[x(1876)] = c), h[x(3105)] > 0 && (i[x(1822)] = h), f.length > 0 && (i.images = f), u[x(3105)] > 0 && (i[x(2002)] = u), l[x(3105)] > 0 && (i[x(741)] = l), _[x(3105)] > 0 && (i.animations = _), p[x(3105)] > 0 && (i[x(1347)] = p);
    }
    return i.object = n, i;
    function r(o) {
      const c = x, h = [];
      for (const f in o) {
        const u = o[f];
        delete u[c(2005)], h[c(3156)](u);
      }
      return h;
    }
  }
  [s(2272)](e) {
    const x = s;
    return new this[x(2787)]()[x(2875)](this, e);
  }
  [s(2875)](e, x = !![]) {
    const t = s;
    if (this[t(3710)] = e.name, this.up[t(2875)](e.up), this[t(3571)][t(2875)](e[t(3571)]), this[t(591)][t(3119)] = e[t(591)].order, this[t(3055)][t(2875)](e[t(3055)]), this.scale[t(2875)](e[t(2204)]), this[t(1067)][t(2875)](e[t(1067)]), this[t(490)][t(2875)](e[t(490)]), this[t(1126)] = e[t(1126)], this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this[t(3573)] = e.matrixWorldAutoUpdate, this[t(479)][t(3791)] = e.layers[t(3791)], this[t(2456)] = e[t(2456)], this[t(2721)] = e.castShadow, this[t(1719)] = e[t(1719)], this[t(3431)] = e[t(3431)], this[t(704)] = e[t(704)], this.userData = JSON[t(1359)](JSON.stringify(e[t(2066)])), x === !![])
      for (let i = 0; i < e[t(3049)].length; i++) {
        const n = e[t(3049)][i];
        this[t(3026)](n.clone());
      }
    return this;
  }
}
px[s(2560)] = new z(0, 1, 0), px[s(3097)] = !![], px.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !![];
const Le = new z(), Qe = new z(), Za = new z(), xt = new z(), mi = new z(), gi = new z(), po = new z(), Ka = new z(), $a = new z(), Ja = new z();
class Ee {
  constructor(e = new z(), x = new z(), t = new z()) {
    this.a = e, this.b = x, this.c = t;
  }
  static getNormal(e, x, t, i) {
    const n = s;
    i.subVectors(t, x), Le[n(1061)](e, x), i[n(1929)](Le);
    const a = i[n(2296)]();
    return a > 0 ? i.multiplyScalar(1 / Math.sqrt(a)) : i[n(1260)](0, 0, 0);
  }
  static [s(1568)](e, x, t, i, n) {
    const a = s;
    Le[a(1061)](i, x), Qe[a(1061)](t, x), Za[a(1061)](e, x);
    const r = Le[a(1454)](Le), o = Le[a(1454)](Qe), c = Le.dot(Za), h = Qe[a(1454)](Qe), f = Qe.dot(Za), u = r * h - o * o;
    if (u === 0)
      return n[a(1260)](-2, -1, -1);
    const l = 1 / u, _ = (h * c - o * f) * l, p = (r * f - o * c) * l;
    return n[a(1260)](1 - _ - p, p, _);
  }
  static [s(3014)](e, x, t, i) {
    return this[s(1568)](e, x, t, i, xt), xt.x >= 0 && xt.y >= 0 && xt.x + xt.y <= 1;
  }
  static [s(457)](e, x, t, i, n, a, r, o) {
    const c = s;
    return this.getBarycoord(e, x, t, i, xt), o.set(0, 0), o[c(1990)](n, xt.x), o[c(1990)](a, xt.y), o[c(1990)](r, xt.z), o;
  }
  static [s(1130)](e, x, t, i) {
    const n = s;
    return Le[n(1061)](t, x), Qe[n(1061)](e, x), Le[n(1929)](Qe)[n(1454)](i) < 0 ? !![] : ![];
  }
  [s(1260)](e, x, t) {
    const i = s;
    return this.a[i(2875)](e), this.b[i(2875)](x), this.c[i(2875)](t), this;
  }
  setFromPointsAndIndices(e, x, t, i) {
    const n = s;
    return this.a[n(2875)](e[x]), this.b[n(2875)](e[t]), this.c[n(2875)](e[i]), this;
  }
  setFromAttributeAndIndices(e, x, t, i) {
    const n = s;
    return this.a.fromBufferAttribute(e, x), this.b[n(804)](e, t), this.c[n(804)](e, i), this;
  }
  [s(2272)]() {
    const e = s;
    return new this[e(2787)]()[e(2875)](this);
  }
  copy(e) {
    const x = s;
    return this.a[x(2875)](e.a), this.b[x(2875)](e.b), this.c[x(2875)](e.c), this;
  }
  [s(3259)]() {
    const e = s;
    return Le[e(1061)](this.c, this.b), Qe[e(1061)](this.a, this.b), Le[e(1929)](Qe)[e(3105)]() * 0.5;
  }
  [s(2655)](e) {
    const x = s;
    return e[x(1168)](this.a, this.b)[x(3026)](this.c)[x(580)](1 / 3);
  }
  [s(2141)](e) {
    return Ee[s(2141)](this.a, this.b, this.c, e);
  }
  [s(1804)](e) {
    return e[s(1574)](this.a, this.b, this.c);
  }
  [s(1568)](e, x) {
    return Ee[s(1568)](e, this.a, this.b, this.c, x);
  }
  [s(457)](e, x, t, i, n) {
    return Ee[s(457)](e, this.a, this.b, this.c, x, t, i, n);
  }
  [s(3014)](e) {
    return Ee[s(3014)](e, this.a, this.b, this.c);
  }
  [s(1130)](e) {
    return Ee[s(1130)](this.a, this.b, this.c, e);
  }
  [s(2549)](e) {
    return e[s(1265)](this);
  }
  [s(2559)](e, x) {
    const t = s, i = this.a, n = this.b, a = this.c;
    let r, o;
    mi.subVectors(n, i), gi[t(1061)](a, i), Ka[t(1061)](e, i);
    const c = mi[t(1454)](Ka), h = gi[t(1454)](Ka);
    if (c <= 0 && h <= 0)
      return x[t(2875)](i);
    $a[t(1061)](e, n);
    const f = mi[t(1454)]($a), u = gi[t(1454)]($a);
    if (f >= 0 && u <= f)
      return x[t(2875)](n);
    const l = c * u - f * h;
    if (l <= 0 && c >= 0 && f <= 0)
      return r = c / (c - f), x[t(2875)](i)[t(1990)](mi, r);
    Ja[t(1061)](e, a);
    const _ = mi[t(1454)](Ja), p = gi.dot(Ja);
    if (p >= 0 && _ <= p)
      return x.copy(a);
    const m = _ * h - c * p;
    if (m <= 0 && h >= 0 && p <= 0)
      return o = h / (h - p), x[t(2875)](i)[t(1990)](gi, o);
    const y = f * p - _ * u;
    if (y <= 0 && u - f >= 0 && _ - p >= 0)
      return po[t(1061)](a, n), o = (u - f) / (u - f + (_ - p)), x[t(2875)](n)[t(1990)](po, o);
    const v = 1 / (y + m + l);
    return r = m * v, o = l * v, x[t(2875)](i)[t(1990)](mi, r)[t(1990)](gi, o);
  }
  [s(2828)](e) {
    const x = s;
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c[x(2828)](this.c);
  }
}
let fl = 0;
class jx extends Ye {
  constructor() {
    const e = s;
    super(), this[e(1447)] = !![], Object[e(1117)](this, "id", { value: fl++ }), this.uuid = ve(), this[e(3710)] = "", this[e(566)] = e(595), this[e(3019)] = ei, this[e(679)] = Xe, this[e(3530)] = ![], this.opacity = 1, this[e(1885)] = ![], this[e(3260)] = m2, this.blendDst = g2, this[e(2404)] = jt, this[e(2044)] = null, this[e(2619)] = null, this[e(1556)] = null, this[e(1844)] = fa, this.depthTest = !![], this[e(3307)] = !![], this[e(2314)] = 255, this.stencilFunc = Bd, this[e(1532)] = 0, this.stencilFuncMask = 255, this.stencilFail = ca, this[e(1771)] = ca, this.stencilZPass = ca, this[e(2975)] = ![], this.clippingPlanes = null, this[e(1402)] = ![], this[e(1467)] = ![], this[e(988)] = null, this[e(860)] = !![], this[e(537)] = null, this[e(2455)] = ![], this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this[e(2995)] = ![], this[e(447)] = ![], this[e(624)] = ![], this[e(2611)] = ![], this[e(2456)] = !![], this[e(626)] = !![], this[e(2066)] = {}, this[e(2185)] = 0, this._alphaTest = 0;
  }
  get [s(3303)]() {
    return this[s(2566)];
  }
  set [s(3303)](e) {
    const x = s;
    this._alphaTest > 0 != e > 0 && this[x(2185)]++, this[x(2566)] = e;
  }
  [s(985)]() {
  }
  [s(3493)]() {
  }
  [s(2610)]() {
  }
  customProgramCacheKey() {
    const e = s;
    return this[e(2610)][e(2670)]();
  }
  [s(1104)](e) {
    const x = s;
    if (e !== void 0)
      for (const t in e) {
        const i = e[t];
        if (i === void 0) {
          console[x(3629)](x(593) + t + x(3638));
          continue;
        }
        const n = this[t];
        if (n === void 0) {
          console[x(3629)](x(2351) + this.type + ": '" + t + x(1008));
          continue;
        }
        n && n[x(1035)] ? n[x(1260)](i) : n && n[x(3804)] && i && i[x(3804)] ? n[x(2875)](i) : this[t] = i;
      }
  }
  toJSON(e) {
    const x = s, t = e === void 0 || typeof e === x(3335);
    t && (e = { textures: {}, images: {} });
    const i = { metadata: { version: 4.5, type: x(595), generator: "Material.toJSON" } };
    i[x(3104)] = this[x(3104)], i.type = this[x(566)], this.name !== "" && (i[x(3710)] = this[x(3710)]), this[x(3282)] && this[x(3282)].isColor && (i[x(3282)] = this[x(3282)][x(2862)]()), this[x(771)] !== void 0 && (i[x(771)] = this[x(771)]), this[x(1586)] !== void 0 && (i.metalness = this[x(1586)]), this[x(1031)] !== void 0 && (i.sheen = this.sheen), this[x(807)] && this[x(807)][x(1035)] && (i.sheenColor = this[x(807)][x(2862)]()), this[x(1915)] !== void 0 && (i.sheenRoughness = this[x(1915)]), this[x(1599)] && this.emissive.isColor && (i[x(1599)] = this[x(1599)][x(2862)]()), this[x(1148)] && this[x(1148)] !== 1 && (i[x(1148)] = this[x(1148)]), this.specular && this.specular[x(1035)] && (i[x(881)] = this[x(881)][x(2862)]()), this.specularIntensity !== void 0 && (i[x(1354)] = this.specularIntensity), this[x(3367)] && this.specularColor[x(1035)] && (i[x(3367)] = this[x(3367)][x(2862)]()), this[x(1274)] !== void 0 && (i.shininess = this[x(1274)]), this[x(2317)] !== void 0 && (i[x(2317)] = this[x(2317)]), this[x(1163)] !== void 0 && (i[x(1163)] = this[x(1163)]), this[x(945)] && this[x(945)][x(1714)] && (i[x(945)] = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this[x(1660)][x(1714)] && (i[x(1660)] = this.clearcoatRoughnessMap.toJSON(e)[x(3104)]), this[x(3674)] && this[x(3674)].isTexture && (i[x(3674)] = this.clearcoatNormalMap[x(3139)](e).uuid, i[x(1111)] = this[x(1111)][x(1496)]()), this[x(3727)] !== void 0 && (i[x(3727)] = this[x(3727)]), this[x(477)] !== void 0 && (i[x(477)] = this[x(477)]), this.iridescenceThicknessRange !== void 0 && (i[x(2845)] = this[x(2845)]), this.iridescenceMap && this[x(2734)][x(1714)] && (i.iridescenceMap = this.iridescenceMap[x(3139)](e)[x(3104)]), this[x(3360)] && this[x(3360)].isTexture && (i.iridescenceThicknessMap = this[x(3360)][x(3139)](e)[x(3104)]), this.map && this.map[x(1714)] && (i.map = this[x(3644)][x(3139)](e)[x(3104)]), this.matcap && this[x(1247)][x(1714)] && (i[x(1247)] = this[x(1247)][x(3139)](e)[x(3104)]), this[x(1453)] && this[x(1453)][x(1714)] && (i[x(1453)] = this[x(1453)][x(3139)](e)[x(3104)]), this[x(2399)] && this.lightMap[x(1714)] && (i[x(2399)] = this[x(2399)][x(3139)](e).uuid, i[x(623)] = this[x(623)]), this.aoMap && this[x(2107)].isTexture && (i.aoMap = this.aoMap[x(3139)](e)[x(3104)], i[x(2702)] = this[x(2702)]), this.bumpMap && this[x(758)].isTexture && (i.bumpMap = this.bumpMap[x(3139)](e)[x(3104)], i[x(470)] = this.bumpScale), this[x(811)] && this[x(811)][x(1714)] && (i[x(811)] = this[x(811)][x(3139)](e)[x(3104)], i.normalMapType = this[x(920)], i[x(2650)] = this[x(2650)][x(1496)]()), this.displacementMap && this[x(629)].isTexture && (i[x(629)] = this[x(629)][x(3139)](e)[x(3104)], i[x(2693)] = this[x(2693)], i.displacementBias = this.displacementBias), this[x(3213)] && this[x(3213)].isTexture && (i.roughnessMap = this[x(3213)][x(3139)](e)[x(3104)]), this[x(989)] && this[x(989)][x(1714)] && (i[x(989)] = this[x(989)][x(3139)](e)[x(3104)]), this.emissiveMap && this[x(2730)][x(1714)] && (i.emissiveMap = this.emissiveMap[x(3139)](e)[x(3104)]), this[x(3470)] && this[x(3470)][x(1714)] && (i.specularMap = this[x(3470)][x(3139)](e)[x(3104)]), this[x(1581)] && this.specularIntensityMap[x(1714)] && (i[x(1581)] = this[x(1581)][x(3139)](e)[x(3104)]), this[x(3637)] && this[x(3637)][x(1714)] && (i.specularColorMap = this[x(3637)][x(3139)](e)[x(3104)]), this[x(1477)] && this[x(1477)][x(1714)] && (i[x(1477)] = this.envMap[x(3139)](e)[x(3104)], this[x(2997)] !== void 0 && (i[x(2997)] = this[x(2997)])), this[x(3176)] !== void 0 && (i[x(3176)] = this[x(3176)]), this[x(2531)] !== void 0 && (i.reflectivity = this[x(2531)]), this.refractionRatio !== void 0 && (i.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this[x(2767)][x(3139)](e).uuid), this.transmission !== void 0 && (i[x(2123)] = this[x(2123)]), this[x(2325)] && this.transmissionMap[x(1714)] && (i[x(2325)] = this[x(2325)].toJSON(e).uuid), this[x(2908)] !== void 0 && (i[x(2908)] = this.thickness), this.thicknessMap && this[x(1051)].isTexture && (i[x(1051)] = this[x(1051)][x(3139)](e)[x(3104)]), this[x(532)] !== void 0 && this[x(532)] !== 1 / 0 && (i[x(532)] = this.attenuationDistance), this[x(2786)] !== void 0 && (i[x(2786)] = this[x(2786)][x(2862)]()), this[x(3073)] !== void 0 && (i[x(3073)] = this.size), this.shadowSide !== null && (i[x(988)] = this[x(988)]), this.sizeAttenuation !== void 0 && (i[x(2907)] = this.sizeAttenuation), this[x(3019)] !== ei && (i.blending = this[x(3019)]), this[x(679)] !== Xe && (i[x(679)] = this[x(679)]), this[x(3530)] && (i[x(3530)] = !![]), this[x(3746)] < 1 && (i[x(3746)] = this[x(3746)]), this[x(1885)] === !![] && (i[x(1885)] = this[x(1885)]), i[x(1844)] = this[x(1844)], i[x(770)] = this[x(770)], i[x(3307)] = this[x(3307)], i.colorWrite = this.colorWrite, i.stencilWrite = this[x(2975)], i[x(2314)] = this[x(2314)], i[x(650)] = this[x(650)], i[x(1532)] = this[x(1532)], i[x(2143)] = this[x(2143)], i[x(1832)] = this[x(1832)], i[x(1771)] = this[x(1771)], i[x(1850)] = this[x(1850)], this[x(591)] !== void 0 && this[x(591)] !== 0 && (i[x(591)] = this[x(591)]), this.polygonOffset === !![] && (i[x(2455)] = !![]), this.polygonOffsetFactor !== 0 && (i[x(2914)] = this[x(2914)]), this[x(911)] !== 0 && (i.polygonOffsetUnits = this[x(911)]), this[x(2968)] !== void 0 && this[x(2968)] !== 1 && (i.linewidth = this.linewidth), this.dashSize !== void 0 && (i[x(1831)] = this[x(1831)]), this.gapSize !== void 0 && (i.gapSize = this[x(2514)]), this[x(2204)] !== void 0 && (i[x(2204)] = this[x(2204)]), this.dithering === !![] && (i[x(2995)] = !![]), this.alphaTest > 0 && (i[x(3303)] = this[x(3303)]), this[x(447)] === !![] && (i[x(447)] = this[x(447)]), this[x(624)] === !![] && (i[x(624)] = this[x(624)]), this[x(2611)] === !![] && (i[x(2611)] = this.forceSinglePass), this[x(1124)] === !![] && (i[x(1124)] = this[x(1124)]), this[x(977)] > 1 && (i.wireframeLinewidth = this[x(977)]), this[x(2700)] !== x(1981) && (i[x(2700)] = this[x(2700)]), this[x(857)] !== x(1981) && (i[x(857)] = this[x(857)]), this[x(1529)] === !![] && (i.flatShading = this[x(1529)]), this[x(2456)] === ![] && (i[x(2456)] = ![]), this[x(626)] === ![] && (i[x(626)] = ![]), this[x(3438)] === ![] && (i.fog = ![]), Object[x(2070)](this[x(2066)]).length > 0 && (i.userData = this.userData);
    function n(a) {
      const r = x, o = [];
      for (const c in a) {
        const h = a[c];
        delete h[r(2005)], o[r(3156)](h);
      }
      return o;
    }
    if (t) {
      const a = n(e[x(1822)]), r = n(e.images);
      a[x(3105)] > 0 && (i[x(1822)] = a), r[x(3105)] > 0 && (i[x(1090)] = r);
    }
    return i;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  [s(2875)](e) {
    const x = s;
    this[x(3710)] = e.name, this[x(3019)] = e[x(3019)], this.side = e.side, this[x(3530)] = e[x(3530)], this[x(3746)] = e[x(3746)], this[x(1885)] = e[x(1885)], this[x(3260)] = e.blendSrc, this[x(1338)] = e.blendDst, this.blendEquation = e.blendEquation, this[x(2044)] = e[x(2044)], this[x(2619)] = e[x(2619)], this[x(1556)] = e[x(1556)], this.depthFunc = e.depthFunc, this[x(770)] = e[x(770)], this[x(3307)] = e[x(3307)], this[x(2314)] = e[x(2314)], this[x(650)] = e[x(650)], this[x(1532)] = e[x(1532)], this[x(2143)] = e.stencilFuncMask, this[x(1832)] = e.stencilFail, this[x(1771)] = e[x(1771)], this[x(1850)] = e[x(1850)], this[x(2975)] = e[x(2975)];
    const t = e[x(2617)];
    let i = null;
    if (t !== null) {
      const n = t[x(3105)];
      i = new Array(n);
      for (let a = 0; a !== n; ++a)
        i[a] = t[a][x(2272)]();
    }
    return this.clippingPlanes = i, this[x(1402)] = e[x(1402)], this.clipShadows = e[x(1467)], this[x(988)] = e[x(988)], this.colorWrite = e[x(860)], this[x(537)] = e[x(537)], this[x(2455)] = e[x(2455)], this.polygonOffsetFactor = e.polygonOffsetFactor, this[x(911)] = e[x(911)], this[x(2995)] = e[x(2995)], this[x(3303)] = e[x(3303)], this.alphaToCoverage = e.alphaToCoverage, this[x(624)] = e[x(624)], this[x(2611)] = e[x(2611)], this.visible = e[x(2456)], this[x(626)] = e[x(626)], this.userData = JSON.parse(JSON[x(3338)](e[x(2066)])), this;
  }
  dispose() {
    const e = s;
    this[e(3157)]({ type: e(3387) });
  }
  set [s(3035)](e) {
    const x = s;
    e === !![] && this[x(2185)]++;
  }
}
const Vd = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }, Re = { h: 0, s: 0, l: 0 }, gs = { h: 0, s: 0, l: 0 };
function Qa(d, e, x) {
  return x < 0 && (x += 1), x > 1 && (x -= 1), x < 1 / 6 ? d + (e - d) * 6 * x : x < 1 / 2 ? e : x < 2 / 3 ? d + (e - d) * 6 * (2 / 3 - x) : d;
}
class P0 {
  constructor(e, x, t) {
    const i = s;
    return this[i(1035)] = !![], this.r = 1, this.g = 1, this.b = 1, x === void 0 && t === void 0 ? this.set(e) : this.setRGB(e, x, t);
  }
  [s(1260)](e) {
    const x = s;
    return e && e[x(1035)] ? this[x(2875)](e) : typeof e === x(1407) ? this.setHex(e) : typeof e === x(3335) && this[x(431)](e), this;
  }
  [s(3417)](e) {
    return this.r = e, this.g = e, this.b = e, this;
  }
  setHex(e, x = _e) {
    const t = s;
    return e = Math[t(2697)](e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, xe[t(1543)](this, x), this;
  }
  [s(1044)](e, x, t, i = xe.workingColorSpace) {
    return this.r = e, this.g = x, this.b = t, xe.toWorkingColorSpace(this, i), this;
  }
  setHSL(e, x, t, i = xe[s(3124)]) {
    if (e = E2(e, 1), x = Gx(x, 0, 1), t = Gx(t, 0, 1), x === 0)
      this.r = this.g = this.b = t;
    else {
      const n = t <= 0.5 ? t * (1 + x) : t + x - t * x, a = 2 * t - n;
      this.r = Qa(a, n, e + 1 / 3), this.g = Qa(a, n, e), this.b = Qa(a, n, e - 1 / 3);
    }
    return xe.toWorkingColorSpace(this, i), this;
  }
  [s(431)](e, x = _e) {
    const t = s;
    function i(a) {
      const r = c0;
      a !== void 0 && parseFloat(a) < 1 && console[r(3629)](r(3566) + e + r(2108));
    }
    let n;
    if (n = /^(\w+)\(([^\)]*)\)/.exec(e)) {
      let a;
      const r = n[1], o = n[2];
      switch (r) {
        case t(1222):
        case t(2214):
          if (a = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/[t(625)](o))
            return this.r = Math[t(3085)](255, parseInt(a[1], 10)) / 255, this.g = Math[t(3085)](255, parseInt(a[2], 10)) / 255, this.b = Math.min(255, parseInt(a[3], 10)) / 255, xe[t(1543)](this, x), i(a[4]), this;
          if (a = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/[t(625)](o))
            return this.r = Math[t(3085)](100, parseInt(a[1], 10)) / 100, this.g = Math[t(3085)](100, parseInt(a[2], 10)) / 100, this.b = Math.min(100, parseInt(a[3], 10)) / 100, xe[t(1543)](this, x), i(a[4]), this;
          break;
        case t(2301):
        case "hsla":
          if (a = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/[t(625)](o)) {
            const c = parseFloat(a[1]) / 360, h = parseFloat(a[2]) / 100, f = parseFloat(a[3]) / 100;
            return i(a[4]), this.setHSL(c, h, f, x);
          }
          break;
        default:
          console[t(3629)]("THREE.Color: Unknown color model " + e);
      }
    } else if (n = /^\#([A-Fa-f\d]+)$/[t(625)](e)) {
      const a = n[1], r = a[t(3105)];
      if (r === 3)
        return this.r = parseInt(a.charAt(0) + a[t(1451)](0), 16) / 255, this.g = parseInt(a[t(1451)](1) + a[t(1451)](1), 16) / 255, this.b = parseInt(a[t(1451)](2) + a[t(1451)](2), 16) / 255, xe[t(1543)](this, x), this;
      if (r === 6)
        return this.r = parseInt(a[t(1451)](0) + a[t(1451)](1), 16) / 255, this.g = parseInt(a[t(1451)](2) + a[t(1451)](3), 16) / 255, this.b = parseInt(a.charAt(4) + a[t(1451)](5), 16) / 255, xe[t(1543)](this, x), this;
      console[t(3629)]("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0)
      return this[t(3251)](e, x);
    return this;
  }
  setColorName(e, x = _e) {
    const t = s, i = Vd[e[t(2050)]()];
    return i !== void 0 ? this[t(2548)](i, x) : console[t(3629)](t(1202) + e), this;
  }
  clone() {
    const e = s;
    return new this[e(2787)](this.r, this.g, this.b);
  }
  [s(2875)](e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this;
  }
  [s(1344)](e) {
    return this.r = zi(e.r), this.g = zi(e.g), this.b = zi(e.b), this;
  }
  [s(2978)](e) {
    return this.r = Ha(e.r), this.g = Ha(e.g), this.b = Ha(e.b), this;
  }
  convertSRGBToLinear() {
    return this[s(1344)](this), this;
  }
  [s(3346)]() {
    return this[s(2978)](this), this;
  }
  [s(2862)](e = _e) {
    const x = s;
    return xe.fromWorkingColorSpace(Qx[x(2875)](this), e), Gx(Qx.r * 255, 0, 255) << 16 ^ Gx(Qx.g * 255, 0, 255) << 8 ^ Gx(Qx.b * 255, 0, 255) << 0;
  }
  getHexString(e = _e) {
    const x = s;
    return (x(705) + this[x(2862)](e)[x(2670)](16)).slice(-6);
  }
  getHSL(e, x = xe[s(3124)]) {
    const t = s;
    xe[t(1253)](Qx[t(2875)](this), x);
    const i = Qx.r, n = Qx.g, a = Qx.b, r = Math[t(1803)](i, n, a), o = Math[t(3085)](i, n, a);
    let c, h;
    const f = (o + r) / 2;
    if (o === r)
      c = 0, h = 0;
    else {
      const u = r - o;
      switch (h = f <= 0.5 ? u / (r + o) : u / (2 - r - o), r) {
        case i:
          c = (n - a) / u + (n < a ? 6 : 0);
          break;
        case n:
          c = (a - i) / u + 2;
          break;
        case a:
          c = (i - n) / u + 4;
          break;
      }
      c /= 6;
    }
    return e.h = c, e.s = h, e.l = f, e;
  }
  [s(2657)](e, x = xe[s(3124)]) {
    const t = s;
    return xe[t(1253)](Qx[t(2875)](this), x), e.r = Qx.r, e.g = Qx.g, e.b = Qx.b, e;
  }
  getStyle(e = _e) {
    const x = s;
    xe[x(1253)](Qx[x(2875)](this), e);
    const t = Qx.r, i = Qx.g, n = Qx.b;
    return e !== _e ? x(2999) + e + " " + t[x(1577)](3) + " " + i[x(1577)](3) + " " + n[x(1577)](3) + ")" : x(437) + (t * 255 | 0) + "," + (i * 255 | 0) + "," + (n * 255 | 0) + ")";
  }
  [s(1681)](e, x, t) {
    return this[s(3495)](Re), Re.h += e, Re.s += x, Re.l += t, this.setHSL(Re.h, Re.s, Re.l), this;
  }
  [s(3026)](e) {
    return this.r += e.r, this.g += e.g, this.b += e.b, this;
  }
  [s(1068)](e, x) {
    return this.r = e.r + x.r, this.g = e.g + x.g, this.b = e.b + x.b, this;
  }
  addScalar(e) {
    return this.r += e, this.g += e, this.b += e, this;
  }
  [s(1943)](e) {
    const x = s;
    return this.r = Math.max(0, this.r - e.r), this.g = Math[x(1803)](0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
  }
  [s(2246)](e) {
    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
  }
  [s(580)](e) {
    return this.r *= e, this.g *= e, this.b *= e, this;
  }
  lerp(e, x) {
    return this.r += (e.r - this.r) * x, this.g += (e.g - this.g) * x, this.b += (e.b - this.b) * x, this;
  }
  lerpColors(e, x, t) {
    return this.r = e.r + (x.r - e.r) * t, this.g = e.g + (x.g - e.g) * t, this.b = e.b + (x.b - e.b) * t, this;
  }
  [s(1397)](e, x) {
    const t = s;
    this[t(3495)](Re), e[t(3495)](gs);
    const i = An(Re.h, gs.h, x), n = An(Re.s, gs.s, x), a = An(Re.l, gs.l, x);
    return this[t(1383)](i, n, a), this;
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  [s(666)](e, x = 0) {
    return this.r = e[x], this.g = e[x + 1], this.b = e[x + 2], this;
  }
  [s(1496)](e = [], x = 0) {
    return e[x] = this.r, e[x + 1] = this.g, e[x + 2] = this.b, e;
  }
  [s(804)](e, x) {
    const t = s;
    return this.r = e.getX(x), this.g = e.getY(x), this.b = e[t(1341)](x), this;
  }
  toJSON() {
    return this[s(2862)]();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const Qx = new P0();
P0[s(1549)] = Vd;
class be extends jx {
  constructor(e) {
    const x = s;
    super(), this[x(500)] = !![], this.type = x(1934), this[x(3282)] = new P0(16777215), this.map = null, this[x(2399)] = null, this[x(623)] = 1, this[x(2107)] = null, this[x(2702)] = 1, this[x(3470)] = null, this[x(1453)] = null, this[x(1477)] = null, this[x(2997)] = Wn, this[x(2531)] = 1, this.refractionRatio = 0.98, this.wireframe = ![], this[x(977)] = 1, this.wireframeLinecap = "round", this[x(857)] = x(1981), this[x(3438)] = !![], this[x(1104)](e);
  }
  copy(e) {
    const x = s;
    return super.copy(e), this.color.copy(e[x(3282)]), this[x(3644)] = e.map, this[x(2399)] = e[x(2399)], this[x(623)] = e.lightMapIntensity, this.aoMap = e[x(2107)], this[x(2702)] = e[x(2702)], this[x(3470)] = e[x(3470)], this[x(1453)] = e[x(1453)], this[x(1477)] = e[x(1477)], this[x(2997)] = e[x(2997)], this[x(2531)] = e.reflectivity, this[x(3759)] = e.refractionRatio, this.wireframe = e[x(1124)], this[x(977)] = e[x(977)], this[x(2700)] = e[x(2700)], this[x(857)] = e[x(857)], this[x(3438)] = e[x(3438)], this;
  }
}
const Hx = new z(), _s = new d0();
class gx {
  constructor(e, x, t = ![]) {
    const i = s;
    if (Array.isArray(e))
      throw new TypeError(i(2861));
    this[i(2474)] = !![], this[i(3710)] = "", this[i(2712)] = e, this[i(3290)] = x, this[i(1267)] = e !== void 0 ? e.length / x : 0, this[i(3320)] = t, this[i(3067)] = On, this[i(2270)] = { offset: 0, count: -1 }, this[i(2185)] = 0;
  }
  [s(3773)]() {
  }
  set needsUpdate(e) {
    const x = s;
    e === !![] && this[x(2185)]++;
  }
  [s(3542)](e) {
    const x = s;
    return this[x(3067)] = e, this;
  }
  [s(2875)](e) {
    const x = s;
    return this[x(3710)] = e.name, this.array = new e.array.constructor(e[x(2712)]), this.itemSize = e[x(3290)], this.count = e[x(1267)], this.normalized = e[x(3320)], this.usage = e[x(3067)], this;
  }
  copyAt(e, x, t) {
    const i = s;
    e *= this.itemSize, t *= x[i(3290)];
    for (let n = 0, a = this[i(3290)]; n < a; n++)
      this.array[e + n] = x.array[t + n];
    return this;
  }
  [s(3066)](e) {
    return this[s(2712)].set(e), this;
  }
  [s(1904)](e) {
    const x = s;
    if (this.itemSize === 2)
      for (let t = 0, i = this[x(1267)]; t < i; t++)
        _s.fromBufferAttribute(this, t), _s[x(1904)](e), this.setXY(t, _s.x, _s.y);
    else if (this[x(3290)] === 3)
      for (let t = 0, i = this[x(1267)]; t < i; t++)
        Hx.fromBufferAttribute(this, t), Hx[x(1904)](e), this[x(1167)](t, Hx.x, Hx.y, Hx.z);
    return this;
  }
  applyMatrix4(e) {
    const x = s;
    for (let t = 0, i = this[x(1267)]; t < i; t++)
      Hx[x(804)](this, t), Hx[x(2442)](e), this[x(1167)](t, Hx.x, Hx.y, Hx.z);
    return this;
  }
  [s(1258)](e) {
    const x = s;
    for (let t = 0, i = this[x(1267)]; t < i; t++)
      Hx.fromBufferAttribute(this, t), Hx[x(1258)](e), this[x(1167)](t, Hx.x, Hx.y, Hx.z);
    return this;
  }
  transformDirection(e) {
    const x = s;
    for (let t = 0, i = this[x(1267)]; t < i; t++)
      Hx.fromBufferAttribute(this, t), Hx.transformDirection(e), this.setXYZ(t, Hx.x, Hx.y, Hx.z);
    return this;
  }
  [s(1260)](e, x = 0) {
    const t = s;
    return this[t(2712)][t(1260)](e, x), this;
  }
  [s(781)](e) {
    const x = s;
    let t = this[x(2712)][e * this.itemSize];
    return this[x(3320)] && (t = it(t, this[x(2712)])), t;
  }
  setX(e, x) {
    const t = s;
    return this[t(3320)] && (x = Ax(x, this[t(2712)])), this[t(2712)][e * this.itemSize] = x, this;
  }
  [s(2459)](e) {
    const x = s;
    let t = this[x(2712)][e * this[x(3290)] + 1];
    return this.normalized && (t = it(t, this[x(2712)])), t;
  }
  [s(712)](e, x) {
    const t = s;
    return this[t(3320)] && (x = Ax(x, this[t(2712)])), this[t(2712)][e * this[t(3290)] + 1] = x, this;
  }
  getZ(e) {
    const x = s;
    let t = this[x(2712)][e * this[x(3290)] + 2];
    return this[x(3320)] && (t = it(t, this[x(2712)])), t;
  }
  [s(3096)](e, x) {
    const t = s;
    return this.normalized && (x = Ax(x, this.array)), this[t(2712)][e * this[t(3290)] + 2] = x, this;
  }
  [s(3549)](e) {
    const x = s;
    let t = this[x(2712)][e * this[x(3290)] + 3];
    return this.normalized && (t = it(t, this[x(2712)])), t;
  }
  setW(e, x) {
    const t = s;
    return this.normalized && (x = Ax(x, this[t(2712)])), this[t(2712)][e * this[t(3290)] + 3] = x, this;
  }
  [s(3011)](e, x, t) {
    const i = s;
    return e *= this.itemSize, this[i(3320)] && (x = Ax(x, this[i(2712)]), t = Ax(t, this[i(2712)])), this[i(2712)][e + 0] = x, this[i(2712)][e + 1] = t, this;
  }
  setXYZ(e, x, t, i) {
    const n = s;
    return e *= this[n(3290)], this[n(3320)] && (x = Ax(x, this[n(2712)]), t = Ax(t, this[n(2712)]), i = Ax(i, this[n(2712)])), this[n(2712)][e + 0] = x, this.array[e + 1] = t, this.array[e + 2] = i, this;
  }
  setXYZW(e, x, t, i, n) {
    const a = s;
    return e *= this[a(3290)], this[a(3320)] && (x = Ax(x, this[a(2712)]), t = Ax(t, this[a(2712)]), i = Ax(i, this[a(2712)]), n = Ax(n, this[a(2712)])), this[a(2712)][e + 0] = x, this.array[e + 1] = t, this[a(2712)][e + 2] = i, this.array[e + 3] = n, this;
  }
  [s(2848)](e) {
    const x = s;
    return this[x(3773)] = e, this;
  }
  clone() {
    const e = s;
    return new this[e(2787)](this[e(2712)], this.itemSize)[e(2875)](this);
  }
  [s(3139)]() {
    const e = s, x = { itemSize: this[e(3290)], type: this[e(2712)][e(2787)].name, array: Array[e(2576)](this.array), normalized: this[e(3320)] };
    return this[e(3710)] !== "" && (x[e(3710)] = this[e(3710)]), this[e(3067)] !== On && (x.usage = this[e(3067)]), (this[e(2270)].offset !== 0 || this.updateRange.count !== -1) && (x[e(2270)] = this[e(2270)]), x;
  }
  copyColorsArray() {
    const e = s;
    console[e(533)](e(2998));
  }
  [s(2363)]() {
    console.error(s(2556));
  }
  [s(1e3)]() {
    const e = s;
    console[e(533)](e(572));
  }
  [s(2361)]() {
    const e = s;
    console[e(533)](e(2241));
  }
}
class ll extends gx {
  constructor(e, x, t) {
    super(new Int8Array(e), x, t);
  }
}
class ul extends gx {
  constructor(e, x, t) {
    super(new Uint8Array(e), x, t);
  }
}
class bl extends gx {
  constructor(e, x, t) {
    super(new Uint8ClampedArray(e), x, t);
  }
}
class pl extends gx {
  constructor(e, x, t) {
    super(new Int16Array(e), x, t);
  }
}
class L2 extends gx {
  constructor(e, x, t) {
    super(new Uint16Array(e), x, t);
  }
}
class ml extends gx {
  constructor(e, x, t) {
    super(new Int32Array(e), x, t);
  }
}
class R2 extends gx {
  constructor(e, x, t) {
    super(new Uint32Array(e), x, t);
  }
}
class gl extends gx {
  constructor(e, x, t) {
    const i = s;
    super(new Uint16Array(e), x, t), this[i(2741)] = !![];
  }
}
class W0 extends gx {
  constructor(e, x, t) {
    super(new Float32Array(e), x, t);
  }
}
class _l extends gx {
  constructor(e, x, t) {
    super(new Float64Array(e), x, t);
  }
}
let vl = 0;
const Me = new ix(), xr = new px(), _i = new z(), ge = new at(), dn = new at(), Yx = new z();
class ox extends Ye {
  constructor() {
    const e = s;
    super(), this[e(3634)] = !![], Object[e(1117)](this, "id", { value: vl++ }), this[e(3104)] = ve(), this[e(3710)] = "", this[e(566)] = e(2219), this[e(3678)] = null, this[e(3265)] = {}, this[e(1034)] = {}, this.morphTargetsRelative = ![], this[e(2751)] = [], this[e(3151)] = null, this.boundingSphere = null, this[e(2499)] = { start: 0, count: 1 / 0 }, this[e(2066)] = {};
  }
  [s(2570)]() {
    return this[s(3678)];
  }
  [s(2203)](e) {
    const x = s;
    return Array.isArray(e) ? this[x(3678)] = new (kd(e) ? R2 : L2)(e, 1) : this[x(3678)] = e, this;
  }
  [s(1740)](e) {
    return this[s(3265)][e];
  }
  setAttribute(e, x) {
    return this.attributes[e] = x, this;
  }
  deleteAttribute(e) {
    const x = s;
    return delete this[x(3265)][e], this;
  }
  [s(2232)](e) {
    return this.attributes[e] !== void 0;
  }
  [s(3597)](e, x, t = 0) {
    this[s(2751)].push({ start: e, count: x, materialIndex: t });
  }
  clearGroups() {
    const e = s;
    this[e(2751)] = [];
  }
  setDrawRange(e, x) {
    const t = s;
    this[t(2499)].start = e, this[t(2499)].count = x;
  }
  applyMatrix4(e) {
    const x = s, t = this[x(3265)].position;
    t !== void 0 && (t[x(2442)](e), t[x(3035)] = !![]);
    const i = this[x(3265)][x(2111)];
    if (i !== void 0) {
      const a = new Kx()[x(1424)](e);
      i[x(1258)](a), i[x(3035)] = !![];
    }
    const n = this.attributes.tangent;
    return n !== void 0 && (n.transformDirection(e), n[x(3035)] = !![]), this[x(3151)] !== null && this[x(3568)](), this[x(3689)] !== null && this.computeBoundingSphere(), this;
  }
  [s(718)](e) {
    const x = s;
    return Me[x(1711)](e), this[x(2442)](Me), this;
  }
  [s(1004)](e) {
    return Me.makeRotationX(e), this.applyMatrix4(Me), this;
  }
  [s(899)](e) {
    const x = s;
    return Me[x(543)](e), this[x(2442)](Me), this;
  }
  [s(2815)](e) {
    const x = s;
    return Me[x(2519)](e), this[x(2442)](Me), this;
  }
  translate(e, x, t) {
    const i = s;
    return Me[i(2381)](e, x, t), this[i(2442)](Me), this;
  }
  [s(2204)](e, x, t) {
    return Me.makeScale(e, x, t), this.applyMatrix4(Me), this;
  }
  [s(2577)](e) {
    const x = s;
    return xr[x(2577)](e), xr[x(1290)](), this.applyMatrix4(xr[x(1067)]), this;
  }
  [s(551)]() {
    const e = s;
    return this.computeBoundingBox(), this[e(3151)][e(1658)](_i)[e(3515)](), this[e(864)](_i.x, _i.y, _i.z), this;
  }
  [s(646)](e) {
    const x = s, t = [];
    for (let i = 0, n = e.length; i < n; i++) {
      const a = e[i];
      t[x(3156)](a.x, a.y, a.z || 0);
    }
    return this[x(3599)](x(3571), new W0(t, 3)), this;
  }
  computeBoundingBox() {
    const e = s;
    this.boundingBox === null && (this[e(3151)] = new at());
    const x = this[e(3265)][e(3571)], t = this[e(1034)][e(3571)];
    if (x && x[e(2025)]) {
      console.error(e(2898), this), this[e(3151)][e(1260)](new z(-1 / 0, -1 / 0, -1 / 0), new z(1 / 0, 1 / 0, 1 / 0));
      return;
    }
    if (x !== void 0) {
      if (this[e(3151)].setFromBufferAttribute(x), t)
        for (let i = 0, n = t[e(3105)]; i < n; i++) {
          const a = t[i];
          ge[e(2926)](a), this[e(3150)] ? (Yx[e(1168)](this.boundingBox.min, ge.min), this.boundingBox[e(1186)](Yx), Yx[e(1168)](this.boundingBox.max, ge.max), this[e(3151)][e(1186)](Yx)) : (this[e(3151)].expandByPoint(ge[e(3085)]), this[e(3151)][e(1186)](ge.max));
        }
    } else
      this[e(3151)][e(2561)]();
    (isNaN(this.boundingBox.min.x) || isNaN(this[e(3151)].min.y) || isNaN(this[e(3151)].min.z)) && console.error(e(2887), this);
  }
  [s(2613)]() {
    const e = s;
    this[e(3689)] === null && (this[e(3689)] = new Pt());
    const x = this[e(3265)][e(3571)], t = this[e(1034)][e(3571)];
    if (x && x.isGLBufferAttribute) {
      console[e(533)](e(3760), this), this[e(3689)][e(1260)](new z(), 1 / 0);
      return;
    }
    if (x) {
      const i = this[e(3689)].center;
      if (ge[e(2926)](x), t)
        for (let a = 0, r = t[e(3105)]; a < r; a++) {
          const o = t[a];
          dn[e(2926)](o), this[e(3150)] ? (Yx.addVectors(ge.min, dn[e(3085)]), ge[e(1186)](Yx), Yx[e(1168)](ge[e(1803)], dn[e(1803)]), ge[e(1186)](Yx)) : (ge[e(1186)](dn[e(3085)]), ge[e(1186)](dn[e(1803)]));
        }
      ge[e(1658)](i);
      let n = 0;
      for (let a = 0, r = x[e(1267)]; a < r; a++)
        Yx[e(804)](x, a), n = Math[e(1803)](n, i[e(1679)](Yx));
      if (t)
        for (let a = 0, r = t.length; a < r; a++) {
          const o = t[a], c = this[e(3150)];
          for (let h = 0, f = o[e(1267)]; h < f; h++)
            Yx.fromBufferAttribute(o, h), c && (_i.fromBufferAttribute(x, h), Yx[e(3026)](_i)), n = Math.max(n, i[e(1679)](Yx));
        }
      this[e(3689)][e(1232)] = Math[e(713)](n), isNaN(this[e(3689)][e(1232)]) && console[e(533)](e(1182), this);
    }
  }
  computeTangents() {
    const e = s, x = this.index, t = this[e(3265)];
    if (x === null || t[e(3571)] === void 0 || t[e(2111)] === void 0 || t.uv === void 0) {
      console[e(533)](e(3091));
      return;
    }
    const i = x.array, n = t[e(3571)].array, a = t[e(2111)][e(2712)], r = t.uv.array, o = n.length / 3;
    this[e(2232)](e(3404)) === ![] && this[e(3599)](e(3404), new gx(new Float32Array(4 * o), 4));
    const c = this[e(1740)](e(3404))[e(2712)], h = [], f = [];
    for (let C = 0; C < o; C++)
      h[C] = new z(), f[C] = new z();
    const u = new z(), l = new z(), _ = new z(), p = new d0(), m = new d0(), y = new d0(), v = new z(), g = new z();
    function b(C, G, $) {
      const N = e;
      u[N(666)](n, C * 3), l[N(666)](n, G * 3), _[N(666)](n, $ * 3), p[N(666)](r, C * 2), m[N(666)](r, G * 2), y.fromArray(r, $ * 2), l[N(1943)](u), _[N(1943)](u), m[N(1943)](p), y[N(1943)](p);
      const V = 1 / (m.x * y.y - y.x * m.y);
      isFinite(V) && (v[N(2875)](l)[N(580)](y.y)[N(1990)](_, -m.y)[N(580)](V), g[N(2875)](_)[N(580)](m.x)[N(1990)](l, -y.x).multiplyScalar(V), h[C][N(3026)](v), h[G][N(3026)](v), h[$][N(3026)](v), f[C][N(3026)](g), f[G][N(3026)](g), f[$][N(3026)](g));
    }
    let M = this.groups;
    M[e(3105)] === 0 && (M = [{ start: 0, count: i[e(3105)] }]);
    for (let C = 0, G = M[e(3105)]; C < G; ++C) {
      const $ = M[C], N = $[e(1917)], V = $[e(1267)];
      for (let X = N, n0 = N + V; X < n0; X += 3)
        b(i[X + 0], i[X + 1], i[X + 2]);
    }
    const A = new z(), L = new z(), P = new z(), S = new z();
    function I(C) {
      const G = e;
      P[G(666)](a, C * 3), S.copy(P);
      const $ = h[C];
      A[G(2875)]($), A[G(1943)](P[G(580)](P[G(1454)]($))).normalize(), L[G(956)](S, $);
      const N = L[G(1454)](f[C]), V = N < 0 ? -1 : 1;
      c[C * 4] = A.x, c[C * 4 + 1] = A.y, c[C * 4 + 2] = A.z, c[C * 4 + 3] = V;
    }
    for (let C = 0, G = M[e(3105)]; C < G; ++C) {
      const $ = M[C], N = $[e(1917)], V = $[e(1267)];
      for (let X = N, n0 = N + V; X < n0; X += 3)
        I(i[X + 0]), I(i[X + 1]), I(i[X + 2]);
    }
  }
  [s(3287)]() {
    const e = s, x = this.index, t = this.getAttribute("position");
    if (t !== void 0) {
      let i = this.getAttribute("normal");
      if (i === void 0)
        i = new gx(new Float32Array(t[e(1267)] * 3), 3), this[e(3599)]("normal", i);
      else
        for (let l = 0, _ = i[e(1267)]; l < _; l++)
          i[e(1167)](l, 0, 0, 0);
      const n = new z(), a = new z(), r = new z(), o = new z(), c = new z(), h = new z(), f = new z(), u = new z();
      if (x)
        for (let l = 0, _ = x.count; l < _; l += 3) {
          const p = x[e(781)](l + 0), m = x[e(781)](l + 1), y = x[e(781)](l + 2);
          n[e(804)](t, p), a.fromBufferAttribute(t, m), r[e(804)](t, y), f[e(1061)](r, a), u[e(1061)](n, a), f.cross(u), o[e(804)](i, p), c[e(804)](i, m), h[e(804)](i, y), o[e(3026)](f), c.add(f), h[e(3026)](f), i[e(1167)](p, o.x, o.y, o.z), i[e(1167)](m, c.x, c.y, c.z), i[e(1167)](y, h.x, h.y, h.z);
        }
      else
        for (let l = 0, _ = t[e(1267)]; l < _; l += 3)
          n[e(804)](t, l + 0), a[e(804)](t, l + 1), r[e(804)](t, l + 2), f.subVectors(r, a), u[e(1061)](n, a), f[e(1929)](u), i[e(1167)](l + 0, f.x, f.y, f.z), i.setXYZ(l + 1, f.x, f.y, f.z), i[e(1167)](l + 2, f.x, f.y, f.z);
      this[e(1730)](), i[e(3035)] = !![];
    }
  }
  [s(2462)]() {
    const e = s;
    return console[e(533)](e(3799)), this;
  }
  [s(1730)]() {
    const e = s, x = this[e(3265)][e(2111)];
    for (let t = 0, i = x[e(1267)]; t < i; t++)
      Yx.fromBufferAttribute(x, t), Yx.normalize(), x[e(1167)](t, Yx.x, Yx.y, Yx.z);
  }
  [s(1688)]() {
    const e = s;
    function x(o, c) {
      const h = c0, f = o[h(2712)], u = o.itemSize, l = o[h(3320)], _ = new f.constructor(c[h(3105)] * u);
      let p = 0, m = 0;
      for (let y = 0, v = c[h(3105)]; y < v; y++) {
        o.isInterleavedBufferAttribute ? p = c[y] * o[h(2416)].stride + o[h(592)] : p = c[y] * u;
        for (let g = 0; g < u; g++)
          _[m++] = f[p++];
      }
      return new gx(_, u, l);
    }
    if (this[e(3678)] === null)
      return console[e(3629)]("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const t = new ox(), i = this[e(3678)][e(2712)], n = this.attributes;
    for (const o in n) {
      const c = n[o], h = x(c, i);
      t[e(3599)](o, h);
    }
    const a = this[e(1034)];
    for (const o in a) {
      const c = [], h = a[o];
      for (let f = 0, u = h[e(3105)]; f < u; f++) {
        const l = h[f], _ = x(l, i);
        c[e(3156)](_);
      }
      t[e(1034)][o] = c;
    }
    t[e(3150)] = this[e(3150)];
    const r = this[e(2751)];
    for (let o = 0, c = r[e(3105)]; o < c; o++) {
      const h = r[o];
      t[e(3597)](h[e(1917)], h.count, h[e(2163)]);
    }
    return t;
  }
  toJSON() {
    const e = s, x = { metadata: { version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } };
    if (x[e(3104)] = this[e(3104)], x[e(566)] = this[e(566)], this[e(3710)] !== "" && (x[e(3710)] = this[e(3710)]), Object.keys(this[e(2066)])[e(3105)] > 0 && (x[e(2066)] = this.userData), this.parameters !== void 0) {
      const c = this[e(1063)];
      for (const h in c)
        c[h] !== void 0 && (x[h] = c[h]);
      return x;
    }
    x[e(2416)] = { attributes: {} };
    const t = this[e(3678)];
    t !== null && (x[e(2416)].index = { type: t.array[e(2787)][e(3710)], array: Array[e(2028)][e(3482)][e(1656)](t[e(2712)]) });
    const i = this[e(3265)];
    for (const c in i) {
      const h = i[c];
      x.data[e(3265)][c] = h[e(3139)](x[e(2416)]);
    }
    const n = {};
    let a = ![];
    for (const c in this[e(1034)]) {
      const h = this[e(1034)][c], f = [];
      for (let u = 0, l = h[e(3105)]; u < l; u++) {
        const _ = h[u];
        f.push(_[e(3139)](x[e(2416)]));
      }
      f[e(3105)] > 0 && (n[c] = f, a = !![]);
    }
    a && (x[e(2416)][e(1034)] = n, x[e(2416)][e(3150)] = this.morphTargetsRelative);
    const r = this[e(2751)];
    r[e(3105)] > 0 && (x[e(2416)][e(2751)] = JSON[e(1359)](JSON.stringify(r)));
    const o = this[e(3689)];
    return o !== null && (x[e(2416)][e(3689)] = { center: o.center[e(1496)](), radius: o[e(1232)] }), x;
  }
  clone() {
    const e = s;
    return new this[e(2787)]()[e(2875)](this);
  }
  [s(2875)](e) {
    const x = s;
    this[x(3678)] = null, this[x(3265)] = {}, this[x(1034)] = {}, this[x(2751)] = [], this[x(3151)] = null, this[x(3689)] = null;
    const t = {};
    this[x(3710)] = e[x(3710)];
    const i = e[x(3678)];
    i !== null && this[x(2203)](i.clone(t));
    const n = e[x(3265)];
    for (const h in n) {
      const f = n[h];
      this[x(3599)](h, f[x(2272)](t));
    }
    const a = e.morphAttributes;
    for (const h in a) {
      const f = [], u = a[h];
      for (let l = 0, _ = u.length; l < _; l++)
        f[x(3156)](u[l][x(2272)](t));
      this.morphAttributes[h] = f;
    }
    this.morphTargetsRelative = e[x(3150)];
    const r = e[x(2751)];
    for (let h = 0, f = r.length; h < f; h++) {
      const u = r[h];
      this[x(3597)](u[x(1917)], u[x(1267)], u.materialIndex);
    }
    const o = e.boundingBox;
    o !== null && (this[x(3151)] = o[x(2272)]());
    const c = e[x(3689)];
    return c !== null && (this[x(3689)] = c.clone()), this[x(2499)][x(1917)] = e[x(2499)][x(1917)], this[x(2499)][x(1267)] = e[x(2499)][x(1267)], this[x(2066)] = e[x(2066)], this;
  }
  [s(3387)]() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const mo = new ix(), Fe = new jn(), vs = new Pt(), go = new z(), hn = new z(), fn = new z(), ln = new z(), er = new z(), ys = new z(), ws = new d0(), Ms = new d0(), Ss = new d0(), tr = new z(), Ts = new z();
class Wx extends px {
  constructor(e = new ox(), x = new be()) {
    const t = s;
    super(), this.isMesh = !![], this[t(566)] = t(3191), this[t(1353)] = e, this[t(1870)] = x, this[t(697)]();
  }
  [s(2875)](e, x) {
    const t = s;
    return super[t(2875)](e, x), e[t(2072)] !== void 0 && (this[t(2072)] = e[t(2072)].slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e[t(3398)])), this.material = e[t(1870)], this[t(1353)] = e[t(1353)], this;
  }
  [s(697)]() {
    const e = s, x = this[e(1353)], t = x[e(1034)], i = Object.keys(t);
    if (i[e(3105)] > 0) {
      const n = t[i[0]];
      if (n !== void 0) {
        this[e(2072)] = [], this.morphTargetDictionary = {};
        for (let a = 0, r = n[e(3105)]; a < r; a++) {
          const o = n[a][e(3710)] || String(a);
          this[e(2072)][e(3156)](0), this[e(3398)][o] = a;
        }
      }
    }
  }
  [s(2616)](e, x) {
    const t = s, i = this[t(1353)], n = i[t(3265)][t(3571)], a = i[t(1034)][t(3571)], r = i[t(3150)];
    x[t(804)](n, e);
    const o = this[t(2072)];
    if (a && o) {
      ys[t(1260)](0, 0, 0);
      for (let c = 0, h = a[t(3105)]; c < h; c++) {
        const f = o[c], u = a[c];
        f !== 0 && (er[t(804)](u, e), r ? ys[t(1990)](er, f) : ys[t(1990)](er.sub(x), f));
      }
      x[t(3026)](ys);
    }
    return this[t(1918)] && this[t(1682)](e, x), x;
  }
  [s(2803)](e, x) {
    const t = s, i = this[t(1353)], n = this[t(1870)], a = this.matrixWorld;
    if (n === void 0 || (i[t(3689)] === null && i[t(2613)](), vs.copy(i.boundingSphere), vs[t(2442)](a), Fe.copy(e[t(1096)]).recast(e[t(1448)]), vs[t(3014)](Fe[t(1149)]) === ![] && (Fe[t(2722)](vs, go) === null || Fe[t(1149)][t(1679)](go) > (e[t(3691)] - e.near) ** 2)) || (mo[t(2875)](a)[t(1525)](), Fe[t(2875)](e.ray).applyMatrix4(mo), i[t(3151)] !== null && Fe.intersectsBox(i[t(3151)]) === ![]))
      return;
    let r;
    const o = i[t(3678)], c = i[t(3265)][t(3571)], h = i[t(3265)].uv, f = i.attributes.uv2, u = i.groups, l = i[t(2499)];
    if (o !== null)
      if (Array[t(1609)](n))
        for (let _ = 0, p = u[t(3105)]; _ < p; _++) {
          const m = u[_], y = n[m[t(2163)]], v = Math[t(1803)](m.start, l[t(1917)]), g = Math[t(3085)](o[t(1267)], Math[t(3085)](m[t(1917)] + m[t(1267)], l[t(1917)] + l[t(1267)]));
          for (let b = v, M = g; b < M; b += 3) {
            const A = o[t(781)](b), L = o[t(781)](b + 1), P = o.getX(b + 2);
            r = Es(this, y, e, Fe, h, f, A, L, P), r && (r[t(1176)] = Math[t(2697)](b / 3), r[t(3102)].materialIndex = m.materialIndex, x[t(3156)](r));
          }
        }
      else {
        const _ = Math.max(0, l[t(1917)]), p = Math[t(3085)](o[t(1267)], l.start + l[t(1267)]);
        for (let m = _, y = p; m < y; m += 3) {
          const v = o.getX(m), g = o[t(781)](m + 1), b = o[t(781)](m + 2);
          r = Es(this, n, e, Fe, h, f, v, g, b), r && (r[t(1176)] = Math[t(2697)](m / 3), x[t(3156)](r));
        }
      }
    else if (c !== void 0)
      if (Array[t(1609)](n))
        for (let _ = 0, p = u[t(3105)]; _ < p; _++) {
          const m = u[_], y = n[m[t(2163)]], v = Math.max(m[t(1917)], l[t(1917)]), g = Math.min(c.count, Math[t(3085)](m.start + m[t(1267)], l[t(1917)] + l[t(1267)]));
          for (let b = v, M = g; b < M; b += 3) {
            const A = b, L = b + 1, P = b + 2;
            r = Es(this, y, e, Fe, h, f, A, L, P), r && (r.faceIndex = Math[t(2697)](b / 3), r[t(3102)].materialIndex = m[t(2163)], x[t(3156)](r));
          }
        }
      else {
        const _ = Math.max(0, l[t(1917)]), p = Math.min(c[t(1267)], l[t(1917)] + l[t(1267)]);
        for (let m = _, y = p; m < y; m += 3) {
          const v = m, g = m + 1, b = m + 2;
          r = Es(this, n, e, Fe, h, f, v, g, b), r && (r[t(1176)] = Math[t(2697)](m / 3), x[t(3156)](r));
        }
      }
  }
}
function yl(d, e, x, t, i, n, a, r) {
  const o = s;
  let c;
  if (e[o(679)] === re ? c = t.intersectTriangle(a, n, i, !![], r) : c = t[o(1131)](i, n, a, e.side === Xe, r), c === null)
    return null;
  Ts[o(2875)](r), Ts[o(2442)](d[o(490)]);
  const h = x[o(1096)].origin[o(3570)](Ts);
  return h < x.near || h > x[o(3691)] ? null : { distance: h, point: Ts[o(2272)](), object: d };
}
function Es(d, e, x, t, i, n, a, r, o) {
  const c = s;
  d[c(2616)](a, hn), d[c(2616)](r, fn), d[c(2616)](o, ln);
  const h = yl(d, e, x, t, hn, fn, ln, tr);
  if (h) {
    i && (ws[c(804)](i, a), Ms[c(804)](i, r), Ss.fromBufferAttribute(i, o), h.uv = Ee[c(457)](tr, hn, fn, ln, ws, Ms, Ss, new d0())), n && (ws[c(804)](n, a), Ms[c(804)](n, r), Ss[c(804)](n, o), h[c(1166)] = Ee[c(457)](tr, hn, fn, ln, ws, Ms, Ss, new d0()));
    const f = { a, b: r, c: o, normal: new z(), materialIndex: 0 };
    Ee.getNormal(hn, fn, ln, f[c(2111)]), h[c(3102)] = f;
  }
  return h;
}
class It extends ox {
  constructor(e = 1, x = 1, t = 1, i = 1, n = 1, a = 1) {
    const r = s;
    super(), this.type = r(1372), this[r(1063)] = { width: e, height: x, depth: t, widthSegments: i, heightSegments: n, depthSegments: a };
    const o = this;
    i = Math[r(2697)](i), n = Math[r(2697)](n), a = Math[r(2697)](a);
    const c = [], h = [], f = [], u = [];
    let l = 0, _ = 0;
    p("z", "y", "x", -1, -1, t, x, e, a, n, 0), p("z", "y", "x", 1, -1, t, x, -e, a, n, 1), p("x", "z", "y", 1, 1, e, t, x, i, a, 2), p("x", "z", "y", 1, -1, e, t, -x, i, a, 3), p("x", "y", "z", 1, -1, e, x, t, i, n, 4), p("x", "y", "z", -1, -1, e, x, -t, i, n, 5), this[r(2203)](c), this[r(3599)]("position", new W0(h, 3)), this[r(3599)](r(2111), new W0(f, 3)), this[r(3599)]("uv", new W0(u, 2));
    function p(m, y, v, g, b, M, A, L, P, S, I) {
      const C = r, G = M / P, $ = A / S, N = M / 2, V = A / 2, X = L / 2, n0 = P + 1, b0 = S + 1;
      let Q = 0, r0 = 0;
      const l0 = new z();
      for (let v0 = 0; v0 < b0; v0++) {
        const s0 = v0 * $ - V;
        for (let q = 0; q < n0; q++) {
          const a0 = q * G - N;
          l0[m] = a0 * g, l0[y] = s0 * b, l0[v] = X, h[C(3156)](l0.x, l0.y, l0.z), l0[m] = 0, l0[y] = 0, l0[v] = L > 0 ? 1 : -1, f[C(3156)](l0.x, l0.y, l0.z), u[C(3156)](q / P), u.push(1 - v0 / S), Q += 1;
        }
      }
      for (let v0 = 0; v0 < S; v0++)
        for (let s0 = 0; s0 < P; s0++) {
          const q = l + s0 + n0 * v0, a0 = l + s0 + n0 * (v0 + 1), e0 = l + (s0 + 1) + n0 * (v0 + 1), p0 = l + (s0 + 1) + n0 * v0;
          c.push(q, a0, p0), c[C(3156)](a0, e0, p0), r0 += 6;
        }
      o[C(3597)](_, r0, I), _ += r0, l += Q;
    }
  }
  [s(2875)](e) {
    const x = s;
    return super[x(2875)](e), this.parameters = Object[x(1188)]({}, e[x(1063)]), this;
  }
  static fromJSON(e) {
    const x = s;
    return new It(e[x(1631)], e[x(1674)], e[x(3611)], e.widthSegments, e.heightSegments, e[x(579)]);
  }
}
function Vi(d) {
  const e = s, x = {};
  for (const t in d) {
    x[t] = {};
    for (const i in d[t]) {
      const n = d[t][i];
      n && (n[e(1035)] || n.isMatrix3 || n[e(3146)] || n[e(2134)] || n[e(3804)] || n[e(703)] || n[e(1714)] || n[e(3141)]) ? x[t][i] = n[e(2272)]() : Array[e(1609)](n) ? x[t][i] = n[e(3482)]() : x[t][i] = n;
    }
  }
  return x;
}
function se(d) {
  const e = s, x = {};
  for (let t = 0; t < d[e(3105)]; t++) {
    const i = Vi(d[t]);
    for (const n in i)
      x[n] = i[n];
  }
  return x;
}
function wl(d) {
  const e = s, x = [];
  for (let t = 0; t < d[e(3105)]; t++)
    x[e(3156)](d[t][e(2272)]());
  return x;
}
function Wd(d) {
  const e = s;
  return d[e(427)]() === null && d[e(3565)] === _x ? _e : ri;
}
const zn = { clone: Vi, merge: se };
var Ml = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, Sl = s(1156);
class ee extends jx {
  constructor(e) {
    const x = s;
    super(), this[x(2488)] = !![], this[x(566)] = x(2299), this[x(2264)] = {}, this[x(2833)] = {}, this[x(997)] = [], this[x(2377)] = Ml, this[x(2489)] = Sl, this[x(2968)] = 1, this.wireframe = ![], this[x(977)] = 1, this.fog = ![], this.lights = ![], this[x(1976)] = ![], this[x(3323)] = { derivatives: ![], fragDepth: ![], drawBuffers: ![], shaderTextureLOD: ![] }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }, this[x(1438)] = void 0, this.uniformsNeedUpdate = ![], this[x(3770)] = null, e !== void 0 && this[x(1104)](e);
  }
  [s(2875)](e) {
    const x = s;
    return super[x(2875)](e), this[x(2489)] = e.fragmentShader, this[x(2377)] = e[x(2377)], this.uniforms = Vi(e[x(2833)]), this.uniformsGroups = wl(e[x(997)]), this[x(2264)] = Object[x(1188)]({}, e[x(2264)]), this[x(1124)] = e[x(1124)], this[x(977)] = e.wireframeLinewidth, this.fog = e[x(3438)], this[x(3054)] = e[x(3054)], this[x(1976)] = e[x(1976)], this.extensions = Object[x(1188)]({}, e[x(3323)]), this.glslVersion = e.glslVersion, this;
  }
  [s(3139)](e) {
    const x = s, t = super[x(3139)](e);
    t[x(3770)] = this[x(3770)], t[x(2833)] = {};
    for (const n in this[x(2833)]) {
      const a = this[x(2833)][n], r = a[x(1811)];
      r && r.isTexture ? t[x(2833)][n] = { type: "t", value: r[x(3139)](e)[x(3104)] } : r && r[x(1035)] ? t.uniforms[n] = { type: "c", value: r[x(2862)]() } : r && r[x(2134)] ? t.uniforms[n] = { type: "v2", value: r[x(1496)]() } : r && r.isVector3 ? t[x(2833)][n] = { type: "v3", value: r.toArray() } : r && r[x(703)] ? t.uniforms[n] = { type: "v4", value: r[x(1496)]() } : r && r[x(3788)] ? t[x(2833)][n] = { type: "m3", value: r[x(1496)]() } : r && r.isMatrix4 ? t[x(2833)][n] = { type: "m4", value: r.toArray() } : t[x(2833)][n] = { value: r };
    }
    Object[x(2070)](this[x(2264)]).length > 0 && (t[x(2264)] = this[x(2264)]), t[x(2377)] = this.vertexShader, t[x(2489)] = this[x(2489)];
    const i = {};
    for (const n in this.extensions)
      this[x(3323)][n] === !![] && (i[n] = !![]);
    return Object[x(2070)](i)[x(3105)] > 0 && (t[x(3323)] = i), t;
  }
}
class wa extends px {
  constructor() {
    const e = s;
    super(), this[e(3256)] = !![], this[e(566)] = "Camera", this[e(1874)] = new ix(), this[e(1057)] = new ix(), this[e(583)] = new ix();
  }
  [s(2875)](e, x) {
    const t = s;
    return super[t(2875)](e, x), this[t(1874)].copy(e[t(1874)]), this.projectionMatrix[t(2875)](e[t(1057)]), this.projectionMatrixInverse.copy(e[t(583)]), this;
  }
  [s(2223)](e) {
    const x = s;
    this[x(630)](!![], ![]);
    const t = this[x(490)][x(717)];
    return e[x(1260)](-t[8], -t[9], -t[10])[x(608)]();
  }
  [s(3640)](e) {
    const x = s;
    super[x(3640)](e), this[x(1874)][x(2875)](this[x(490)]).invert();
  }
  updateWorldMatrix(e, x) {
    const t = s;
    super[t(630)](e, x), this[t(1874)][t(2875)](this[t(490)])[t(1525)]();
  }
  [s(2272)]() {
    const e = s;
    return new this.constructor()[e(2875)](this);
  }
}
class Vx extends wa {
  constructor(e = 50, x = 1, t = 0.1, i = 2e3) {
    const n = s;
    super(), this[n(2480)] = !![], this[n(566)] = "PerspectiveCamera", this[n(3557)] = e, this[n(2477)] = 1, this.near = t, this.far = i, this.focus = 10, this.aspect = x, this[n(1206)] = null, this[n(2417)] = 35, this[n(1690)] = 0, this[n(1701)]();
  }
  [s(2875)](e, x) {
    const t = s;
    return super[t(2875)](e, x), this[t(3557)] = e[t(3557)], this.zoom = e[t(2477)], this[t(1448)] = e[t(1448)], this.far = e[t(3691)], this[t(3594)] = e[t(3594)], this[t(2308)] = e.aspect, this[t(1206)] = e[t(1206)] === null ? null : Object.assign({}, e[t(1206)]), this[t(2417)] = e[t(2417)], this.filmOffset = e[t(1690)], this;
  }
  [s(3194)](e) {
    const x = s, t = 0.5 * this.getFilmHeight() / e;
    this[x(3557)] = Nn * 2 * Math.atan(t), this.updateProjectionMatrix();
  }
  getFocalLength() {
    const e = s, x = Math.tan(ii * 0.5 * this[e(3557)]);
    return 0.5 * this[e(2334)]() / x;
  }
  getEffectiveFOV() {
    const e = s;
    return Nn * 2 * Math[e(3041)](Math[e(745)](ii * 0.5 * this[e(3557)]) / this[e(2477)]);
  }
  [s(1551)]() {
    const e = s;
    return this[e(2417)] * Math[e(3085)](this[e(2308)], 1);
  }
  [s(2334)]() {
    const e = s;
    return this[e(2417)] / Math[e(1803)](this[e(2308)], 1);
  }
  [s(2174)](e, x, t, i, n, a) {
    const r = s;
    this[r(2308)] = e / x, this.view === null && (this[r(1206)] = { enabled: !![], fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this[r(1206)][r(2679)] = !![], this[r(1206)][r(2169)] = e, this[r(1206)][r(2096)] = x, this[r(1206)][r(2618)] = t, this[r(1206)][r(1948)] = i, this[r(1206)][r(1631)] = n, this.view[r(1674)] = a, this[r(1701)]();
  }
  [s(2309)]() {
    const e = s;
    this[e(1206)] !== null && (this[e(1206)][e(2679)] = ![]), this[e(1701)]();
  }
  [s(1701)]() {
    const e = s, x = this[e(1448)];
    let t = x * Math[e(745)](ii * 0.5 * this[e(3557)]) / this.zoom, i = 2 * t, n = this[e(2308)] * i, a = -0.5 * n;
    const r = this[e(1206)];
    if (this[e(1206)] !== null && this[e(1206)][e(2679)]) {
      const c = r[e(2169)], h = r[e(2096)];
      a += r[e(2618)] * n / c, t -= r[e(1948)] * i / h, n *= r[e(1631)] / c, i *= r.height / h;
    }
    const o = this[e(1690)];
    o !== 0 && (a += x * o / this.getFilmWidth()), this.projectionMatrix[e(1931)](a, a + n, t, t - i, x, this[e(3691)]), this[e(583)][e(2875)](this[e(1057)])[e(1525)]();
  }
  toJSON(e) {
    const x = s, t = super.toJSON(e);
    return t[x(1413)][x(3557)] = this[x(3557)], t.object[x(2477)] = this[x(2477)], t[x(1413)][x(1448)] = this[x(1448)], t[x(1413)][x(3691)] = this[x(3691)], t[x(1413)][x(3594)] = this.focus, t[x(1413)][x(2308)] = this.aspect, this[x(1206)] !== null && (t.object[x(1206)] = Object[x(1188)]({}, this[x(1206)])), t[x(1413)][x(2417)] = this[x(2417)], t[x(1413)][x(1690)] = this[x(1690)], t;
  }
}
const vi = -90, yi = 1;
class jd extends px {
  constructor(e, x, t) {
    const i = s;
    super(), this[i(566)] = i(3672), this[i(2394)] = t;
    const n = new Vx(vi, yi, e, x);
    n[i(479)] = this[i(479)], n.up[i(1260)](0, 1, 0), n[i(2577)](1, 0, 0), this[i(3026)](n);
    const a = new Vx(vi, yi, e, x);
    a[i(479)] = this[i(479)], a.up[i(1260)](0, 1, 0), a.lookAt(-1, 0, 0), this[i(3026)](a);
    const r = new Vx(vi, yi, e, x);
    r[i(479)] = this.layers, r.up[i(1260)](0, 0, -1), r.lookAt(0, 1, 0), this.add(r);
    const o = new Vx(vi, yi, e, x);
    o.layers = this.layers, o.up[i(1260)](0, 0, 1), o.lookAt(0, -1, 0), this[i(3026)](o);
    const c = new Vx(vi, yi, e, x);
    c[i(479)] = this[i(479)], c.up.set(0, 1, 0), c[i(2577)](0, 0, 1), this[i(3026)](c);
    const h = new Vx(vi, yi, e, x);
    h.layers = this[i(479)], h.up[i(1260)](0, 1, 0), h.lookAt(0, 0, -1), this[i(3026)](h);
  }
  [s(3452)](e, x) {
    const t = s;
    this[t(3562)] === null && this[t(3640)]();
    const i = this[t(2394)], [n, a, r, o, c, h] = this[t(3049)], f = e[t(427)](), u = e[t(602)], l = e.xr[t(2679)];
    e[t(602)] = We, e.xr.enabled = ![];
    const _ = i.texture[t(3632)];
    i[t(2431)][t(3632)] = ![], e[t(2969)](i, 0), e[t(489)](x, n), e.setRenderTarget(i, 1), e[t(489)](x, a), e[t(2969)](i, 2), e[t(489)](x, r), e[t(2969)](i, 3), e.render(x, o), e[t(2969)](i, 4), e[t(489)](x, c), i[t(2431)][t(3632)] = _, e[t(2969)](i, 5), e.render(x, h), e.setRenderTarget(f), e[t(602)] = u, e.xr[t(2679)] = l, i[t(2431)][t(1152)] = !![];
  }
}
class qn extends Ux {
  constructor(e, x, t, i, n, a, r, o, c, h) {
    const f = s;
    e = e !== void 0 ? e : [], x = x !== void 0 ? x : St, super(e, x, t, i, n, a, r, o, c, h), this[f(3038)] = !![], this[f(1739)] = ![];
  }
  get [s(1090)]() {
    return this[s(450)];
  }
  set images(e) {
    const x = s;
    this[x(450)] = e;
  }
}
class Xd extends oe {
  constructor(e = 1, x = {}) {
    const t = s;
    super(e, e, x), this[t(1676)] = !![];
    const i = { width: e, height: e, depth: 1 }, n = [i, i, i, i, i, i];
    this.texture = new qn(n, x[t(667)], x[t(578)], x[t(3221)], x[t(999)], x.minFilter, x.format, x[t(566)], x.anisotropy, x[t(523)]), this[t(2431)][t(546)] = !![], this[t(2431)][t(3632)] = x[t(3632)] !== void 0 ? x[t(3632)] : ![], this.texture[t(991)] = x[t(991)] !== void 0 ? x[t(991)] : Cx;
  }
  [s(1414)](e, x) {
    const t = s;
    this[t(2431)][t(566)] = x.type, this[t(2431)].encoding = x.encoding, this[t(2431)][t(3632)] = x[t(3632)], this.texture[t(991)] = x[t(991)], this[t(2431)][t(999)] = x.magFilter;
    const i = { uniforms: { tEquirect: { value: null } }, vertexShader: t(764), fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			` }, n = new It(5, 5, 5), a = new ee({ name: t(1858), uniforms: Vi(i[t(2833)]), vertexShader: i[t(2377)], fragmentShader: i[t(2489)], side: re, blending: Ve });
    a[t(2833)].tEquirect[t(1811)] = x;
    const r = new Wx(n, a), o = x[t(991)];
    return x[t(991)] === qe && (x[t(991)] = Cx), new jd(1, 10, this)[t(3452)](e, r), x.minFilter = o, r.geometry.dispose(), r.material[t(3387)](), this;
  }
  clear(e, x, t, i) {
    const n = s, a = e[n(427)]();
    for (let r = 0; r < 6; r++)
      e.setRenderTarget(this, r), e.clear(x, t, i);
    e[n(2969)](a);
  }
}
const ir = new z(), Tl = new z(), El = new Kx();
class mt {
  constructor(e = new z(1, 0, 0), x = 0) {
    const t = s;
    this[t(2261)] = !![], this[t(2111)] = e, this[t(2656)] = x;
  }
  set(e, x) {
    const t = s;
    return this[t(2111)][t(2875)](e), this.constant = x, this;
  }
  [s(2463)](e, x, t, i) {
    const n = s;
    return this[n(2111)][n(1260)](e, x, t), this[n(2656)] = i, this;
  }
  setFromNormalAndCoplanarPoint(e, x) {
    const t = s;
    return this[t(2111)][t(2875)](e), this[t(2656)] = -x[t(1454)](this[t(2111)]), this;
  }
  [s(1574)](e, x, t) {
    const i = s, n = ir[i(1061)](t, x)[i(1929)](Tl[i(1061)](e, x)).normalize();
    return this[i(1591)](n, e), this;
  }
  [s(2875)](e) {
    const x = s;
    return this[x(2111)][x(2875)](e[x(2111)]), this[x(2656)] = e[x(2656)], this;
  }
  [s(608)]() {
    const e = s, x = 1 / this[e(2111)][e(3105)]();
    return this[e(2111)][e(580)](x), this[e(2656)] *= x, this;
  }
  negate() {
    const e = s;
    return this[e(2656)] *= -1, this[e(2111)][e(3515)](), this;
  }
  [s(618)](e) {
    const x = s;
    return this[x(2111)].dot(e) + this[x(2656)];
  }
  [s(2170)](e) {
    const x = s;
    return this.distanceToPoint(e[x(551)]) - e[x(1232)];
  }
  [s(1297)](e, x) {
    const t = s;
    return x[t(2875)](e)[t(1990)](this[t(2111)], -this[t(618)](e));
  }
  [s(2681)](e, x) {
    const t = s, i = e[t(530)](ir), n = this.normal[t(1454)](i);
    if (n === 0)
      return this[t(618)](e[t(1917)]) === 0 ? x[t(2875)](e[t(1917)]) : null;
    const a = -(e[t(1917)][t(1454)](this[t(2111)]) + this[t(2656)]) / n;
    return a < 0 || a > 1 ? null : x[t(2875)](e[t(1917)]).addScaledVector(i, a);
  }
  [s(1151)](e) {
    const x = s, t = this[x(618)](e[x(1917)]), i = this[x(618)](e[x(1475)]);
    return t < 0 && i > 0 || i < 0 && t > 0;
  }
  [s(2549)](e) {
    return e.intersectsPlane(this);
  }
  [s(2935)](e) {
    return e.intersectsPlane(this);
  }
  [s(1411)](e) {
    const x = s;
    return e[x(2875)](this[x(2111)]).multiplyScalar(-this.constant);
  }
  [s(2442)](e, x) {
    const t = s, i = x || El[t(1424)](e), n = this.coplanarPoint(ir)[t(2442)](e), a = this[t(2111)][t(1904)](i)[t(608)]();
    return this[t(2656)] = -n[t(1454)](a), this;
  }
  [s(864)](e) {
    const x = s;
    return this.constant -= e.dot(this[x(2111)]), this;
  }
  [s(2828)](e) {
    const x = s;
    return e[x(2111)][x(2828)](this[x(2111)]) && e[x(2656)] === this[x(2656)];
  }
  [s(2272)]() {
    const e = s;
    return new this[e(2787)]()[e(2875)](this);
  }
}
const wi = new Pt(), As = new z();
class Ma {
  constructor(e = new mt(), x = new mt(), t = new mt(), i = new mt(), n = new mt(), a = new mt()) {
    const r = s;
    this[r(1747)] = [e, x, t, i, n, a];
  }
  [s(1260)](e, x, t, i, n, a) {
    const r = s, o = this[r(1747)];
    return o[0][r(2875)](e), o[1][r(2875)](x), o[2].copy(t), o[3].copy(i), o[4][r(2875)](n), o[5][r(2875)](a), this;
  }
  [s(2875)](e) {
    const x = s, t = this[x(1747)];
    for (let i = 0; i < 6; i++)
      t[i][x(2875)](e[x(1747)][i]);
    return this;
  }
  [s(894)](e) {
    const x = s, t = this[x(1747)], i = e[x(717)], n = i[0], a = i[1], r = i[2], o = i[3], c = i[4], h = i[5], f = i[6], u = i[7], l = i[8], _ = i[9], p = i[10], m = i[11], y = i[12], v = i[13], g = i[14], b = i[15];
    return t[0][x(2463)](o - n, u - c, m - l, b - y)[x(608)](), t[1][x(2463)](o + n, u + c, m + l, b + y)[x(608)](), t[2][x(2463)](o + a, u + h, m + _, b + v)[x(608)](), t[3][x(2463)](o - a, u - h, m - _, b - v)[x(608)](), t[4][x(2463)](o - r, u - f, m - p, b - g)[x(608)](), t[5][x(2463)](o + r, u + f, m + p, b + g)[x(608)](), this;
  }
  [s(1259)](e) {
    const x = s, t = e.geometry;
    return t[x(3689)] === null && t[x(2613)](), wi.copy(t[x(3689)])[x(2442)](e[x(490)]), this.intersectsSphere(wi);
  }
  [s(2568)](e) {
    const x = s;
    return wi[x(551)].set(0, 0, 0), wi[x(1232)] = 0.7071067811865476, wi.applyMatrix4(e[x(490)]), this[x(2935)](wi);
  }
  intersectsSphere(e) {
    const x = s, t = this[x(1747)], i = e[x(551)], n = -e[x(1232)];
    for (let a = 0; a < 6; a++)
      if (t[a][x(618)](i) < n)
        return ![];
    return !![];
  }
  intersectsBox(e) {
    const x = s, t = this.planes;
    for (let i = 0; i < 6; i++) {
      const n = t[i];
      if (As.x = n.normal.x > 0 ? e[x(1803)].x : e[x(3085)].x, As.y = n[x(2111)].y > 0 ? e[x(1803)].y : e.min.y, As.z = n[x(2111)].z > 0 ? e[x(1803)].z : e[x(3085)].z, n[x(618)](As) < 0)
        return ![];
    }
    return !![];
  }
  containsPoint(e) {
    const x = s, t = this[x(1747)];
    for (let i = 0; i < 6; i++)
      if (t[i][x(618)](e) < 0)
        return ![];
    return !![];
  }
  [s(2272)]() {
    const e = s;
    return new this[e(2787)]()[e(2875)](this);
  }
}
function qd() {
  let d = null, e = ![], x = null, t = null;
  function i(n, a) {
    const r = c0;
    x(n, a), t = d[r(1780)](i);
  }
  return { start: function() {
    const n = c0;
    e !== !![] && x !== null && (t = d[n(1780)](i), e = !![]);
  }, stop: function() {
    d[c0(2393)](t), e = ![];
  }, setAnimationLoop: function(n) {
    x = n;
  }, setContext: function(n) {
    d = n;
  } };
}
function Al(d, e) {
  const x = e.isWebGL2, t = /* @__PURE__ */ new WeakMap();
  function i(c, h) {
    const f = c0, u = c[f(2712)], l = c[f(3067)], _ = d.createBuffer();
    d[f(3224)](h, _), d[f(3513)](h, u, l), c[f(3773)]();
    let p;
    if (u instanceof Float32Array)
      p = 5126;
    else if (u instanceof Uint16Array)
      if (c[f(2741)])
        if (x)
          p = 5131;
        else
          throw new Error(f(1165));
      else
        p = 5123;
    else if (u instanceof Int16Array)
      p = 5122;
    else if (u instanceof Uint32Array)
      p = 5125;
    else if (u instanceof Int32Array)
      p = 5124;
    else if (u instanceof Int8Array)
      p = 5120;
    else if (u instanceof Uint8Array)
      p = 5121;
    else if (u instanceof Uint8ClampedArray)
      p = 5121;
    else
      throw new Error(f(1463) + u);
    return { buffer: _, type: p, bytesPerElement: u[f(2823)], version: c[f(2185)] };
  }
  function n(c, h, f) {
    const u = c0, l = h[u(2712)], _ = h.updateRange;
    d[u(3224)](f, c), _.count === -1 ? d[u(3107)](f, 0, l) : (x ? d[u(3107)](f, _[u(592)] * l[u(2823)], l, _[u(592)], _[u(1267)]) : d[u(3107)](f, _.offset * l.BYTES_PER_ELEMENT, l[u(1049)](_[u(592)], _.offset + _.count)), _.count = -1), h[u(3773)]();
  }
  function a(c) {
    const h = c0;
    return c[h(3154)] && (c = c[h(2416)]), t.get(c);
  }
  function r(c) {
    const h = c0;
    c[h(3154)] && (c = c[h(2416)]);
    const f = t[h(3016)](c);
    f && (d.deleteBuffer(f.buffer), t[h(2850)](c));
  }
  function o(c, h) {
    const f = c0;
    if (c[f(2025)]) {
      const l = t[f(3016)](c);
      (!l || l[f(2185)] < c[f(2185)]) && t[f(1260)](c, { buffer: c[f(2770)], type: c[f(566)], bytesPerElement: c[f(2873)], version: c[f(2185)] });
      return;
    }
    c[f(3154)] && (c = c[f(2416)]);
    const u = t.get(c);
    u === void 0 ? t[f(1260)](c, i(c, h)) : u[f(2185)] < c[f(2185)] && (n(u[f(2770)], c, h), u.version = c.version);
  }
  return { get: a, remove: r, update: o };
}
class $i extends ox {
  constructor(e = 1, x = 1, t = 1, i = 1) {
    const n = s;
    super(), this[n(566)] = n(3068), this[n(1063)] = { width: e, height: x, widthSegments: t, heightSegments: i };
    const a = e / 2, r = x / 2, o = Math[n(2697)](t), c = Math[n(2697)](i), h = o + 1, f = c + 1, u = e / o, l = x / c, _ = [], p = [], m = [], y = [];
    for (let v = 0; v < f; v++) {
      const g = v * l - r;
      for (let b = 0; b < h; b++) {
        const M = b * u - a;
        p[n(3156)](M, -g, 0), m[n(3156)](0, 0, 1), y.push(b / o), y[n(3156)](1 - v / c);
      }
    }
    for (let v = 0; v < c; v++)
      for (let g = 0; g < o; g++) {
        const b = g + h * v, M = g + h * (v + 1), A = g + 1 + h * (v + 1), L = g + 1 + h * v;
        _[n(3156)](b, M, L), _.push(M, A, L);
      }
    this[n(2203)](_), this[n(3599)](n(3571), new W0(p, 3)), this.setAttribute(n(2111), new W0(m, 3)), this.setAttribute("uv", new W0(y, 2));
  }
  [s(2875)](e) {
    const x = s;
    return super[x(2875)](e), this.parameters = Object[x(1188)]({}, e.parameters), this;
  }
  static fromJSON(e) {
    const x = s;
    return new $i(e[x(1631)], e[x(1674)], e[x(1715)], e[x(3563)]);
  }
}
var Cl = s(1935), Ll = s(1213), Rl = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`, Pl = s(823), Il = s(2210), Dl = s(1043), Ol = s(3500), Nl = s(3512), Ul = `vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
#ifdef USE_IRIDESCENCE
	vec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`, zl = s(3677), Bl = s(1071), Fl = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`, Gl = s(1530), Hl = s(2190), kl = s(1234), Vl = s(1248), Wl = s(2165), jl = s(3136), Xl = s(2336), ql = s(2799), Yl = s(1741), Zl = s(2635), Kl = s(3123), $l = s(2817), Jl = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, Ql = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, xu = s(2171), eu = `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`, tu = s(1894), iu = s(1495), nu = s(2829), su = s(3581), au = s(2099), ru = s(3084), ou = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, cu = s(2690), du = s(951), hu = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, fu = s(3058), lu = s(2517), uu = s(1769), bu = s(936), pu = s(2122), mu = s(3039), gu = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, _u = s(2912), vu = s(2343), yu = s(2853), wu = s(1349), Mu = s(762), Su = s(810), Tu = s(793), Eu = s(1511), Au = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, Cu = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, Lu = s(2457), Ru = s(1859), Pu = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, Iu = s(1400), Du = s(2647), Ou = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, Nu = s(2758), Uu = s(1185), zu = s(3696), Bu = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`, Fu = s(1246), Gu = s(928), Hu = s(534), ku = s(690), Vu = s(1499), Wu = s(1499), ju = s(3078), Xu = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`, qu = s(2288), Yu = s(2518), Zu = s(2711), Ku = s(2452), $u = s(1322), Ju = s(901), Qu = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, x9 = s(3308), e9 = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, t9 = s(1762), i9 = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`, n9 = s(3347), s9 = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`, a9 = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, r9 = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, o9 = s(3405), c9 = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, d9 = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`, h9 = s(1014), f9 = s(2090), l9 = s(2529), u9 = s(859), b9 = s(3700), p9 = s(1835), m9 = s(2222), g9 = s(3602), _9 = `#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`, v9 = s(3212), y9 = s(2503), w9 = s(3589), M9 = s(3138), S9 = s(3293), T9 = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const E9 = s(2725), A9 = s(1880), C9 = s(3165), L9 = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, R9 = s(3165), P9 = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, I9 = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, D9 = s(2718), O9 = s(1940), N9 = s(2443), U9 = s(3538), z9 = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, B9 = s(885), F9 = s(3362), G9 = s(2036), H9 = s(1064), k9 = s(3351), V9 = s(2747), W9 = s(835), j9 = s(851), X9 = s(1878), q9 = s(3269), Y9 = s(1252), Z9 = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, K9 = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, $9 = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, J9 = s(3033), Q9 = s(3075), xb = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, eb = s(1473), tb = s(429), ib = s(2551), nb = s(1572), sb = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`, dx = { alphamap_fragment: Cl, alphamap_pars_fragment: Ll, alphatest_fragment: Rl, alphatest_pars_fragment: Pl, aomap_fragment: Il, aomap_pars_fragment: Dl, begin_vertex: Ol, beginnormal_vertex: Nl, bsdfs: Ul, iridescence_fragment: zl, bumpmap_pars_fragment: Bl, clipping_planes_fragment: Fl, clipping_planes_pars_fragment: Gl, clipping_planes_pars_vertex: Hl, clipping_planes_vertex: kl, color_fragment: Vl, color_pars_fragment: Wl, color_pars_vertex: jl, color_vertex: Xl, common: ql, cube_uv_reflection_fragment: Yl, defaultnormal_vertex: Zl, displacementmap_pars_vertex: Kl, displacementmap_vertex: $l, emissivemap_fragment: Jl, emissivemap_pars_fragment: Ql, encodings_fragment: xu, encodings_pars_fragment: eu, envmap_fragment: tu, envmap_common_pars_fragment: iu, envmap_pars_fragment: nu, envmap_pars_vertex: su, envmap_physical_pars_fragment: mu, envmap_vertex: au, fog_vertex: ru, fog_pars_vertex: ou, fog_fragment: cu, fog_pars_fragment: du, gradientmap_pars_fragment: hu, lightmap_fragment: fu, lightmap_pars_fragment: lu, lights_lambert_fragment: uu, lights_lambert_pars_fragment: bu, lights_pars_begin: pu, lights_toon_fragment: gu, lights_toon_pars_fragment: _u, lights_phong_fragment: vu, lights_phong_pars_fragment: yu, lights_physical_fragment: wu, lights_physical_pars_fragment: Mu, lights_fragment_begin: Su, lights_fragment_maps: Tu, lights_fragment_end: Eu, logdepthbuf_fragment: Au, logdepthbuf_pars_fragment: Cu, logdepthbuf_pars_vertex: Lu, logdepthbuf_vertex: Ru, map_fragment: Pu, map_pars_fragment: Iu, map_particle_fragment: Du, map_particle_pars_fragment: Ou, metalnessmap_fragment: Nu, metalnessmap_pars_fragment: Uu, morphcolor_vertex: zu, morphnormal_vertex: Bu, morphtarget_pars_vertex: Fu, morphtarget_vertex: Gu, normal_fragment_begin: Hu, normal_fragment_maps: ku, normal_pars_fragment: Vu, normal_pars_vertex: Wu, normal_vertex: ju, normalmap_pars_fragment: Xu, clearcoat_normal_fragment_begin: qu, clearcoat_normal_fragment_maps: Yu, clearcoat_pars_fragment: Zu, iridescence_pars_fragment: Ku, output_fragment: $u, packing: Ju, premultiplied_alpha_fragment: Qu, project_vertex: x9, dithering_fragment: e9, dithering_pars_fragment: t9, roughnessmap_fragment: i9, roughnessmap_pars_fragment: n9, shadowmap_pars_fragment: s9, shadowmap_pars_vertex: a9, shadowmap_vertex: r9, shadowmask_pars_fragment: o9, skinbase_vertex: c9, skinning_pars_vertex: d9, skinning_vertex: h9, skinnormal_vertex: f9, specularmap_fragment: l9, specularmap_pars_fragment: u9, tonemapping_fragment: b9, tonemapping_pars_fragment: p9, transmission_fragment: m9, transmission_pars_fragment: g9, uv_pars_fragment: _9, uv_pars_vertex: v9, uv_vertex: y9, uv2_pars_fragment: w9, uv2_pars_vertex: M9, uv2_vertex: S9, worldpos_vertex: T9, background_vert: E9, background_frag: A9, backgroundCube_vert: C9, backgroundCube_frag: L9, cube_vert: R9, cube_frag: P9, depth_vert: I9, depth_frag: D9, distanceRGBA_vert: O9, distanceRGBA_frag: N9, equirect_vert: U9, equirect_frag: z9, linedashed_vert: B9, linedashed_frag: F9, meshbasic_vert: G9, meshbasic_frag: H9, meshlambert_vert: k9, meshlambert_frag: V9, meshmatcap_vert: W9, meshmatcap_frag: j9, meshnormal_vert: X9, meshnormal_frag: q9, meshphong_vert: Y9, meshphong_frag: Z9, meshphysical_vert: K9, meshphysical_frag: $9, meshtoon_vert: J9, meshtoon_frag: Q9, points_vert: xb, points_frag: eb, shadow_vert: tb, shadow_frag: ib, sprite_vert: nb, sprite_frag: sb }, I0 = { common: { diffuse: { value: new P0(16777215) }, opacity: { value: 1 }, map: { value: null }, uvTransform: { value: new Kx() }, uv2Transform: { value: new Kx() }, alphaMap: { value: null }, alphaTest: { value: 0 } }, specularmap: { specularMap: { value: null } }, envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, ior: { value: 1.5 }, refractionRatio: { value: 0.98 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } }, emissivemap: { emissiveMap: { value: null } }, bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalScale: { value: new d0(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, roughnessmap: { roughnessMap: { value: null } }, metalnessmap: { metalnessMap: { value: null } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new P0(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotLightMap: { value: [] }, spotShadowMap: { value: [] }, spotLightMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }, ltc_1: { value: null }, ltc_2: { value: null } }, points: { diffuse: { value: new P0(16777215) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, alphaTest: { value: 0 }, uvTransform: { value: new Kx() } }, sprite: { diffuse: { value: new P0(16777215) }, opacity: { value: 1 }, center: { value: new d0(0.5, 0.5) }, rotation: { value: 0 }, map: { value: null }, alphaMap: { value: null }, alphaTest: { value: 0 }, uvTransform: { value: new Kx() } } }, De = { basic: { uniforms: se([I0[s(3483)], I0[s(3692)], I0[s(961)], I0.aomap, I0[s(1172)], I0.fog]), vertexShader: dx[s(2136)], fragmentShader: dx.meshbasic_frag }, lambert: { uniforms: se([I0.common, I0.specularmap, I0.envmap, I0[s(3511)], I0[s(1172)], I0[s(2277)], I0[s(738)], I0[s(2371)], I0[s(3386)], I0[s(3438)], I0[s(3054)], { emissive: { value: new P0(0) } }]), vertexShader: dx.meshlambert_vert, fragmentShader: dx[s(1925)] }, phong: { uniforms: se([I0[s(3483)], I0.specularmap, I0.envmap, I0[s(3511)], I0[s(1172)], I0.emissivemap, I0[s(738)], I0.normalmap, I0[s(3386)], I0[s(3438)], I0[s(3054)], { emissive: { value: new P0(0) }, specular: { value: new P0(1118481) }, shininess: { value: 30 } }]), vertexShader: dx[s(1329)], fragmentShader: dx[s(2928)] }, standard: { uniforms: se([I0[s(3483)], I0[s(961)], I0[s(3511)], I0.lightmap, I0.emissivemap, I0[s(738)], I0.normalmap, I0[s(3386)], I0[s(1458)], I0[s(892)], I0[s(3438)], I0[s(3054)], { emissive: { value: new P0(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: dx[s(2994)], fragmentShader: dx[s(2524)] }, toon: { uniforms: se([I0[s(3483)], I0[s(3511)], I0[s(1172)], I0[s(2277)], I0[s(738)], I0[s(2371)], I0[s(3386)], I0.gradientmap, I0[s(3438)], I0[s(3054)], { emissive: { value: new P0(0) } }]), vertexShader: dx[s(2057)], fragmentShader: dx[s(3420)] }, matcap: { uniforms: se([I0[s(3483)], I0[s(738)], I0.normalmap, I0[s(3386)], I0.fog, { matcap: { value: null } }]), vertexShader: dx[s(1953)], fragmentShader: dx[s(2358)] }, points: { uniforms: se([I0[s(1197)], I0[s(3438)]]), vertexShader: dx[s(458)], fragmentShader: dx[s(1667)] }, dashed: { uniforms: se([I0.common, I0[s(3438)], { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: dx[s(1284)], fragmentShader: dx[s(2860)] }, depth: { uniforms: se([I0[s(3483)], I0[s(3386)]]), vertexShader: dx[s(3765)], fragmentShader: dx[s(560)] }, normal: { uniforms: se([I0.common, I0[s(738)], I0[s(2371)], I0[s(3386)], { opacity: { value: 1 } }]), vertexShader: dx[s(2209)], fragmentShader: dx.meshnormal_frag }, sprite: { uniforms: se([I0[s(983)], I0[s(3438)]]), vertexShader: dx[s(933)], fragmentShader: dx[s(2992)] }, background: { uniforms: { uvTransform: { value: new Kx() }, t2D: { value: null }, backgroundIntensity: { value: 1 } }, vertexShader: dx[s(1573)], fragmentShader: dx[s(2383)] }, backgroundCube: { uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 }, backgroundBlurriness: { value: 0 }, backgroundIntensity: { value: 1 } }, vertexShader: dx[s(2175)], fragmentShader: dx[s(3789)] }, cube: { uniforms: { tCube: { value: null }, tFlip: { value: -1 }, opacity: { value: 1 } }, vertexShader: dx.cube_vert, fragmentShader: dx[s(2359)] }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: dx[s(2395)], fragmentShader: dx[s(3477)] }, distanceRGBA: { uniforms: se([I0[s(3483)], I0.displacementmap, { referencePosition: { value: new z() }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: dx[s(2372)], fragmentShader: dx[s(1571)] }, shadow: { uniforms: se([I0.lights, I0[s(3438)], { color: { value: new P0(0) }, opacity: { value: 1 } }]), vertexShader: dx[s(3489)], fragmentShader: dx[s(3278)] } };
De[s(802)] = { uniforms: se([De[s(1589)][s(2833)], { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatNormalScale: { value: new d0(1, 1) }, clearcoatNormalMap: { value: null }, iridescence: { value: 0 }, iridescenceMap: { value: null }, iridescenceIOR: { value: 1.3 }, iridescenceThicknessMinimum: { value: 100 }, iridescenceThicknessMaximum: { value: 400 }, iridescenceThicknessMap: { value: null }, sheen: { value: 0 }, sheenColor: { value: new P0(0) }, sheenColorMap: { value: null }, sheenRoughness: { value: 1 }, sheenRoughnessMap: { value: null }, transmission: { value: 0 }, transmissionMap: { value: null }, transmissionSamplerSize: { value: new d0() }, transmissionSamplerMap: { value: null }, thickness: { value: 0 }, thicknessMap: { value: null }, attenuationDistance: { value: 0 }, attenuationColor: { value: new P0(0) }, specularIntensity: { value: 1 }, specularIntensityMap: { value: null }, specularColor: { value: new P0(1, 1, 1) }, specularColorMap: { value: null } }]), vertexShader: dx[s(2994)], fragmentShader: dx[s(2524)] };
const Cs = { r: 0, b: 0, g: 0 };
function ab(d, e, x, t, i, n, a) {
  const r = new P0(0);
  let o = n === !![] ? 0 : 1, c, h, f = null, u = 0, l = null;
  function _(m, y) {
    const v = c0;
    let g = ![], b = y[v(1444)] === !![] ? y[v(2525)] : null;
    b && b.isTexture && (b = (y[v(2812)] > 0 ? x : e)[v(3016)](b));
    const M = d.xr, A = M[v(1912)] && M.getSession();
    A && A[v(2403)] === v(2191) && (b = null), b === null ? p(r, o) : b && b[v(1035)] && (p(b, 1), g = !![]), (d[v(1363)] || g) && d.clear(d[v(2e3)], d[v(3201)], d[v(2904)]), b && (b.isCubeTexture || b.mapping === Ki) ? (h === void 0 && (h = new Wx(new It(1, 1, 1), new ee({ name: "BackgroundCubeMaterial", uniforms: Vi(De[v(2855)][v(2833)]), vertexShader: De.backgroundCube[v(2377)], fragmentShader: De[v(2855)].fragmentShader, side: re, depthTest: ![], depthWrite: ![], fog: ![] })), h.geometry.deleteAttribute("normal"), h[v(1353)][v(1951)]("uv"), h.onBeforeRender = function(L, P, S) {
      const I = v;
      this[I(490)][I(689)](S[I(490)]);
    }, Object[v(1117)](h[v(1870)], "envMap", { get: function() {
      const L = v;
      return this[L(2833)][L(1477)][L(1811)];
    } }), i.update(h)), h[v(1870)][v(2833)].envMap[v(1811)] = b, h[v(1870)][v(2833)][v(3234)][v(1811)] = b[v(3038)] && b.isRenderTargetTexture === ![] ? -1 : 1, h.material[v(2833)][v(2812)].value = y[v(2812)], h[v(1870)][v(2833)].backgroundIntensity[v(1811)] = y[v(2217)], h[v(1870)][v(626)] = b[v(523)] === _x ? ![] : !![], (f !== b || u !== b[v(2185)] || l !== d[v(602)]) && (h[v(1870)][v(3035)] = !![], f = b, u = b.version, l = d[v(602)]), h[v(479)][v(960)](), m[v(2248)](h, h[v(1353)], h.material, 0, 0, null)) : b && b[v(1714)] && (c === void 0 && (c = new Wx(new $i(2, 2), new ee({ name: v(1590), uniforms: Vi(De[v(2525)][v(2833)]), vertexShader: De[v(2525)][v(2377)], fragmentShader: De[v(2525)][v(2489)], side: Xe, depthTest: ![], depthWrite: ![], fog: ![] })), c[v(1353)][v(1951)](v(2111)), Object.defineProperty(c[v(1870)], v(3644), { get: function() {
      const L = v;
      return this[L(2833)].t2D[L(1811)];
    } }), i[v(3452)](c)), c[v(1870)][v(2833)].t2D[v(1811)] = b, c[v(1870)].uniforms.backgroundIntensity.value = y[v(2217)], c[v(1870)][v(626)] = b[v(523)] === _x ? ![] : !![], b[v(1126)] === !![] && b[v(1290)](), c[v(1870)][v(2833)][v(1275)].value[v(2875)](b[v(1067)]), (f !== b || u !== b[v(2185)] || l !== d[v(602)]) && (c[v(1870)][v(3035)] = !![], f = b, u = b[v(2185)], l = d[v(602)]), c[v(479)][v(960)](), m.unshift(c, c[v(1353)], c.material, 0, 0, null));
  }
  function p(m, y) {
    const v = c0;
    m[v(2657)](Cs, Wd(d)), t[v(2563)][v(3282)][v(2139)](Cs.r, Cs.g, Cs.b, y, a);
  }
  return { getClearColor: function() {
    return r;
  }, setClearColor: function(m, y = 1) {
    r[c0(1260)](m), o = y, p(r, o);
  }, getClearAlpha: function() {
    return o;
  }, setClearAlpha: function(m) {
    o = m, p(r, o);
  }, render: _ };
}
function rb(d, e, x, t) {
  const i = s, n = d[i(3516)](34921), a = t[i(510)] ? null : e[i(3016)](i(637)), r = t[i(510)] || a !== null, o = {}, c = y(null);
  let h = c, f = ![];
  function u(V, X, n0, b0, Q) {
    const r0 = i;
    let l0 = ![];
    if (r) {
      const v0 = m(b0, n0, X);
      h !== v0 && (h = v0, _(h[r0(1413)])), l0 = v(V, b0, n0, Q), l0 && g(V, b0, n0, Q);
    } else {
      const v0 = X.wireframe === !![];
      (h[r0(1353)] !== b0.id || h[r0(2302)] !== n0.id || h[r0(1124)] !== v0) && (h[r0(1353)] = b0.id, h[r0(2302)] = n0.id, h[r0(1124)] = v0, l0 = !![]);
    }
    Q !== null && x[r0(3452)](Q, 34963), (l0 || f) && (f = ![], S(V, X, n0, b0), Q !== null && d.bindBuffer(34963, x.get(Q)[r0(2770)]));
  }
  function l() {
    const V = i;
    return t[V(510)] ? d.createVertexArray() : a[V(1877)]();
  }
  function _(V) {
    const X = i;
    return t[X(510)] ? d[X(2475)](V) : a[X(2775)](V);
  }
  function p(V) {
    const X = i;
    return t.isWebGL2 ? d[X(3776)](V) : a[X(2470)](V);
  }
  function m(V, X, n0) {
    const b0 = i, Q = n0[b0(1124)] === !![];
    let r0 = o[V.id];
    r0 === void 0 && (r0 = {}, o[V.id] = r0);
    let l0 = r0[X.id];
    l0 === void 0 && (l0 = {}, r0[X.id] = l0);
    let v0 = l0[Q];
    return v0 === void 0 && (v0 = y(l()), l0[Q] = v0), v0;
  }
  function y(V) {
    const X = [], n0 = [], b0 = [];
    for (let Q = 0; Q < n; Q++)
      X[Q] = 0, n0[Q] = 0, b0[Q] = 0;
    return { geometry: null, program: null, wireframe: ![], newAttributes: X, enabledAttributes: n0, attributeDivisors: b0, object: V, attributes: {}, index: null };
  }
  function v(V, X, n0, b0) {
    const Q = i, r0 = h[Q(3265)], l0 = X.attributes;
    let v0 = 0;
    const s0 = n0[Q(2298)]();
    for (const q in s0)
      if (s0[q][Q(2494)] >= 0) {
        const e0 = r0[q];
        let p0 = l0[q];
        if (p0 === void 0 && (q === Q(1312) && V[Q(1312)] && (p0 = V[Q(1312)]), q === Q(752) && V.instanceColor && (p0 = V[Q(752)])), e0 === void 0)
          return !![];
        if (e0[Q(1134)] !== p0)
          return !![];
        if (p0 && e0[Q(2416)] !== p0[Q(2416)])
          return !![];
        v0++;
      }
    return h[Q(995)] !== v0 ? !![] : h[Q(3678)] !== b0 ? !![] : ![];
  }
  function g(V, X, n0, b0) {
    const Q = i, r0 = {}, l0 = X[Q(3265)];
    let v0 = 0;
    const s0 = n0[Q(2298)]();
    for (const q in s0)
      if (s0[q][Q(2494)] >= 0) {
        let e0 = l0[q];
        e0 === void 0 && (q === Q(1312) && V.instanceMatrix && (e0 = V[Q(1312)]), q === Q(752) && V.instanceColor && (e0 = V[Q(752)]));
        const p0 = {};
        p0[Q(1134)] = e0, e0 && e0[Q(2416)] && (p0[Q(2416)] = e0[Q(2416)]), r0[q] = p0, v0++;
      }
    h[Q(3265)] = r0, h[Q(995)] = v0, h[Q(3678)] = b0;
  }
  function b() {
    const V = i, X = h.newAttributes;
    for (let n0 = 0, b0 = X[V(3105)]; n0 < b0; n0++)
      X[n0] = 0;
  }
  function M(V) {
    A(V, 0);
  }
  function A(V, X) {
    const n0 = i, b0 = h[n0(1641)], Q = h[n0(952)], r0 = h[n0(2982)];
    b0[V] = 1, Q[V] === 0 && (d[n0(3787)](V), Q[V] = 1), r0[V] !== X && ((t[n0(510)] ? d : e[n0(3016)](n0(425)))[t.isWebGL2 ? n0(441) : "vertexAttribDivisorANGLE"](V, X), r0[V] = X);
  }
  function L() {
    const V = i, X = h[V(1641)], n0 = h[V(952)];
    for (let b0 = 0, Q = n0[V(3105)]; b0 < Q; b0++)
      n0[b0] !== X[b0] && (d.disableVertexAttribArray(b0), n0[b0] = 0);
  }
  function P(V, X, n0, b0, Q, r0) {
    const l0 = i;
    t[l0(510)] === !![] && (n0 === 5124 || n0 === 5125) ? d.vertexAttribIPointer(V, X, n0, Q, r0) : d[l0(2595)](V, X, n0, b0, Q, r0);
  }
  function S(V, X, n0, b0) {
    const Q = i;
    if (t.isWebGL2 === ![] && (V[Q(2342)] || b0[Q(548)]) && e[Q(3016)]("ANGLE_instanced_arrays") === null)
      return;
    b();
    const r0 = b0[Q(3265)], l0 = n0[Q(2298)](), v0 = X[Q(3240)];
    for (const s0 in l0) {
      const q = l0[s0];
      if (q[Q(2494)] >= 0) {
        let a0 = r0[s0];
        if (a0 === void 0 && (s0 === Q(1312) && V[Q(1312)] && (a0 = V.instanceMatrix), s0 === Q(752) && V[Q(752)] && (a0 = V[Q(752)])), a0 !== void 0) {
          const e0 = a0[Q(3320)], p0 = a0[Q(3290)], y0 = x[Q(3016)](a0);
          if (y0 === void 0)
            continue;
          const L0 = y0[Q(2770)], k0 = y0[Q(566)], Q0 = y0[Q(2720)];
          if (a0.isInterleavedBufferAttribute) {
            const U0 = a0[Q(2416)], xx = U0[Q(2479)], _0 = a0[Q(592)];
            if (U0[Q(886)]) {
              for (let E0 = 0; E0 < q.locationSize; E0++)
                A(q[Q(2494)] + E0, U0[Q(656)]);
              V.isInstancedMesh !== !![] && b0._maxInstanceCount === void 0 && (b0[Q(2562)] = U0[Q(656)] * U0[Q(1267)]);
            } else
              for (let E0 = 0; E0 < q[Q(774)]; E0++)
                M(q[Q(2494)] + E0);
            d[Q(3224)](34962, L0);
            for (let E0 = 0; E0 < q[Q(774)]; E0++)
              P(q[Q(2494)] + E0, p0 / q[Q(774)], k0, e0, xx * Q0, (_0 + p0 / q[Q(774)] * E0) * Q0);
          } else {
            if (a0[Q(1242)]) {
              for (let U0 = 0; U0 < q.locationSize; U0++)
                A(q[Q(2494)] + U0, a0[Q(656)]);
              V[Q(2342)] !== !![] && b0._maxInstanceCount === void 0 && (b0[Q(2562)] = a0.meshPerAttribute * a0[Q(1267)]);
            } else
              for (let U0 = 0; U0 < q[Q(774)]; U0++)
                M(q[Q(2494)] + U0);
            d.bindBuffer(34962, L0);
            for (let U0 = 0; U0 < q[Q(774)]; U0++)
              P(q[Q(2494)] + U0, p0 / q.locationSize, k0, e0, p0 * Q0, p0 / q[Q(774)] * U0 * Q0);
          }
        } else if (v0 !== void 0) {
          const e0 = v0[s0];
          if (e0 !== void 0)
            switch (e0.length) {
              case 2:
                d[Q(2552)](q[Q(2494)], e0);
                break;
              case 3:
                d[Q(2710)](q[Q(2494)], e0);
                break;
              case 4:
                d.vertexAttrib4fv(q.location, e0);
                break;
              default:
                d.vertexAttrib1fv(q[Q(2494)], e0);
            }
        }
      }
    }
    L();
  }
  function I() {
    $();
    for (const V in o) {
      const X = o[V];
      for (const n0 in X) {
        const b0 = X[n0];
        for (const Q in b0)
          p(b0[Q].object), delete b0[Q];
        delete X[n0];
      }
      delete o[V];
    }
  }
  function C(V) {
    const X = i;
    if (o[V.id] === void 0)
      return;
    const n0 = o[V.id];
    for (const b0 in n0) {
      const Q = n0[b0];
      for (const r0 in Q)
        p(Q[r0][X(1413)]), delete Q[r0];
      delete n0[b0];
    }
    delete o[V.id];
  }
  function G(V) {
    const X = i;
    for (const n0 in o) {
      const b0 = o[n0];
      if (b0[V.id] === void 0)
        continue;
      const Q = b0[V.id];
      for (const r0 in Q)
        p(Q[r0][X(1413)]), delete Q[r0];
      delete b0[V.id];
    }
  }
  function $() {
    const V = i;
    N(), f = !![], h !== c && (h = c, _(h[V(1413)]));
  }
  function N() {
    const V = i;
    c.geometry = null, c[V(2302)] = null, c[V(1124)] = ![];
  }
  return { setup: u, reset: $, resetDefaultState: N, dispose: I, releaseStatesOfGeometry: C, releaseStatesOfProgram: G, initAttributes: b, enableAttribute: M, disableUnusedAttributes: L };
}
function ob(d, e, x, t) {
  const i = s, n = t[i(510)];
  let a;
  function r(h) {
    a = h;
  }
  function o(h, f) {
    d[i(2091)](a, h, f), x.update(f, a, 1);
  }
  function c(h, f, u) {
    const l = i;
    if (u === 0)
      return;
    let _, p;
    if (n)
      _ = d, p = l(2677);
    else if (_ = e[l(3016)](l(425)), p = l(2750), _ === null) {
      console.error(l(3369));
      return;
    }
    _[p](a, h, f, u), x[l(3452)](f, a, u);
  }
  this[i(2392)] = r, this.render = o, this[i(2347)] = c;
}
function cb(d, e, x) {
  const t = s;
  let i;
  function n() {
    const P = c0;
    if (i !== void 0)
      return i;
    if (e[P(2086)](P(1869)) === !![]) {
      const S = e[P(3016)](P(1869));
      i = d.getParameter(S.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else
      i = 0;
    return i;
  }
  function a(P) {
    const S = c0;
    if (P === S(994)) {
      if (d[S(3077)](35633, 36338)[S(537)] > 0 && d.getShaderPrecisionFormat(35632, 36338)[S(537)] > 0)
        return S(994);
      P = S(2293);
    }
    return P === "mediump" && d[S(3077)](35633, 36337)[S(537)] > 0 && d.getShaderPrecisionFormat(35632, 36337)[S(537)] > 0 ? "mediump" : "lowp";
  }
  const r = typeof WebGL2RenderingContext !== t(2011) && d instanceof WebGL2RenderingContext;
  let o = x[t(537)] !== void 0 ? x[t(537)] : "highp";
  const c = a(o);
  c !== o && (console.warn(t(1629), o, t(587), c, t(3295)), o = c);
  const h = r || e.has(t(2492)), f = x[t(428)] === !![], u = d[t(3516)](34930), l = d[t(3516)](35660), _ = d[t(3516)](3379), p = d[t(3516)](34076), m = d[t(3516)](34921), y = d[t(3516)](36347), v = d[t(3516)](36348), g = d[t(3516)](36349), b = l > 0, M = r || e.has(t(3027)), A = b && M, L = r ? d[t(3516)](36183) : 0;
  return { isWebGL2: r, drawBuffers: h, getMaxAnisotropy: n, getMaxPrecision: a, precision: o, logarithmicDepthBuffer: f, maxTextures: u, maxVertexTextures: l, maxTextureSize: _, maxCubemapSize: p, maxAttributes: m, maxVertexUniforms: y, maxVaryings: v, maxFragmentUniforms: g, vertexTextures: b, floatFragmentTextures: M, floatVertexTextures: A, maxSamples: L };
}
function db(d) {
  const e = s, x = this;
  let t = null, i = 0, n = ![], a = ![];
  const r = new mt(), o = new Kx(), c = { value: null, needsUpdate: ![] };
  this[e(3080)] = c, this[e(1336)] = 0, this.numIntersection = 0, this[e(2156)] = function(u, l) {
    const _ = e, p = u[_(3105)] !== 0 || l || i !== 0 || n;
    return n = l, i = u[_(3105)], p;
  }, this[e(2846)] = function() {
    a = !![], f(null);
  }, this[e(1616)] = function() {
    a = ![];
  }, this[e(3274)] = function(u, l) {
    t = f(u, l, 0);
  }, this[e(1520)] = function(u, l, _) {
    const p = e, m = u.clippingPlanes, y = u.clipIntersection, v = u[p(1467)], g = d.get(u);
    if (!n || m === null || m[p(3105)] === 0 || a && !v)
      a ? f(null) : h();
    else {
      const b = a ? 0 : i, M = b * 4;
      let A = g[p(535)] || null;
      c.value = A, A = f(m, l, M, _);
      for (let L = 0; L !== M; ++L)
        A[L] = t[L];
      g.clippingState = A, this[p(3508)] = y ? this[p(1336)] : 0, this[p(1336)] += b;
    }
  };
  function h() {
    const u = e;
    c[u(1811)] !== t && (c[u(1811)] = t, c[u(3035)] = i > 0), x[u(1336)] = i, x[u(3508)] = 0;
  }
  function f(u, l, _, p) {
    const m = e, y = u !== null ? u[m(3105)] : 0;
    let v = null;
    if (y !== 0) {
      if (v = c[m(1811)], p !== !![] || v === null) {
        const g = _ + y * 4, b = l.matrixWorldInverse;
        o[m(1424)](b), (v === null || v[m(3105)] < g) && (v = new Float32Array(g));
        for (let M = 0, A = _; M !== y; ++M, A += 4)
          r[m(2875)](u[M])[m(2442)](b, o), r.normal[m(1496)](v, A), v[A + 3] = r.constant;
      }
      c[m(1811)] = v, c.needsUpdate = !![];
    }
    return x.numPlanes = y, x[m(3508)] = 0, v;
  }
}
function hb(d) {
  let e = /* @__PURE__ */ new WeakMap();
  function x(a, r) {
    const o = c0;
    return r === Gi ? a[o(667)] = St : r === Pn && (a[o(667)] = Tt), a;
  }
  function t(a) {
    const r = c0;
    if (a && a[r(1714)] && a.isRenderTargetTexture === ![]) {
      const o = a[r(667)];
      if (o === Gi || o === Pn)
        if (e[r(2086)](a)) {
          const c = e[r(3016)](a)[r(2431)];
          return x(c, a[r(667)]);
        } else {
          const c = a[r(450)];
          if (c && c[r(1674)] > 0) {
            const h = new Xd(c[r(1674)] / 2);
            return h[r(1414)](d, a), e[r(1260)](a, h), a[r(818)](r(3387), i), x(h.texture, a[r(667)]);
          } else
            return null;
        }
    }
    return a;
  }
  function i(a) {
    const r = c0, o = a[r(671)];
    o[r(1079)]("dispose", i);
    const c = e.get(o);
    c !== void 0 && (e[r(2850)](o), c.dispose());
  }
  function n() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return { get: t, dispose: n };
}
class Ji extends wa {
  constructor(e = -1, x = 1, t = 1, i = -1, n = 0.1, a = 2e3) {
    const r = s;
    super(), this[r(519)] = !![], this[r(566)] = r(1099), this[r(2477)] = 1, this[r(1206)] = null, this.left = e, this[r(3383)] = x, this[r(1376)] = t, this[r(574)] = i, this[r(1448)] = n, this[r(3691)] = a, this.updateProjectionMatrix();
  }
  [s(2875)](e, x) {
    const t = s;
    return super.copy(e, x), this[t(1640)] = e.left, this[t(3383)] = e[t(3383)], this[t(1376)] = e.top, this.bottom = e[t(574)], this[t(1448)] = e[t(1448)], this[t(3691)] = e[t(3691)], this[t(2477)] = e[t(2477)], this.view = e[t(1206)] === null ? null : Object.assign({}, e[t(1206)]), this;
  }
  setViewOffset(e, x, t, i, n, a) {
    const r = s;
    this[r(1206)] === null && (this[r(1206)] = { enabled: !![], fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this[r(1206)][r(2679)] = !![], this[r(1206)][r(2169)] = e, this.view[r(2096)] = x, this[r(1206)][r(2618)] = t, this[r(1206)][r(1948)] = i, this[r(1206)][r(1631)] = n, this[r(1206)][r(1674)] = a, this[r(1701)]();
  }
  clearViewOffset() {
    const e = s;
    this[e(1206)] !== null && (this[e(1206)][e(2679)] = ![]), this[e(1701)]();
  }
  [s(1701)]() {
    const e = s, x = (this[e(3383)] - this[e(1640)]) / (2 * this[e(2477)]), t = (this[e(1376)] - this.bottom) / (2 * this[e(2477)]), i = (this.right + this.left) / 2, n = (this.top + this[e(574)]) / 2;
    let a = i - x, r = i + x, o = n + t, c = n - t;
    if (this.view !== null && this[e(1206)][e(2679)]) {
      const h = (this[e(3383)] - this[e(1640)]) / this.view[e(2169)] / this.zoom, f = (this.top - this[e(574)]) / this.view.fullHeight / this.zoom;
      a += h * this[e(1206)].offsetX, r = a + h * this[e(1206)][e(1631)], o -= f * this[e(1206)][e(1948)], c = o - f * this[e(1206)][e(1674)];
    }
    this[e(1057)][e(2062)](a, r, o, c, this[e(1448)], this[e(3691)]), this[e(583)].copy(this[e(1057)]).invert();
  }
  [s(3139)](e) {
    const x = s, t = super[x(3139)](e);
    return t[x(1413)][x(2477)] = this.zoom, t[x(1413)].left = this[x(1640)], t[x(1413)].right = this[x(3383)], t[x(1413)][x(1376)] = this.top, t[x(1413)][x(574)] = this[x(574)], t[x(1413)][x(1448)] = this[x(1448)], t[x(1413)].far = this.far, this[x(1206)] !== null && (t[x(1413)][x(1206)] = Object[x(1188)]({}, this[x(1206)])), t;
  }
}
const Oi = 4, _o = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], Xt = 20, nr = new Ji(), vo = new P0();
let sr = null;
const Wt = (1 + Math[s(713)](5)) / 2, Mi = 1 / Wt, yo = [new z(1, 1, 1), new z(-1, 1, 1), new z(1, 1, -1), new z(-1, 1, -1), new z(0, Wt, Mi), new z(0, Wt, -Mi), new z(Mi, 0, Wt), new z(-Mi, 0, Wt), new z(Wt, Mi, 0), new z(-Wt, Mi, 0)];
class Bn {
  constructor(e) {
    const x = s;
    this[x(2609)] = e, this._pingPongRenderTarget = null, this[x(2735)] = 0, this._cubeSize = 0, this[x(2504)] = [], this._sizeLods = [], this[x(1466)] = [], this[x(1060)] = null, this._cubemapMaterial = null, this[x(3267)] = null, this[x(3079)](this[x(1060)]);
  }
  fromScene(e, x = 0, t = 0.1, i = 100) {
    const n = s;
    sr = this[n(2609)][n(427)](), this[n(3635)](256);
    const a = this._allocateTargets();
    return a[n(471)] = !![], this[n(1373)](e, t, i, a), x > 0 && this[n(1471)](a, 0, 0, x), this[n(3657)](a), this._cleanup(a), a;
  }
  fromEquirectangular(e, x = null) {
    return this._fromTexture(e, x);
  }
  fromCubemap(e, x = null) {
    return this[s(912)](e, x);
  }
  [s(2370)]() {
    const e = s;
    this._cubemapMaterial === null && (this._cubemapMaterial = So(), this[e(3079)](this[e(2016)]));
  }
  [s(3092)]() {
    const e = s;
    this[e(3267)] === null && (this[e(3267)] = Mo(), this._compileMaterial(this._equirectMaterial));
  }
  [s(3387)]() {
    const e = s;
    this._dispose(), this[e(2016)] !== null && this[e(2016)][e(3387)](), this[e(3267)] !== null && this[e(3267)][e(3387)]();
  }
  _setSize(e) {
    const x = s;
    this._lodMax = Math.floor(Math[x(3422)](e)), this[x(1983)] = Math[x(3196)](2, this[x(2735)]);
  }
  [s(1240)]() {
    const e = s;
    this[e(1060)] !== null && this._blurMaterial[e(3387)](), this[e(927)] !== null && this[e(927)][e(3387)]();
    for (let x = 0; x < this._lodPlanes[e(3105)]; x++)
      this[e(2504)][x][e(3387)]();
  }
  [s(2571)](e) {
    const x = s;
    this[x(2609)].setRenderTarget(sr), e.scissorTest = ![], Ls(e, 0, 0, e[x(1631)], e[x(1674)]);
  }
  _fromTexture(e, x) {
    const t = s;
    e.mapping === St || e[t(667)] === Tt ? this[t(3635)](e[t(450)][t(3105)] === 0 ? 16 : e[t(450)][0][t(1631)] || e[t(450)][0][t(450)][t(1631)]) : this[t(3635)](e.image[t(1631)] / 4), sr = this._renderer.getRenderTarget();
    const i = x || this._allocateTargets();
    return this[t(497)](e, i), this._applyPMREM(i), this[t(2571)](i), i;
  }
  [s(1643)]() {
    const e = s, x = 3 * Math[e(1803)](this[e(1983)], 16 * 7), t = 4 * this[e(1983)], i = { magFilter: Cx, minFilter: Cx, generateMipmaps: ![], type: ue, format: le, encoding: Ne, depthBuffer: ![] }, n = wo(x, t, i);
    if (this[e(927)] === null || this[e(927)][e(1631)] !== x || this._pingPongRenderTarget.height !== t) {
      this[e(927)] !== null && this[e(1240)](), this[e(927)] = wo(x, t, i);
      const { _lodMax: a } = this;
      ({ sizeLods: this[e(3499)], lodPlanes: this[e(2504)], sigmas: this[e(1466)] } = fb(a)), this._blurMaterial = lb(a, x, t);
    }
    return n;
  }
  [s(3079)](e) {
    const x = s, t = new Wx(this[x(2504)][0], e);
    this._renderer[x(1479)](t, nr);
  }
  [s(1373)](e, x, t, i) {
    const n = s, a = 90, r = 1, o = new Vx(a, r, x, t), c = [1, -1, 1, 1, 1, 1], h = [1, 1, 1, -1, -1, -1], f = this[n(2609)], u = f[n(1363)], l = f.toneMapping;
    f.getClearColor(vo), f[n(602)] = We, f[n(1363)] = ![];
    const _ = new be({ name: "PMREM.Background", side: re, depthWrite: ![], depthTest: ![] }), p = new Wx(new It(), _);
    let m = ![];
    const y = e[n(2525)];
    y ? y[n(1035)] && (_[n(3282)].copy(y), e[n(2525)] = null, m = !![]) : (_[n(3282)][n(2875)](vo), m = !![]);
    for (let v = 0; v < 6; v++) {
      const g = v % 3;
      g === 0 ? (o.up[n(1260)](0, c[v], 0), o[n(2577)](h[v], 0, 0)) : g === 1 ? (o.up[n(1260)](0, 0, c[v]), o[n(2577)](0, h[v], 0)) : (o.up[n(1260)](0, c[v], 0), o.lookAt(0, 0, h[v]));
      const b = this._cubeSize;
      Ls(i, g * b, v > 2 ? b : 0, b, b), f[n(2969)](i), m && f[n(489)](p, o), f[n(489)](e, o);
    }
    p[n(1353)][n(3387)](), p[n(1870)][n(3387)](), f[n(602)] = l, f[n(1363)] = u, e[n(2525)] = y;
  }
  _textureToCubeUV(e, x) {
    const t = s, i = this[t(2609)], n = e.mapping === St || e[t(667)] === Tt;
    n ? (this[t(2016)] === null && (this[t(2016)] = So()), this[t(2016)][t(2833)][t(3234)][t(1811)] = e[t(546)] === ![] ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = Mo());
    const a = n ? this[t(2016)] : this[t(3267)], r = new Wx(this._lodPlanes[0], a), o = a[t(2833)];
    o.envMap[t(1811)] = e;
    const c = this._cubeSize;
    Ls(x, 0, 0, 3 * c, 2 * c), i[t(2969)](x), i.render(r, nr);
  }
  [s(3657)](e) {
    const x = s, t = this[x(2609)], i = t[x(1363)];
    t[x(1363)] = ![];
    for (let n = 1; n < this[x(2504)].length; n++) {
      const a = Math[x(713)](this[x(1466)][n] * this[x(1466)][n] - this[x(1466)][n - 1] * this[x(1466)][n - 1]), r = yo[(n - 1) % yo[x(3105)]];
      this._blur(e, n - 1, n, a, r);
    }
    t.autoClear = i;
  }
  [s(1471)](e, x, t, i, n) {
    const a = s, r = this[a(927)];
    this[a(904)](e, r, x, t, i, a(2449), n), this[a(904)](r, e, t, t, i, a(799), n);
  }
  [s(904)](e, x, t, i, n, a, r) {
    const o = s, c = this[o(2609)], h = this[o(1060)];
    a !== o(2449) && a !== "longitudinal" && console.error(o(2097));
    const f = 3, u = new Wx(this._lodPlanes[i], h), l = h.uniforms, _ = this[o(3499)][t] - 1, p = isFinite(n) ? Math.PI / (2 * _) : 2 * Math.PI / (2 * Xt - 1), m = n / p, y = isFinite(n) ? 1 + Math[o(2697)](f * m) : Xt;
    y > Xt && console.warn(o(3695) + n + o(3372) + y + o(1535) + Xt);
    const v = [];
    let g = 0;
    for (let P = 0; P < Xt; ++P) {
      const S = P / m, I = Math[o(1773)](-S * S / 2);
      v[o(3156)](I), P === 0 ? g += I : P < y && (g += 2 * I);
    }
    for (let P = 0; P < v[o(3105)]; P++)
      v[P] = v[P] / g;
    l[o(1477)][o(1811)] = e.texture, l[o(1820)][o(1811)] = y, l[o(3012)][o(1811)] = v, l[o(2449)].value = a === o(2449), r && (l[o(461)][o(1811)] = r);
    const { _lodMax: b } = this;
    l[o(635)][o(1811)] = p, l[o(668)][o(1811)] = b - t;
    const M = this[o(3499)][i], A = 3 * M * (i > b - Oi ? i - b + Oi : 0), L = 4 * (this[o(1983)] - M);
    Ls(x, A, L, 3 * M, 2 * M), c[o(2969)](x), c[o(489)](u, nr);
  }
}
function fb(d) {
  const e = s, x = [], t = [], i = [];
  let n = d;
  const a = d - Oi + 1 + _o.length;
  for (let r = 0; r < a; r++) {
    const o = Math[e(3196)](2, n);
    t[e(3156)](o);
    let c = 1 / o;
    r > d - Oi ? c = _o[r - d + Oi - 1] : r === 0 && (c = 0), i[e(3156)](c);
    const h = 1 / (o - 2), f = -h, u = 1 + h, l = [f, f, u, f, u, u, f, f, u, u, f, u], _ = 6, p = 6, m = 3, y = 2, v = 1, g = new Float32Array(m * p * _), b = new Float32Array(y * p * _), M = new Float32Array(v * p * _);
    for (let L = 0; L < _; L++) {
      const P = L % 3 * 2 / 3 - 1, S = L > 2 ? 0 : -1, I = [P, S, 0, P + 2 / 3, S, 0, P + 2 / 3, S + 1, 0, P, S, 0, P + 2 / 3, S + 1, 0, P, S + 1, 0];
      g[e(1260)](I, m * p * L), b[e(1260)](l, y * p * L);
      const C = [L, L, L, L, L, L];
      M[e(1260)](C, v * p * L);
    }
    const A = new ox();
    A[e(3599)](e(3571), new gx(g, m)), A[e(3599)]("uv", new gx(b, y)), A.setAttribute("faceIndex", new gx(M, v)), x.push(A), n > Oi && n--;
  }
  return { lodPlanes: x, sizeLods: t, sigmas: i };
}
function wo(d, e, x) {
  const t = s, i = new oe(d, e, x);
  return i[t(2431)][t(667)] = Ki, i[t(2431)].name = t(2229), i[t(1199)] = !![], i;
}
function Ls(d, e, x, t, i) {
  const n = s;
  d[n(2483)][n(1260)](e, x, t, i), d.scissor.set(e, x, t, i);
}
function lb(d, e, x) {
  const t = s, i = new Float32Array(Xt), n = new z(0, 1, 0);
  return new ee({ name: t(1441), defines: { n: Xt, CUBEUV_TEXEL_WIDTH: 1 / e, CUBEUV_TEXEL_HEIGHT: 1 / x, CUBEUV_MAX_MIP: d + ".0" }, uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: i }, latitudinal: { value: ![] }, dTheta: { value: 0 }, mipInt: { value: 0 }, poleAxis: { value: n } }, vertexShader: P2(), fragmentShader: t(3659), blending: Ve, depthTest: ![], depthWrite: ![] });
}
function Mo() {
  const d = s;
  return new ee({ name: d(946), uniforms: { envMap: { value: null } }, vertexShader: P2(), fragmentShader: d(1226), blending: Ve, depthTest: ![], depthWrite: ![] });
}
function So() {
  const d = s;
  return new ee({ name: d(1952), uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } }, vertexShader: P2(), fragmentShader: d(1785), blending: Ve, depthTest: ![], depthWrite: ![] });
}
function P2() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function ub(d) {
  let e = /* @__PURE__ */ new WeakMap(), x = null;
  function t(r) {
    const o = c0;
    if (r && r.isTexture) {
      const c = r[o(667)], h = c === Gi || c === Pn, f = c === St || c === Tt;
      if (h || f)
        if (r[o(546)] && r[o(1152)] === !![]) {
          r.needsPMREMUpdate = ![];
          let u = e[o(3016)](r);
          return x === null && (x = new Bn(d)), u = h ? x[o(577)](r, u) : x.fromCubemap(r, u), e[o(1260)](r, u), u[o(2431)];
        } else {
          if (e.has(r))
            return e.get(r)[o(2431)];
          {
            const u = r[o(450)];
            if (h && u && u[o(1674)] > 0 || f && u && i(u)) {
              x === null && (x = new Bn(d));
              const l = h ? x[o(577)](r) : x[o(1028)](r);
              return e[o(1260)](r, l), r[o(818)](o(3387), n), l[o(2431)];
            } else
              return null;
          }
        }
    }
    return r;
  }
  function i(r) {
    let o = 0;
    const c = 6;
    for (let h = 0; h < c; h++)
      r[h] !== void 0 && o++;
    return o === c;
  }
  function n(r) {
    const o = c0, c = r[o(671)];
    c[o(1079)]("dispose", n);
    const h = e[o(3016)](c);
    h !== void 0 && (e[o(2850)](c), h[o(3387)]());
  }
  function a() {
    const r = c0;
    e = /* @__PURE__ */ new WeakMap(), x !== null && (x[r(3387)](), x = null);
  }
  return { get: t, dispose: a };
}
function bb(d) {
  const e = {};
  function x(t) {
    const i = c0;
    if (e[t] !== void 0)
      return e[t];
    let n;
    switch (t) {
      case "WEBGL_depth_texture":
        n = d[i(2450)](i(1542)) || d[i(2450)]("MOZ_WEBGL_depth_texture") || d[i(2450)](i(2620));
        break;
      case i(1869):
        n = d[i(2450)](i(1869)) || d[i(2450)](i(696)) || d[i(2450)](i(1839));
        break;
      case i(2159):
        n = d[i(2450)](i(2159)) || d[i(2450)](i(1745)) || d[i(2450)]("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case i(2937):
        n = d[i(2450)](i(2937)) || d[i(2450)](i(2109));
        break;
      default:
        n = d.getExtension(t);
    }
    return e[t] = n, n;
  }
  return { has: function(t) {
    return x(t) !== null;
  }, init: function(t) {
    const i = c0;
    t[i(510)] ? x(i(1371)) : (x("WEBGL_depth_texture"), x(i(3027)), x(i(875)), x(i(740)), x(i(726)), x("OES_element_index_uint"), x(i(637)), x("ANGLE_instanced_arrays")), x(i(547)), x(i(3365)), x(i(2598));
  }, get: function(t) {
    const i = c0, n = x(t);
    return n === null && console[i(3629)](i(2412) + t + i(848)), n;
  } };
}
function pb(d, e, x, t) {
  const i = {}, n = /* @__PURE__ */ new WeakMap();
  function a(f) {
    const u = c0, l = f[u(671)];
    l.index !== null && e[u(3137)](l[u(3678)]);
    for (const p in l[u(3265)])
      e[u(3137)](l[u(3265)][p]);
    l[u(1079)](u(3387), a), delete i[l.id];
    const _ = n[u(3016)](l);
    _ && (e[u(3137)](_), n[u(2850)](l)), t.releaseStatesOfGeometry(l), l.isInstancedBufferGeometry === !![] && delete l[u(2562)], x.memory[u(1986)]--;
  }
  function r(f, u) {
    const l = c0;
    return i[u.id] === !![] || (u[l(818)](l(3387), a), i[u.id] = !![], x[l(2158)][l(1986)]++), u;
  }
  function o(f) {
    const u = c0, l = f[u(3265)];
    for (const p in l)
      e[u(3452)](l[p], 34962);
    const _ = f.morphAttributes;
    for (const p in _) {
      const m = _[p];
      for (let y = 0, v = m[u(3105)]; y < v; y++)
        e[u(3452)](m[y], 34962);
    }
  }
  function c(f) {
    const u = c0, l = [], _ = f[u(3678)], p = f[u(3265)][u(3571)];
    let m = 0;
    if (_ !== null) {
      const g = _[u(2712)];
      m = _[u(2185)];
      for (let b = 0, M = g[u(3105)]; b < M; b += 3) {
        const A = g[b + 0], L = g[b + 1], P = g[b + 2];
        l.push(A, L, L, P, P, A);
      }
    } else {
      const g = p[u(2712)];
      m = p[u(2185)];
      for (let b = 0, M = g[u(3105)] / 3 - 1; b < M; b += 3) {
        const A = b + 0, L = b + 1, P = b + 2;
        l.push(A, L, L, P, P, A);
      }
    }
    const y = new (kd(l) ? R2 : L2)(l, 1);
    y.version = m;
    const v = n[u(3016)](f);
    v && e.remove(v), n.set(f, y);
  }
  function h(f) {
    const u = c0, l = n[u(3016)](f);
    if (l) {
      const _ = f[u(3678)];
      _ !== null && l.version < _[u(2185)] && c(f);
    } else
      c(f);
    return n[u(3016)](f);
  }
  return { get: r, update: o, getWireframeAttribute: h };
}
function mb(d, e, x, t) {
  const i = s, n = t[i(510)];
  let a;
  function r(l) {
    a = l;
  }
  let o, c;
  function h(l) {
    const _ = i;
    o = l[_(566)], c = l[_(2720)];
  }
  function f(l, _) {
    const p = i;
    d[p(3214)](a, _, o, l * c), x[p(3452)](_, a, 1);
  }
  function u(l, _, p) {
    const m = i;
    if (p === 0)
      return;
    let y, v;
    if (n)
      y = d, v = m(1272);
    else if (y = e[m(3016)](m(425)), v = "drawElementsInstancedANGLE", y === null) {
      console[m(533)](m(1243));
      return;
    }
    y[v](a, _, o, l * c, p), x.update(_, a, p);
  }
  this.setMode = r, this.setIndex = h, this[i(489)] = f, this[i(2347)] = u;
}
function gb(d) {
  const e = { geometries: 0, textures: 0 }, x = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  function t(n, a, r) {
    const o = c0;
    switch (x[o(3244)]++, a) {
      case 4:
        x[o(442)] += r * (n / 3);
        break;
      case 1:
        x[o(1410)] += r * (n / 2);
        break;
      case 3:
        x[o(1410)] += r * (n - 1);
        break;
      case 2:
        x[o(1410)] += r * n;
        break;
      case 0:
        x.points += r * n;
        break;
      default:
        console[o(533)]("THREE.WebGLInfo: Unknown draw mode:", a);
        break;
    }
  }
  function i() {
    const n = c0;
    x[n(1320)]++, x[n(3244)] = 0, x.triangles = 0, x[n(1197)] = 0, x[n(1410)] = 0;
  }
  return { memory: e, render: x, programs: null, autoReset: !![], reset: i, update: t };
}
function _b(d, e) {
  return d[0] - e[0];
}
function vb(d, e) {
  const x = s;
  return Math.abs(e[1]) - Math[x(3373)](d[1]);
}
function yb(d, e, x) {
  const t = {}, i = new Float32Array(8), n = /* @__PURE__ */ new WeakMap(), a = new Mx(), r = [];
  for (let c = 0; c < 8; c++)
    r[c] = [c, 0];
  function o(c, h, f) {
    const u = c0, l = c[u(2072)];
    if (e[u(510)] === !![]) {
      const _ = h[u(1034)][u(3571)] || h.morphAttributes[u(2111)] || h.morphAttributes[u(3282)], p = _ !== void 0 ? _[u(3105)] : 0;
      let m = n[u(3016)](h);
      if (m === void 0 || m.count !== p) {
        let V = function() {
          const X = u;
          $.dispose(), n.delete(h), h[X(1079)](X(3387), V);
        };
        m !== void 0 && m.texture[u(3387)]();
        const g = h[u(1034)][u(3571)] !== void 0, b = h[u(1034)].normal !== void 0, M = h.morphAttributes[u(3282)] !== void 0, A = h[u(1034)].position || [], L = h[u(1034)][u(2111)] || [], P = h[u(1034)][u(3282)] || [];
        let S = 0;
        g === !![] && (S = 1), b === !![] && (S = 2), M === !![] && (S = 3);
        let I = h[u(3265)][u(3571)].count * S, C = 1;
        I > e.maxTextureSize && (C = Math[u(756)](I / e[u(2310)]), I = e[u(2310)]);
        const G = new Float32Array(I * C * 4 * p), $ = new va(G, I, C, p);
        $[u(566)] = ae, $[u(3035)] = !![];
        const N = S * 4;
        for (let X = 0; X < p; X++) {
          const n0 = A[X], b0 = L[X], Q = P[X], r0 = I * C * 4 * X;
          for (let l0 = 0; l0 < n0.count; l0++) {
            const v0 = l0 * N;
            g === !![] && (a[u(804)](n0, l0), G[r0 + v0 + 0] = a.x, G[r0 + v0 + 1] = a.y, G[r0 + v0 + 2] = a.z, G[r0 + v0 + 3] = 0), b === !![] && (a[u(804)](b0, l0), G[r0 + v0 + 4] = a.x, G[r0 + v0 + 5] = a.y, G[r0 + v0 + 6] = a.z, G[r0 + v0 + 7] = 0), M === !![] && (a[u(804)](Q, l0), G[r0 + v0 + 8] = a.x, G[r0 + v0 + 9] = a.y, G[r0 + v0 + 10] = a.z, G[r0 + v0 + 11] = Q.itemSize === 4 ? a.w : 1);
          }
        }
        m = { count: p, texture: $, size: new d0(I, C) }, n[u(1260)](h, m), h.addEventListener(u(3387), V);
      }
      let y = 0;
      for (let g = 0; g < l[u(3105)]; g++)
        y += l[g];
      const v = h[u(3150)] ? 1 : 1 - y;
      f[u(486)]().setValue(d, "morphTargetBaseInfluence", v), f[u(486)]().setValue(d, u(2072), l), f[u(486)]()[u(2249)](d, u(1456), m[u(2431)], x), f[u(486)]()[u(2249)](d, u(1544), m[u(3073)]);
    } else {
      const _ = l === void 0 ? 0 : l[u(3105)];
      let p = t[h.id];
      if (p === void 0 || p[u(3105)] !== _) {
        p = [];
        for (let b = 0; b < _; b++)
          p[b] = [b, 0];
        t[h.id] = p;
      }
      for (let b = 0; b < _; b++) {
        const M = p[b];
        M[0] = b, M[1] = l[b];
      }
      p.sort(vb);
      for (let b = 0; b < 8; b++)
        b < _ && p[b][1] ? (r[b][0] = p[b][0], r[b][1] = p[b][1]) : (r[b][0] = Number.MAX_SAFE_INTEGER, r[b][1] = 0);
      r[u(614)](_b);
      const m = h.morphAttributes[u(3571)], y = h[u(1034)].normal;
      let v = 0;
      for (let b = 0; b < 8; b++) {
        const M = r[b], A = M[0], L = M[1];
        A !== Number[u(2001)] && L ? (m && h[u(1740)](u(1519) + b) !== m[A] && h[u(3599)](u(1519) + b, m[A]), y && h[u(1740)](u(719) + b) !== y[A] && h[u(3599)](u(719) + b, y[A]), i[b] = L, v += L) : (m && h[u(2232)](u(1519) + b) === !![] && h[u(1951)]("morphTarget" + b), y && h[u(2232)](u(719) + b) === !![] && h[u(1951)](u(719) + b), i[b] = 0);
      }
      const g = h.morphTargetsRelative ? 1 : 1 - v;
      f[u(486)]()[u(2249)](d, "morphTargetBaseInfluence", g), f.getUniforms()[u(2249)](d, u(2072), i);
    }
  }
  return { update: o };
}
function wb(d, e, x, t) {
  let i = /* @__PURE__ */ new WeakMap();
  function n(o) {
    const c = c0, h = t[c(489)][c(1320)], f = o.geometry, u = e.get(o, f);
    return i.get(u) !== h && (e[c(3452)](u), i.set(u, h)), o[c(2342)] && (o[c(2131)](c(3387), r) === ![] && o.addEventListener(c(3387), r), x[c(3452)](o.instanceMatrix, 34962), o[c(752)] !== null && x[c(3452)](o[c(752)], 34962)), u;
  }
  function a() {
    i = /* @__PURE__ */ new WeakMap();
  }
  function r(o) {
    const c = c0, h = o.target;
    h[c(1079)](c(3387), r), x[c(3137)](h[c(1312)]), h[c(752)] !== null && x[c(3137)](h.instanceColor);
  }
  return { update: n, dispose: a };
}
const Yd = new Ux(), Zd = new va(), Kd = new C2(), $d = new qn(), To = [], Eo = [], Ao = new Float32Array(16), Co = new Float32Array(9), Lo = new Float32Array(4);
function Qi(d, e, x) {
  const t = s, i = d[0];
  if (i <= 0 || i > 0)
    return d;
  const n = e * x;
  let a = To[n];
  if (a === void 0 && (a = new Float32Array(n), To[n] = a), e !== 0) {
    i[t(1496)](a, 0);
    for (let r = 1, o = 0; r !== e; ++r)
      o += x, d[r][t(1496)](a, o);
  }
  return a;
}
function Xx(d, e) {
  const x = s;
  if (d[x(3105)] !== e[x(3105)])
    return ![];
  for (let t = 0, i = d[x(3105)]; t < i; t++)
    if (d[t] !== e[t])
      return ![];
  return !![];
}
function qx(d, e) {
  for (let x = 0, t = e.length; x < t; x++)
    d[x] = e[x];
}
function Sa(d, e) {
  let x = Eo[e];
  x === void 0 && (x = new Int32Array(e), Eo[e] = x);
  for (let t = 0; t !== e; ++t)
    x[t] = d.allocateTextureUnit();
  return x;
}
function Mb(d, e) {
  const x = s, t = this[x(2023)];
  t[0] !== e && (d[x(1084)](this[x(2527)], e), t[0] = e);
}
function Sb(d, e) {
  const x = s, t = this[x(2023)];
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (d[x(862)](this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (Xx(t, e))
      return;
    d.uniform2fv(this.addr, e), qx(t, e);
  }
}
function Tb(d, e) {
  const x = s, t = this[x(2023)];
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (d[x(1988)](this[x(2527)], e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else if (e.r !== void 0)
    (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (d[x(1988)](this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b);
  else {
    if (Xx(t, e))
      return;
    d[x(1838)](this[x(2527)], e), qx(t, e);
  }
}
function Eb(d, e) {
  const x = s, t = this[x(2023)];
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (d[x(3142)](this[x(2527)], e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (Xx(t, e))
      return;
    d[x(1209)](this.addr, e), qx(t, e);
  }
}
function Ab(d, e) {
  const x = s, t = this[x(2023)], i = e[x(717)];
  if (i === void 0) {
    if (Xx(t, e))
      return;
    d[x(3467)](this[x(2527)], ![], e), qx(t, e);
  } else {
    if (Xx(t, i))
      return;
    Lo[x(1260)](i), d.uniformMatrix2fv(this[x(2527)], ![], Lo), qx(t, i);
  }
}
function Cb(d, e) {
  const x = s, t = this[x(2023)], i = e[x(717)];
  if (i === void 0) {
    if (Xx(t, e))
      return;
    d[x(1020)](this[x(2527)], ![], e), qx(t, e);
  } else {
    if (Xx(t, i))
      return;
    Co[x(1260)](i), d.uniformMatrix3fv(this[x(2527)], ![], Co), qx(t, i);
  }
}
function Lb(d, e) {
  const x = s, t = this[x(2023)], i = e[x(717)];
  if (i === void 0) {
    if (Xx(t, e))
      return;
    d.uniformMatrix4fv(this[x(2527)], ![], e), qx(t, e);
  } else {
    if (Xx(t, i))
      return;
    Ao[x(1260)](i), d.uniformMatrix4fv(this[x(2527)], ![], Ao), qx(t, i);
  }
}
function Rb(d, e) {
  const x = s, t = this[x(2023)];
  t[0] !== e && (d[x(794)](this[x(2527)], e), t[0] = e);
}
function Pb(d, e) {
  const x = s, t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (d[x(3622)](this[x(2527)], e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (Xx(t, e))
      return;
    d[x(596)](this.addr, e), qx(t, e);
  }
}
function Ib(d, e) {
  const x = s, t = this[x(2023)];
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (d[x(449)](this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else {
    if (Xx(t, e))
      return;
    d[x(2515)](this[x(2527)], e), qx(t, e);
  }
}
function Db(d, e) {
  const x = s, t = this[x(2023)];
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (d[x(1670)](this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (Xx(t, e))
      return;
    d[x(1642)](this.addr, e), qx(t, e);
  }
}
function Ob(d, e) {
  const x = s, t = this[x(2023)];
  t[0] !== e && (d[x(632)](this.addr, e), t[0] = e);
}
function Nb(d, e) {
  const x = s, t = this[x(2023)];
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (d[x(1680)](this[x(2527)], e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (Xx(t, e))
      return;
    d[x(1661)](this[x(2527)], e), qx(t, e);
  }
}
function Ub(d, e) {
  const x = s, t = this[x(2023)];
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (d[x(1157)](this[x(2527)], e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else {
    if (Xx(t, e))
      return;
    d.uniform3uiv(this[x(2527)], e), qx(t, e);
  }
}
function zb(d, e) {
  const x = s, t = this[x(2023)];
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (d[x(1728)](this[x(2527)], e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (Xx(t, e))
      return;
    d[x(2754)](this[x(2527)], e), qx(t, e);
  }
}
function Bb(d, e, x) {
  const t = s, i = this[t(2023)], n = x[t(2931)]();
  i[0] !== n && (d.uniform1i(this[t(2527)], n), i[0] = n), x[t(3670)](e || Yd, n);
}
function Fb(d, e, x) {
  const t = s, i = this[t(2023)], n = x[t(2931)]();
  i[0] !== n && (d.uniform1i(this.addr, n), i[0] = n), x.setTexture3D(e || Kd, n);
}
function Gb(d, e, x) {
  const t = s, i = this[t(2023)], n = x[t(2931)]();
  i[0] !== n && (d[t(794)](this[t(2527)], n), i[0] = n), x[t(2188)](e || $d, n);
}
function Hb(d, e, x) {
  const t = s, i = this[t(2023)], n = x[t(2931)]();
  i[0] !== n && (d[t(794)](this[t(2527)], n), i[0] = n), x[t(3161)](e || Zd, n);
}
function kb(d) {
  switch (d) {
    case 5126:
      return Mb;
    case 35664:
      return Sb;
    case 35665:
      return Tb;
    case 35666:
      return Eb;
    case 35674:
      return Ab;
    case 35675:
      return Cb;
    case 35676:
      return Lb;
    case 5124:
    case 35670:
      return Rb;
    case 35667:
    case 35671:
      return Pb;
    case 35668:
    case 35672:
      return Ib;
    case 35669:
    case 35673:
      return Db;
    case 5125:
      return Ob;
    case 36294:
      return Nb;
    case 36295:
      return Ub;
    case 36296:
      return zb;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return Bb;
    case 35679:
    case 36299:
    case 36307:
      return Fb;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return Gb;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return Hb;
  }
}
function Vb(d, e) {
  const x = s;
  d[x(1971)](this[x(2527)], e);
}
function Wb(d, e) {
  const x = s, t = Qi(e, this.size, 2);
  d[x(2068)](this[x(2527)], t);
}
function jb(d, e) {
  const x = s, t = Qi(e, this[x(3073)], 3);
  d[x(1838)](this[x(2527)], t);
}
function Xb(d, e) {
  const x = s, t = Qi(e, this[x(3073)], 4);
  d[x(1209)](this[x(2527)], t);
}
function qb(d, e) {
  const x = s, t = Qi(e, this[x(3073)], 4);
  d.uniformMatrix2fv(this.addr, ![], t);
}
function Yb(d, e) {
  const x = s, t = Qi(e, this.size, 9);
  d[x(1020)](this[x(2527)], ![], t);
}
function Zb(d, e) {
  const x = s, t = Qi(e, this[x(3073)], 16);
  d.uniformMatrix4fv(this[x(2527)], ![], t);
}
function Kb(d, e) {
  d[s(2844)](this.addr, e);
}
function $b(d, e) {
  d.uniform2iv(this.addr, e);
}
function Jb(d, e) {
  const x = s;
  d[x(2515)](this[x(2527)], e);
}
function Qb(d, e) {
  d[s(1642)](this.addr, e);
}
function xp(d, e) {
  const x = s;
  d[x(565)](this[x(2527)], e);
}
function ep(d, e) {
  const x = s;
  d[x(1661)](this[x(2527)], e);
}
function tp(d, e) {
  const x = s;
  d.uniform3uiv(this[x(2527)], e);
}
function ip(d, e) {
  d.uniform4uiv(this.addr, e);
}
function np(d, e, x) {
  const t = s, i = this.cache, n = e[t(3105)], a = Sa(x, n);
  !Xx(i, a) && (d[t(2844)](this[t(2527)], a), qx(i, a));
  for (let r = 0; r !== n; ++r)
    x[t(3670)](e[r] || Yd, a[r]);
}
function sp(d, e, x) {
  const t = s, i = this[t(2023)], n = e[t(3105)], a = Sa(x, n);
  !Xx(i, a) && (d[t(2844)](this[t(2527)], a), qx(i, a));
  for (let r = 0; r !== n; ++r)
    x.setTexture3D(e[r] || Kd, a[r]);
}
function ap(d, e, x) {
  const t = s, i = this[t(2023)], n = e[t(3105)], a = Sa(x, n);
  !Xx(i, a) && (d[t(2844)](this[t(2527)], a), qx(i, a));
  for (let r = 0; r !== n; ++r)
    x.setTextureCube(e[r] || $d, a[r]);
}
function rp(d, e, x) {
  const t = s, i = this[t(2023)], n = e[t(3105)], a = Sa(x, n);
  !Xx(i, a) && (d[t(2844)](this[t(2527)], a), qx(i, a));
  for (let r = 0; r !== n; ++r)
    x[t(3161)](e[r] || Zd, a[r]);
}
function op(d) {
  switch (d) {
    case 5126:
      return Vb;
    case 35664:
      return Wb;
    case 35665:
      return jb;
    case 35666:
      return Xb;
    case 35674:
      return qb;
    case 35675:
      return Yb;
    case 35676:
      return Zb;
    case 5124:
    case 35670:
      return Kb;
    case 35667:
    case 35671:
      return $b;
    case 35668:
    case 35672:
      return Jb;
    case 35669:
    case 35673:
      return Qb;
    case 5125:
      return xp;
    case 36294:
      return ep;
    case 36295:
      return tp;
    case 36296:
      return ip;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return np;
    case 35679:
    case 36299:
    case 36307:
      return sp;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return ap;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return rp;
  }
}
class cp {
  constructor(e, x, t) {
    const i = s;
    this.id = e, this[i(2527)] = t, this[i(2023)] = [], this[i(2249)] = kb(x[i(566)]);
  }
}
class dp {
  constructor(e, x, t) {
    const i = s;
    this.id = e, this[i(2527)] = t, this[i(2023)] = [], this[i(3073)] = x[i(3073)], this.setValue = op(x[i(566)]);
  }
}
class hp {
  constructor(e) {
    const x = s;
    this.id = e, this[x(1873)] = [], this[x(3644)] = {};
  }
  setValue(e, x, t) {
    const i = s, n = this[i(1873)];
    for (let a = 0, r = n[i(3105)]; a !== r; ++a) {
      const o = n[a];
      o[i(2249)](e, x[o.id], t);
    }
  }
}
const ar = /(\w+)(\])?(\[|\.)?/g;
function Ro(d, e) {
  const x = s;
  d[x(1873)][x(3156)](e), d.map[e.id] = e;
}
function fp(d, e, x) {
  const t = s, i = d[t(3710)], n = i.length;
  for (ar[t(3645)] = 0; []; ) {
    const a = ar[t(625)](i), r = ar[t(3645)];
    let o = a[1];
    const c = a[2] === "]", h = a[3];
    if (c && (o = o | 0), h === void 0 || h === "[" && r + 2 === n) {
      Ro(x, h === void 0 ? new cp(o, d, e) : new dp(o, d, e));
      break;
    } else {
      let u = x.map[o];
      u === void 0 && (u = new hp(o), Ro(x, u)), x = u;
    }
  }
}
class da {
  constructor(e, x) {
    const t = s;
    this[t(1873)] = [], this[t(3644)] = {};
    const i = e[t(849)](x, 35718);
    for (let n = 0; n < i; ++n) {
      const a = e.getActiveUniform(x, n), r = e.getUniformLocation(x, a[t(3710)]);
      fp(a, r, this);
    }
  }
  setValue(e, x, t, i) {
    const n = s, a = this[n(3644)][x];
    a !== void 0 && a[n(2249)](e, t, i);
  }
  [s(2283)](e, x, t) {
    const i = x[t];
    i !== void 0 && this.setValue(e, t, i);
  }
  static [s(639)](e, x, t, i) {
    const n = s;
    for (let a = 0, r = x[n(3105)]; a !== r; ++a) {
      const o = x[a], c = t[o.id];
      c.needsUpdate !== ![] && o.setValue(e, c.value, i);
    }
  }
  static [s(1744)](e, x) {
    const t = s, i = [];
    for (let n = 0, a = e[t(3105)]; n !== a; ++n) {
      const r = e[n];
      r.id in x && i[t(3156)](r);
    }
    return i;
  }
}
function Po(d, e, x) {
  const t = s, i = d[t(1216)](e);
  return d.shaderSource(i, x), d.compileShader(i), i;
}
let lp = 0;
function up(d, e) {
  const x = s, t = d.split(`
`), i = [], n = Math.max(e - 6, 0), a = Math.min(e + 6, t[x(3105)]);
  for (let r = n; r < a; r++) {
    const o = r + 1;
    i[x(3156)]((o === e ? ">" : " ") + " " + o + ": " + t[r]);
  }
  return i[x(3443)](`
`);
}
function bp(d) {
  const e = s;
  switch (d) {
    case Ne:
      return [e(1898), e(847)];
    case _x:
      return ["sRGB", e(847)];
    default:
      return console[e(3629)](e(1271), d), [e(1898), e(847)];
  }
}
function Io(d, e, x) {
  const t = s, i = d[t(982)](e, 35713), n = d[t(1686)](e)[t(549)]();
  if (i && n === "")
    return "";
  const a = /ERROR: 0:(\d+)/[t(625)](n);
  if (a) {
    const r = parseInt(a[1]);
    return x.toUpperCase() + `

` + n + `

` + up(d.getShaderSource(e), r);
  } else
    return n;
}
function pp(d, e) {
  const x = s, t = bp(e);
  return "vec4 " + d + x(3390) + t[0] + t[1] + x(3227);
}
function mp(d, e) {
  const x = s;
  let t;
  switch (e) {
    case ud:
      t = x(1898);
      break;
    case _2:
      t = x(1170);
      break;
    case bd:
      t = x(3344);
      break;
    case pd:
      t = "ACESFilmic";
      break;
    case md:
      t = x(1430);
      break;
    default:
      console[x(3629)](x(3163), e), t = x(1898);
  }
  return x(2502) + d + x(2840) + t + x(1800);
}
function gp(d) {
  const e = s;
  return [d.extensionDerivatives || d[e(1669)] || d[e(758)] || d[e(2144)] || d[e(3674)] || d[e(1529)] || d[e(2743)] === e(802) ? e(1048) : "", (d.extensionFragDepth || d.logarithmicDepthBuffer) && d[e(422)] ? e(3313) : "", d[e(853)] && d[e(2133)] ? e(2528) : "", (d[e(1826)] || d.envMap || d.transmission) && d[e(1978)] ? "#extension GL_EXT_shader_texture_lod : enable" : ""][e(3587)](En)[e(3443)](`
`);
}
function _p(d) {
  const e = s, x = [];
  for (const t in d) {
    const i = d[t];
    i !== ![] && x.push(e(929) + t + " " + i);
  }
  return x[e(3443)](`
`);
}
function vp(d, e) {
  const x = s, t = {}, i = d[x(849)](e, 35721);
  for (let n = 0; n < i; n++) {
    const a = d[x(1557)](e, n), r = a[x(3710)];
    let o = 1;
    a[x(566)] === 35674 && (o = 2), a[x(566)] === 35675 && (o = 3), a[x(566)] === 35676 && (o = 4), t[r] = { type: a[x(566)], location: d[x(1522)](e, r), locationSize: o };
  }
  return t;
}
function En(d) {
  return d !== "";
}
function Do(d, e) {
  const x = s, t = e[x(1391)] + e[x(3232)] - e[x(2247)];
  return d[x(1786)](/NUM_DIR_LIGHTS/g, e[x(2444)])[x(1786)](/NUM_SPOT_LIGHTS/g, e[x(779)])[x(1786)](/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)[x(1786)](/NUM_SPOT_LIGHT_COORDS/g, t)[x(1786)](/NUM_RECT_AREA_LIGHTS/g, e[x(840)]).replace(/NUM_POINT_LIGHTS/g, e[x(2851)])[x(1786)](/NUM_HEMI_LIGHTS/g, e[x(3275)])[x(1786)](/NUM_DIR_LIGHT_SHADOWS/g, e[x(1662)]).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps)[x(1786)](/NUM_SPOT_LIGHT_SHADOWS/g, e[x(1391)])[x(1786)](/NUM_POINT_LIGHT_SHADOWS/g, e[x(1022)]);
}
function Oo(d, e) {
  const x = s;
  return d[x(1786)](/NUM_CLIPPING_PLANES/g, e[x(1037)]).replace(/UNION_CLIPPING_PLANES/g, e[x(1037)] - e[x(1306)]);
}
const yp = /^[ \t]*#include +<([\w\d./]+)>/gm;
function c0(d, e) {
  const x = ba();
  return c0 = function(t, i) {
    return t = t - 422, x[t];
  }, c0(d, e);
}
function s2(d) {
  return d[s(1786)](yp, wp);
}
function wp(d, e) {
  const x = s, t = dx[e];
  if (t === void 0)
    throw new Error(x(3175) + e + ">");
  return s2(t);
}
const Mp = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function No(d) {
  return d[s(1786)](Mp, Sp);
}
function Sp(d, e, x, t) {
  const i = s;
  let n = "";
  for (let a = parseInt(e); a < parseInt(x); a++)
    n += t[i(1786)](/\[\s*i\s*\]/g, "[ " + a + " ]")[i(1786)](/UNROLLED_LOOP_INDEX/g, a);
  return n;
}
function Uo(d) {
  const e = s;
  let x = e(1619) + d[e(537)] + e(3726) + d.precision + e(3498);
  return d[e(537)] === e(994) ? x += e(2397) : d[e(537)] === e(2293) ? x += e(2367) : d[e(537)] === e(791) && (x += e(2220)), x;
}
function Tp(d) {
  const e = s;
  let x = e(873);
  return d[e(998)] === p2 ? x = e(1368) : d.shadowMapType === Xc ? x = "SHADOWMAP_TYPE_PCF_SOFT" : d[e(998)] === Ii && (x = e(2140)), x;
}
function Ep(d) {
  const e = s;
  let x = e(2167);
  if (d[e(1477)])
    switch (d[e(2738)]) {
      case St:
      case Tt:
        x = "ENVMAP_TYPE_CUBE";
        break;
      case Ki:
        x = e(2761);
        break;
    }
  return x;
}
function Ap(d) {
  const e = s;
  let x = e(1900);
  if (d[e(1477)])
    switch (d.envMapMode) {
      case Tt:
        x = e(759);
        break;
    }
  return x;
}
function Cp(d) {
  const e = s;
  let x = e(2018);
  if (d[e(1477)])
    switch (d[e(2997)]) {
      case Wn:
        x = e(2874);
        break;
      case fd:
        x = "ENVMAP_BLENDING_MIX";
        break;
      case ld:
        x = e(2683);
        break;
    }
  return x;
}
function Lp(d) {
  const e = s, x = d.envMapCubeUVHeight;
  if (x === null)
    return null;
  const t = Math[e(3422)](x) - 2, i = 1 / x;
  return { texelWidth: 1 / (3 * Math[e(1803)](Math[e(3196)](2, t), 7 * 16)), texelHeight: i, maxMip: t };
}
function Rp(d, e, x, t) {
  const i = s, n = d[i(3271)](), a = x[i(2264)];
  let r = x.vertexShader, o = x[i(2489)];
  const c = Tp(x), h = Ep(x), f = Ap(x), u = Cp(x), l = Lp(x), _ = x[i(510)] ? "" : gp(x), p = _p(a), m = n[i(1545)]();
  let y, v, g = x.glslVersion ? i(2266) + x[i(3770)] + `
` : "";
  x[i(3704)] ? (y = [p][i(3587)](En)[i(3443)](`
`), y[i(3105)] > 0 && (y += `
`), v = [_, p][i(3587)](En).join(`
`), v.length > 0 && (v += `
`)) : (y = [Uo(x), "#define SHADER_NAME " + x[i(1261)], p, x[i(2177)] ? i(1223) : "", x[i(1893)] ? i(1828) : "", x.supportsVertexTextures ? i(1867) : "", x[i(1487)] && x[i(3438)] ? i(2701) : "", x[i(1487)] && x[i(459)] ? i(2682) : "", x[i(3644)] ? i(1836) : "", x[i(1477)] ? i(3192) : "", x[i(1477)] ? i(929) + f : "", x[i(2399)] ? "#define USE_LIGHTMAP" : "", x.aoMap ? i(2792) : "", x.emissiveMap ? i(2740) : "", x[i(758)] ? i(2511) : "", x[i(811)] ? i(3619) : "", x[i(811)] && x[i(2506)] ? "#define OBJECTSPACE_NORMALMAP" : "", x[i(811)] && x.tangentSpaceNormalMap ? i(711) : "", x.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", x.clearcoatRoughnessMap ? i(861) : "", x[i(3674)] ? i(3419) : "", x.iridescenceMap ? i(3131) : "", x[i(3360)] ? i(2651) : "", x[i(629)] && x[i(1546)] ? "#define USE_DISPLACEMENTMAP" : "", x.specularMap ? i(2540) : "", x.specularIntensityMap ? i(3679) : "", x[i(3637)] ? i(1933) : "", x.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", x[i(989)] ? "#define USE_METALNESSMAP" : "", x.alphaMap ? "#define USE_ALPHAMAP" : "", x[i(2123)] ? i(643) : "", x[i(2325)] ? i(3129) : "", x[i(1051)] ? i(1125) : "", x[i(2078)] ? "#define USE_SHEENCOLORMAP" : "", x[i(3168)] ? i(2047) : "", x.vertexTangents ? "#define USE_TANGENT" : "", x.vertexColors ? i(3340) : "", x.vertexAlphas ? i(3180) : "", x.vertexUvs ? i(2696) : "", x[i(491)] ? "#define UVS_VERTEX_ONLY" : "", x[i(1529)] ? i(3486) : "", x.skinning ? "#define USE_SKINNING" : "", x[i(2461)] ? "#define USE_MORPHTARGETS" : "", x[i(2193)] && x[i(1529)] === ![] ? i(3309) : "", x[i(2103)] && x[i(510)] ? i(1221) : "", x[i(3122)] > 0 && x[i(510)] ? i(2146) : "", x.morphTargetsCount > 0 && x[i(510)] ? i(3652) + x.morphTextureStride : "", x[i(3122)] > 0 && x.isWebGL2 ? i(3181) + x.morphTargetsCount : "", x[i(2481)] ? i(619) : "", x[i(586)] ? "#define FLIP_SIDED" : "", x[i(1605)] ? "#define USE_SHADOWMAP" : "", x[i(1605)] ? "#define " + c : "", x[i(2907)] ? i(1303) : "", x.logarithmicDepthBuffer ? i(2259) : "", x.logarithmicDepthBuffer && x[i(422)] ? i(1764) : "", "uniform mat4 modelMatrix;", i(1984), i(1005), i(2362), i(2458), i(1697), i(1449), i(3713), i(3504), "#endif", i(2116), "	attribute vec3 instanceColor;", "#endif", i(3520), i(1324), i(3537), i(3762), i(3297), "#endif", i(2520), i(1737), "#elif defined( USE_COLOR )", i(2473), i(777), "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", i(2006), "	attribute vec3 morphTarget1;", i(2933), i(2573), i(3550), i(3166), i(2160), i(2379), "		attribute vec3 morphNormal3;", i(1905), i(2838), i(2230), i(620), i(2512), "	#endif", i(777), i(589), i(1432), i(1553), i(777), `
`].filter(En)[i(3443)](`
`), v = [_, Uo(x), i(786) + x.shaderName, p, x[i(1487)] && x.fog ? i(2701) : "", x[i(1487)] && x[i(459)] ? "#define FOG_EXP2" : "", x.map ? i(1836) : "", x.matcap ? "#define USE_MATCAP" : "", x[i(1477)] ? i(3192) : "", x.envMap ? "#define " + h : "", x[i(1477)] ? i(929) + f : "", x[i(1477)] ? i(929) + u : "", l ? i(3466) + l[i(3627)] : "", l ? i(2976) + l[i(1863)] : "", l ? i(2902) + l[i(1569)] + ".0" : "", x.lightMap ? i(1305) : "", x.aoMap ? i(2792) : "", x[i(2730)] ? i(2740) : "", x[i(758)] ? i(2511) : "", x[i(811)] ? "#define USE_NORMALMAP" : "", x[i(811)] && x[i(2506)] ? "#define OBJECTSPACE_NORMALMAP" : "", x[i(811)] && x[i(2144)] ? i(711) : "", x[i(2317)] ? "#define USE_CLEARCOAT" : "", x[i(945)] ? "#define USE_CLEARCOATMAP" : "", x[i(1660)] ? i(861) : "", x[i(3674)] ? i(3419) : "", x[i(3727)] ? i(3731) : "", x[i(2734)] ? "#define USE_IRIDESCENCEMAP" : "", x[i(3360)] ? i(2651) : "", x[i(3470)] ? i(2540) : "", x.specularIntensityMap ? i(3679) : "", x[i(3637)] ? "#define USE_SPECULARCOLORMAP" : "", x[i(3213)] ? "#define USE_ROUGHNESSMAP" : "", x[i(989)] ? i(1469) : "", x[i(1453)] ? i(1190) : "", x[i(3303)] ? i(2534) : "", x[i(1031)] ? i(1817) : "", x.sheenColorMap ? i(1105) : "", x[i(3168)] ? i(2047) : "", x[i(2123)] ? "#define USE_TRANSMISSION" : "", x[i(2325)] ? i(3129) : "", x[i(1051)] ? "#define USE_THICKNESSMAP" : "", x[i(2061)] ? i(483) : "", x.vertexTangents ? i(2707) : "", x[i(3530)] || x.instancingColor ? i(3340) : "", x[i(3451)] ? i(3180) : "", x[i(2152)] ? i(2696) : "", x[i(491)] ? i(3662) : "", x[i(2767)] ? "#define USE_GRADIENTMAP" : "", x.flatShading ? i(3486) : "", x[i(2481)] ? i(619) : "", x[i(586)] ? i(1903) : "", x[i(1605)] ? i(3628) : "", x[i(1605)] ? "#define " + c : "", x.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", x[i(1218)] ? i(1705) : "", x[i(428)] ? i(2259) : "", x[i(428)] && x[i(422)] ? i(1764) : "", i(2362), i(1697), i(1449), x[i(602)] !== We ? i(2634) : "", x.toneMapping !== We ? dx[i(3503)] : "", x.toneMapping !== We ? mp("toneMapping", x.toneMapping) : "", x[i(2995)] ? i(2356) : "", x.opaque ? "#define OPAQUE" : "", dx[i(2965)], pp(i(2037), x[i(3565)]), x.useDepthPacking ? "#define DEPTH_PACKING " + x[i(1039)] : "", `
`][i(3587)](En).join(`
`)), r = s2(r), r = Do(r, x), r = Oo(r, x), o = s2(o), o = Do(o, x), o = Oo(o, x), r = No(r), o = No(o), x[i(510)] && x.isRawShaderMaterial !== !![] && (g = `#version 300 es
`, y = [i(594), i(1153), i(3607), i(3588)][i(3443)](`
`) + `
` + y, v = [i(3693), x.glslVersion === i2 ? "" : i(2805), x[i(3770)] === i2 ? "" : i(3556), "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", i(2354), i(3100), i(3701), i(2491), i(2327), i(2980), "#define texture2DProjGradEXT textureProjGrad", i(1625)].join(`
`) + `
` + v);
  const b = g + y + r, M = g + v + o, A = Po(n, 35633, b), L = Po(n, 35632, M);
  if (n[i(3755)](m, A), n[i(3755)](m, L), x[i(1438)] !== void 0 ? n.bindAttribLocation(m, 0, x[i(1438)]) : x[i(2461)] === !![] && n.bindAttribLocation(m, 0, "position"), n[i(484)](m), d[i(3231)][i(3642)]) {
    const I = n[i(1707)](m)[i(549)](), C = n[i(1686)](A)[i(549)](), G = n[i(1686)](L)[i(549)]();
    let $ = !![], N = !![];
    if (n[i(849)](m, 35714) === ![]) {
      $ = ![];
      const V = Io(n, A, i(1108)), X = Io(n, L, "fragment");
      console[i(533)](i(2300) + n[i(3740)]() + i(1173) + i(969) + n[i(849)](m, 35715) + `

Program Info Log: ` + I + `
` + V + `
` + X);
    } else
      I !== "" ? console[i(3629)](i(3675), I) : (C === "" || G === "") && (N = ![]);
    N && (this[i(1293)] = { runnable: $, programLog: I, vertexShader: { log: C, prefix: y }, fragmentShader: { log: G, prefix: v } });
  }
  n[i(1201)](A), n[i(1201)](L);
  let P;
  this.getUniforms = function() {
    return P === void 0 && (P = new da(n, m)), P;
  };
  let S;
  return this[i(2298)] = function() {
    return S === void 0 && (S = vp(n, m)), S;
  }, this[i(893)] = function() {
    const I = i;
    t[I(3434)](this), n[I(992)](m), this.program = void 0;
  }, this[i(3710)] = x[i(1261)], this.id = lp++, this[i(2180)] = e, this[i(3558)] = 1, this[i(2302)] = m, this.vertexShader = A, this[i(2489)] = L, this;
}
let Pp = 0;
class Ip {
  constructor() {
    const e = s;
    this[e(648)] = /* @__PURE__ */ new Map(), this[e(2292)] = /* @__PURE__ */ new Map();
  }
  [s(3452)](e) {
    const x = s, t = e[x(2377)], i = e[x(2489)], n = this._getShaderStage(t), a = this[x(3219)](i), r = this[x(2186)](e);
    return r.has(n) === ![] && (r[x(3026)](n), n[x(3558)]++), r[x(2086)](a) === ![] && (r[x(3026)](a), a[x(3558)]++), this;
  }
  [s(3137)](e) {
    const x = s, t = this.materialCache[x(3016)](e);
    for (const i of t)
      i[x(3558)]--, i[x(3558)] === 0 && this.shaderCache.delete(i[x(898)]);
    return this[x(2292)][x(2850)](e), this;
  }
  getVertexShaderID(e) {
    return this[s(3219)](e.vertexShader).id;
  }
  [s(513)](e) {
    const x = s;
    return this[x(3219)](e[x(2489)]).id;
  }
  [s(3387)]() {
    const e = s;
    this[e(648)].clear(), this[e(2292)].clear();
  }
  _getShaderCacheForMaterial(e) {
    const x = s, t = this[x(2292)];
    let i = t.get(e);
    return i === void 0 && (i = /* @__PURE__ */ new Set(), t.set(e, i)), i;
  }
  [s(3219)](e) {
    const x = s, t = this[x(648)];
    let i = t[x(3016)](e);
    return i === void 0 && (i = new Dp(e), t[x(1260)](e, i)), i;
  }
}
class Dp {
  constructor(e) {
    const x = s;
    this.id = Pp++, this[x(898)] = e, this[x(3558)] = 0;
  }
}
function Op(d, e, x, t, i, n, a) {
  const r = s, o = new ya(), c = new Ip(), h = [], f = i[r(510)], u = i[r(428)], l = i[r(2237)];
  let _ = i.precision;
  const p = { MeshDepthMaterial: r(3611), MeshDistanceMaterial: r(654), MeshNormalMaterial: r(2111), MeshBasicMaterial: "basic", MeshLambertMaterial: r(2335), MeshPhongMaterial: r(1910), MeshToonMaterial: r(1281), MeshStandardMaterial: r(802), MeshPhysicalMaterial: "physical", MeshMatcapMaterial: r(1247), LineBasicMaterial: "basic", LineDashedMaterial: r(3076), PointsMaterial: "points", ShadowMaterial: r(2145), SpriteMaterial: r(983) };
  function m(S, I, C, G, $) {
    const N = r, V = G.fog, X = $.geometry, n0 = S.isMeshStandardMaterial ? G.environment : null, b0 = (S[N(2589)] ? x : e)[N(3016)](S.envMap || n0), Q = b0 && b0.mapping === Ki ? b0[N(450)][N(1674)] : null, r0 = p[S[N(566)]];
    S[N(537)] !== null && (_ = i[N(2632)](S[N(537)]), _ !== S[N(537)] && console[N(3629)](N(3145), S[N(537)], "not supported, using", _, N(3295)));
    const l0 = X[N(1034)][N(3571)] || X[N(1034)][N(2111)] || X[N(1034)][N(3282)], v0 = l0 !== void 0 ? l0[N(3105)] : 0;
    let s0 = 0;
    X[N(1034)].position !== void 0 && (s0 = 1), X.morphAttributes[N(2111)] !== void 0 && (s0 = 2), X[N(1034)].color !== void 0 && (s0 = 3);
    let q, a0, e0, p0;
    if (r0) {
      const xx = De[r0];
      q = xx.vertexShader, a0 = xx[N(2489)];
    } else
      q = S[N(2377)], a0 = S[N(2489)], c[N(3452)](S), e0 = c[N(761)](S), p0 = c[N(513)](S);
    const y0 = d.getRenderTarget(), L0 = S[N(3303)] > 0, k0 = S[N(2317)] > 0, Q0 = S[N(3727)] > 0;
    return { isWebGL2: f, shaderID: r0, shaderName: S[N(566)], vertexShader: q, fragmentShader: a0, defines: S[N(2264)], customVertexShaderID: e0, customFragmentShaderID: p0, isRawShaderMaterial: S[N(3704)] === !![], glslVersion: S[N(3770)], precision: _, instancing: $[N(2342)] === !![], instancingColor: $[N(2342)] === !![] && $[N(752)] !== null, supportsVertexTextures: l, outputEncoding: y0 === null ? d[N(3565)] : y0[N(2764)] === !![] ? y0.texture[N(523)] : Ne, map: !!S[N(3644)], matcap: !!S[N(1247)], envMap: !!b0, envMapMode: b0 && b0[N(667)], envMapCubeUVHeight: Q, lightMap: !!S.lightMap, aoMap: !!S[N(2107)], emissiveMap: !!S[N(2730)], bumpMap: !!S.bumpMap, normalMap: !!S.normalMap, objectSpaceNormalMap: S[N(920)] === zd, tangentSpaceNormalMap: S[N(920)] === Rt, decodeVideoTexture: !!S[N(3644)] && S[N(3644)][N(2119)] === !![] && S[N(3644)].encoding === _x, clearcoat: k0, clearcoatMap: k0 && !!S[N(945)], clearcoatRoughnessMap: k0 && !!S[N(1660)], clearcoatNormalMap: k0 && !!S[N(3674)], iridescence: Q0, iridescenceMap: Q0 && !!S.iridescenceMap, iridescenceThicknessMap: Q0 && !!S[N(3360)], displacementMap: !!S[N(629)], roughnessMap: !!S[N(3213)], metalnessMap: !!S.metalnessMap, specularMap: !!S[N(3470)], specularIntensityMap: !!S[N(1581)], specularColorMap: !!S.specularColorMap, opaque: S[N(1885)] === ![] && S[N(3019)] === ei, alphaMap: !!S[N(1453)], alphaTest: L0, gradientMap: !!S.gradientMap, sheen: S[N(1031)] > 0, sheenColorMap: !!S[N(2078)], sheenRoughnessMap: !!S.sheenRoughnessMap, transmission: S[N(2123)] > 0, transmissionMap: !!S.transmissionMap, thicknessMap: !!S[N(1051)], combine: S.combine, vertexTangents: !!S[N(811)] && !!X[N(3265)][N(3404)], vertexColors: S.vertexColors, vertexAlphas: S[N(3530)] === !![] && !!X[N(3265)][N(3282)] && X[N(3265)].color.itemSize === 4, vertexUvs: !!S[N(3644)] || !!S[N(758)] || !!S[N(811)] || !!S.specularMap || !!S[N(1453)] || !!S.emissiveMap || !!S.roughnessMap || !!S[N(989)] || !!S[N(945)] || !!S.clearcoatRoughnessMap || !!S.clearcoatNormalMap || !!S[N(2734)] || !!S[N(3360)] || !!S.displacementMap || !!S.transmissionMap || !!S[N(1051)] || !!S[N(1581)] || !!S[N(3637)] || !!S[N(2078)] || !!S.sheenRoughnessMap, uvsVertexOnly: !(S[N(3644)] || S.bumpMap || S[N(811)] || S[N(3470)] || S.alphaMap || S.emissiveMap || S[N(3213)] || S[N(989)] || S[N(3674)] || S[N(2734)] || S[N(3360)] || S[N(2123)] > 0 || S[N(2325)] || S[N(1051)] || S.specularIntensityMap || S.specularColorMap || S[N(1031)] > 0 || S[N(2078)] || S[N(3168)]) && !!S[N(629)], fog: !!V, useFog: S.fog === !![], fogExp2: V && V[N(1003)], flatShading: !!S[N(1529)], sizeAttenuation: S.sizeAttenuation, logarithmicDepthBuffer: u, skinning: $[N(1918)] === !![], morphTargets: X[N(1034)][N(3571)] !== void 0, morphNormals: X[N(1034)][N(2111)] !== void 0, morphColors: X[N(1034)][N(3282)] !== void 0, morphTargetsCount: v0, morphTextureStride: s0, numDirLights: I[N(3705)].length, numPointLights: I[N(1482)][N(3105)], numSpotLights: I[N(1337)][N(3105)], numSpotLightMaps: I[N(2095)][N(3105)], numRectAreaLights: I[N(2364)][N(3105)], numHemiLights: I[N(544)][N(3105)], numDirLightShadows: I[N(2311)][N(3105)], numPointLightShadows: I[N(1871)][N(3105)], numSpotLightShadows: I[N(1864)].length, numSpotLightShadowsWithMaps: I[N(2247)], numClippingPlanes: a.numPlanes, numClipIntersection: a[N(3508)], dithering: S[N(2995)], shadowMapEnabled: d[N(2445)][N(2679)] && C[N(3105)] > 0, shadowMapType: d[N(2445)].type, toneMapping: S.toneMapped ? d.toneMapping : We, useLegacyLights: d[N(1218)], premultipliedAlpha: S[N(624)], doubleSided: S[N(679)] === ke, flipSided: S[N(679)] === re, useDepthPacking: !!S[N(1039)], depthPacking: S[N(1039)] || 0, index0AttributeName: S.index0AttributeName, extensionDerivatives: S[N(3323)] && S[N(3323)].derivatives, extensionFragDepth: S[N(3323)] && S.extensions.fragDepth, extensionDrawBuffers: S[N(3323)] && S.extensions.drawBuffers, extensionShaderTextureLOD: S.extensions && S[N(3323)][N(905)], rendererExtensionFragDepth: f || t[N(2086)](N(955)), rendererExtensionDrawBuffers: f || t[N(2086)](N(2492)), rendererExtensionShaderTextureLod: f || t[N(2086)](N(1837)), customProgramCacheKey: S[N(2082)]() };
  }
  function y(S) {
    const I = r, C = [];
    if (S[I(2743)] ? C[I(3156)](S.shaderID) : (C[I(3156)](S[I(3747)]), C[I(3156)](S[I(1237)])), S.defines !== void 0)
      for (const G in S[I(2264)])
        C.push(G), C[I(3156)](S.defines[G]);
    return S[I(3704)] === ![] && (v(C, S), g(C, S), C[I(3156)](d[I(3565)])), C[I(3156)](S[I(2082)]), C[I(3443)]();
  }
  function v(S, I) {
    const C = r;
    S[C(3156)](I[C(537)]), S[C(3156)](I[C(3565)]), S[C(3156)](I[C(2738)]), S[C(3156)](I.envMapCubeUVHeight), S[C(3156)](I.combine), S[C(3156)](I[C(2152)]), S[C(3156)](I.fogExp2), S.push(I.sizeAttenuation), S.push(I[C(3122)]), S[C(3156)](I[C(621)]), S[C(3156)](I[C(2444)]), S.push(I[C(2851)]), S.push(I[C(779)]), S[C(3156)](I.numSpotLightMaps), S.push(I[C(3275)]), S.push(I[C(840)]), S[C(3156)](I.numDirLightShadows), S[C(3156)](I[C(1022)]), S[C(3156)](I[C(1391)]), S[C(3156)](I[C(2247)]), S[C(3156)](I[C(998)]), S[C(3156)](I[C(602)]), S[C(3156)](I.numClippingPlanes), S[C(3156)](I.numClipIntersection), S[C(3156)](I[C(1039)]);
  }
  function g(S, I) {
    const C = r;
    o.disableAll(), I[C(510)] && o[C(3167)](0), I[C(1546)] && o.enable(1), I.instancing && o[C(3167)](2), I[C(1893)] && o.enable(3), I.map && o[C(3167)](4), I[C(1247)] && o[C(3167)](5), I[C(1477)] && o[C(3167)](6), I.lightMap && o.enable(7), I[C(2107)] && o.enable(8), I[C(2730)] && o.enable(9), I[C(758)] && o[C(3167)](10), I[C(811)] && o[C(3167)](11), I[C(2506)] && o.enable(12), I[C(2144)] && o[C(3167)](13), I[C(2317)] && o[C(3167)](14), I[C(945)] && o.enable(15), I[C(1660)] && o[C(3167)](16), I.clearcoatNormalMap && o.enable(17), I[C(3727)] && o[C(3167)](18), I[C(2734)] && o[C(3167)](19), I[C(3360)] && o[C(3167)](20), I.displacementMap && o.enable(21), I[C(3470)] && o[C(3167)](22), I[C(3213)] && o[C(3167)](23), I.metalnessMap && o[C(3167)](24), I[C(2767)] && o.enable(25), I[C(1453)] && o[C(3167)](26), I.alphaTest && o[C(3167)](27), I[C(3530)] && o[C(3167)](28), I[C(3451)] && o.enable(29), I[C(2152)] && o[C(3167)](30), I[C(3202)] && o[C(3167)](31), I[C(491)] && o[C(3167)](32), S[C(3156)](o.mask), o[C(3254)](), I[C(3438)] && o.enable(0), I[C(1487)] && o[C(3167)](1), I[C(1529)] && o[C(3167)](2), I[C(428)] && o[C(3167)](3), I.skinning && o[C(3167)](4), I[C(2461)] && o[C(3167)](5), I[C(2193)] && o.enable(6), I[C(2103)] && o[C(3167)](7), I[C(624)] && o[C(3167)](8), I[C(1605)] && o[C(3167)](9), I[C(1218)] && o[C(3167)](10), I.doubleSided && o[C(3167)](11), I[C(586)] && o[C(3167)](12), I[C(753)] && o[C(3167)](13), I[C(2995)] && o[C(3167)](14), I[C(1581)] && o[C(3167)](15), I.specularColorMap && o[C(3167)](16), I[C(2123)] && o.enable(17), I[C(2325)] && o[C(3167)](18), I[C(1051)] && o[C(3167)](19), I[C(1031)] && o[C(3167)](20), I[C(2078)] && o[C(3167)](21), I.sheenRoughnessMap && o[C(3167)](22), I[C(2061)] && o.enable(23), I[C(3505)] && o[C(3167)](24), S.push(o.mask);
  }
  function b(S) {
    const I = r, C = p[S[I(566)]];
    let G;
    if (C) {
      const $ = De[C];
      G = zn[I(2272)]($[I(2833)]);
    } else
      G = S[I(2833)];
    return G;
  }
  function M(S, I) {
    const C = r;
    let G;
    for (let $ = 0, N = h[C(3105)]; $ < N; $++) {
      const V = h[$];
      if (V[C(2180)] === I) {
        G = V, ++G[C(3558)];
        break;
      }
    }
    return G === void 0 && (G = new Rp(d, I, S, n), h[C(3156)](G)), G;
  }
  function A(S) {
    const I = r;
    if (--S[I(3558)] === 0) {
      const C = h.indexOf(S);
      h[C] = h[h[I(3105)] - 1], h[I(465)](), S[I(893)]();
    }
  }
  function L(S) {
    c[r(3137)](S);
  }
  function P() {
    c[r(3387)]();
  }
  return { getParameters: m, getProgramCacheKey: y, getUniforms: b, acquireProgram: M, releaseProgram: A, releaseShaderCache: L, programs: h, dispose: P };
}
function Np() {
  let d = /* @__PURE__ */ new WeakMap();
  function e(n) {
    const a = c0;
    let r = d.get(n);
    return r === void 0 && (r = {}, d[a(1260)](n, r)), r;
  }
  function x(n) {
    d.delete(n);
  }
  function t(n, a, r) {
    const o = c0;
    d[o(3016)](n)[a] = r;
  }
  function i() {
    d = /* @__PURE__ */ new WeakMap();
  }
  return { get: e, remove: x, update: t, dispose: i };
}
function Up(d, e) {
  const x = s;
  return d[x(3126)] !== e.groupOrder ? d[x(3126)] - e[x(3126)] : d.renderOrder !== e[x(704)] ? d[x(704)] - e[x(704)] : d[x(1870)].id !== e[x(1870)].id ? d[x(1870)].id - e[x(1870)].id : d.z !== e.z ? d.z - e.z : d.id - e.id;
}
function zo(d, e) {
  const x = s;
  return d[x(3126)] !== e[x(3126)] ? d[x(3126)] - e[x(3126)] : d.renderOrder !== e[x(704)] ? d.renderOrder - e[x(704)] : d.z !== e.z ? e.z - d.z : d.id - e.id;
}
function Bo() {
  const d = [];
  let e = 0;
  const x = [], t = [], i = [];
  function n() {
    const f = c0;
    e = 0, x[f(3105)] = 0, t.length = 0, i[f(3105)] = 0;
  }
  function a(f, u, l, _, p, m) {
    const y = c0;
    let v = d[e];
    return v === void 0 ? (v = { id: f.id, object: f, geometry: u, material: l, groupOrder: _, renderOrder: f[y(704)], z: p, group: m }, d[e] = v) : (v.id = f.id, v[y(1413)] = f, v.geometry = u, v.material = l, v[y(3126)] = _, v[y(704)] = f.renderOrder, v.z = p, v[y(755)] = m), e++, v;
  }
  function r(f, u, l, _, p, m) {
    const y = c0, v = a(f, u, l, _, p, m);
    l[y(2123)] > 0 ? t[y(3156)](v) : l.transparent === !![] ? i[y(3156)](v) : x[y(3156)](v);
  }
  function o(f, u, l, _, p, m) {
    const y = c0, v = a(f, u, l, _, p, m);
    l[y(2123)] > 0 ? t.unshift(v) : l.transparent === !![] ? i.unshift(v) : x[y(2248)](v);
  }
  function c(f, u) {
    const l = c0;
    x[l(3105)] > 1 && x[l(614)](f || Up), t.length > 1 && t[l(614)](u || zo), i[l(3105)] > 1 && i[l(614)](u || zo);
  }
  function h() {
    const f = c0;
    for (let u = e, l = d.length; u < l; u++) {
      const _ = d[u];
      if (_.id === null)
        break;
      _.id = null, _[f(1413)] = null, _[f(1353)] = null, _[f(1870)] = null, _[f(755)] = null;
    }
  }
  return { opaque: x, transmissive: t, transparent: i, init: n, push: r, unshift: o, finish: h, sort: c };
}
function zp() {
  let d = /* @__PURE__ */ new WeakMap();
  function e(t, i) {
    const n = c0, a = d[n(3016)](t);
    let r;
    return a === void 0 ? (r = new Bo(), d[n(1260)](t, [r])) : i >= a.length ? (r = new Bo(), a[n(3156)](r)) : r = a[i], r;
  }
  function x() {
    d = /* @__PURE__ */ new WeakMap();
  }
  return { get: e, dispose: x };
}
function Bp() {
  const d = {};
  return { get: function(e) {
    const x = c0;
    if (d[e.id] !== void 0)
      return d[e.id];
    let t;
    switch (e[x(566)]) {
      case x(1119):
        t = { direction: new z(), color: new P0() };
        break;
      case x(2811):
        t = { position: new z(), direction: new z(), color: new P0(), distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 };
        break;
      case x(3496):
        t = { position: new z(), color: new P0(), distance: 0, decay: 0 };
        break;
      case x(659):
        t = { direction: new z(), skyColor: new P0(), groundColor: new P0() };
        break;
      case x(2472):
        t = { color: new P0(), position: new z(), halfWidth: new z(), halfHeight: new z() };
        break;
    }
    return d[e.id] = t, t;
  } };
}
function Fp() {
  const d = {};
  return { get: function(e) {
    const x = c0;
    if (d[e.id] !== void 0)
      return d[e.id];
    let t;
    switch (e[x(566)]) {
      case x(1119):
        t = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new d0() };
        break;
      case "SpotLight":
        t = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new d0() };
        break;
      case x(3496):
        t = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new d0(), shadowCameraNear: 1, shadowCameraFar: 1e3 };
        break;
    }
    return d[e.id] = t, t;
  } };
}
let Gp = 0;
function Hp(d, e) {
  const x = s;
  return (e[x(2721)] ? 2 : 0) - (d.castShadow ? 2 : 0) + (e[x(3644)] ? 1 : 0) - (d.map ? 1 : 0);
}
function kp(d, e) {
  const x = s, t = new Bp(), i = Fp(), n = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1, numSpotMaps: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotLightMap: [], spotShadow: [], spotShadowMap: [], spotLightMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [], numSpotLightShadowsWithMaps: 0 };
  for (let f = 0; f < 9; f++)
    n[x(1212)][x(3156)](new z());
  const a = new z(), r = new ix(), o = new ix();
  function c(f, u) {
    const l = x;
    let _ = 0, p = 0, m = 0;
    for (let $ = 0; $ < 9; $++)
      n[l(1212)][$][l(1260)](0, 0, 0);
    let y = 0, v = 0, g = 0, b = 0, M = 0, A = 0, L = 0, P = 0, S = 0, I = 0;
    f.sort(Hp);
    const C = u === !![] ? Math.PI : 1;
    for (let $ = 0, N = f[l(3105)]; $ < N; $++) {
      const V = f[$], X = V[l(3282)], n0 = V[l(1798)], b0 = V[l(1183)], Q = V[l(2145)] && V[l(2145)][l(3644)] ? V.shadow[l(3644)][l(2431)] : null;
      if (V[l(468)])
        _ += X.r * n0 * C, p += X.g * n0 * C, m += X.b * n0 * C;
      else if (V[l(1251)])
        for (let r0 = 0; r0 < 9; r0++)
          n[l(1212)][r0].addScaledVector(V.sh.coefficients[r0], n0);
      else if (V[l(2537)]) {
        const r0 = t[l(3016)](V);
        if (r0[l(3282)][l(2875)](V[l(3282)]).multiplyScalar(V[l(1798)] * C), V.castShadow) {
          const l0 = V[l(2145)], v0 = i[l(3016)](V);
          v0[l(3330)] = l0[l(638)], v0[l(906)] = l0[l(3094)], v0[l(3299)] = l0[l(1232)], v0[l(2280)] = l0.mapSize, n[l(1133)][y] = v0, n[l(2311)][y] = Q, n[l(634)][y] = V[l(2145)][l(1067)], A++;
        }
        n.directional[y] = r0, y++;
      } else if (V[l(2183)]) {
        const r0 = t.get(V);
        r0.position[l(683)](V[l(490)]), r0[l(3282)].copy(X)[l(580)](n0 * C), r0.distance = b0, r0[l(1485)] = Math[l(2063)](V[l(2202)]), r0[l(3469)] = Math[l(2063)](V.angle * (1 - V[l(2276)])), r0[l(3411)] = V.decay, n[l(1337)][g] = r0;
        const l0 = V[l(2145)];
        if (V[l(3644)] && (n[l(2095)][S] = V[l(3644)], S++, l0.updateMatrices(V), V.castShadow && I++), n[l(1982)][g] = l0[l(1067)], V.castShadow) {
          const v0 = i.get(V);
          v0[l(3330)] = l0[l(638)], v0[l(906)] = l0[l(3094)], v0[l(3299)] = l0[l(1232)], v0[l(2280)] = l0[l(1969)], n[l(2532)][g] = v0, n[l(1864)][g] = Q, P++;
        }
        g++;
      } else if (V[l(1027)]) {
        const r0 = t[l(3016)](V);
        r0[l(3282)][l(2875)](X)[l(580)](n0), r0.halfWidth[l(1260)](V.width * 0.5, 0, 0), r0[l(1431)][l(1260)](0, V[l(1674)] * 0.5, 0), n[l(2364)][b] = r0, b++;
      } else if (V[l(3266)]) {
        const r0 = t.get(V);
        if (r0[l(3282)][l(2875)](V.color)[l(580)](V[l(1798)] * C), r0[l(1183)] = V[l(1183)], r0[l(3411)] = V[l(3411)], V[l(2721)]) {
          const l0 = V.shadow, v0 = i[l(3016)](V);
          v0[l(3330)] = l0[l(638)], v0.shadowNormalBias = l0.normalBias, v0.shadowRadius = l0.radius, v0[l(2280)] = l0[l(1969)], v0.shadowCameraNear = l0[l(2189)][l(1448)], v0[l(1488)] = l0[l(2189)][l(3691)], n.pointShadow[v] = v0, n.pointShadowMap[v] = Q, n[l(653)][v] = V.shadow[l(1067)], L++;
        }
        n[l(1482)][v] = r0, v++;
      } else if (V[l(1332)]) {
        const r0 = t[l(3016)](V);
        r0.skyColor.copy(V[l(3282)])[l(580)](n0 * C), r0[l(2035)].copy(V[l(2035)])[l(580)](n0 * C), n[l(544)][M] = r0, M++;
      }
    }
    b > 0 && (e[l(510)] || d[l(2086)](l(547)) === !![] ? (n.rectAreaLTC1 = I0[l(3005)], n[l(1229)] = I0[l(1889)]) : d.has(l(740)) === !![] ? (n[l(2785)] = I0[l(1954)], n[l(1229)] = I0[l(824)]) : console[l(533)](l(749))), n[l(2800)][0] = _, n[l(2800)][1] = p, n[l(2800)][2] = m;
    const G = n[l(2543)];
    (G[l(2736)] !== y || G[l(2029)] !== v || G.spotLength !== g || G.rectAreaLength !== b || G[l(944)] !== M || G[l(921)] !== A || G[l(1702)] !== L || G[l(2256)] !== P || G.numSpotMaps !== S) && (n[l(3705)][l(3105)] = y, n[l(1337)][l(3105)] = g, n.rectArea[l(3105)] = b, n[l(1482)].length = v, n[l(544)][l(3105)] = M, n[l(1133)][l(3105)] = A, n[l(2311)].length = A, n[l(536)][l(3105)] = L, n[l(1871)].length = L, n[l(2532)].length = P, n[l(1864)][l(3105)] = P, n.directionalShadowMatrix[l(3105)] = A, n.pointShadowMatrix[l(3105)] = L, n[l(1982)].length = P + S - I, n[l(2095)].length = S, n.numSpotLightShadowsWithMaps = I, G[l(2736)] = y, G.pointLength = v, G.spotLength = g, G[l(3771)] = b, G[l(944)] = M, G[l(921)] = A, G[l(1702)] = L, G[l(2256)] = P, G[l(1472)] = S, n[l(2185)] = Gp++);
  }
  function h(f, u) {
    const l = x;
    let _ = 0, p = 0, m = 0, y = 0, v = 0;
    const g = u.matrixWorldInverse;
    for (let b = 0, M = f[l(3105)]; b < M; b++) {
      const A = f[b];
      if (A[l(2537)]) {
        const L = n.directional[_];
        L[l(2847)][l(683)](A[l(490)]), a.setFromMatrixPosition(A.target[l(490)]), L.direction.sub(a), L[l(2847)][l(1657)](g), _++;
      } else if (A[l(2183)]) {
        const L = n.spot[m];
        L[l(3571)][l(683)](A[l(490)]), L.position[l(2442)](g), L.direction[l(683)](A.matrixWorld), a[l(683)](A[l(671)][l(490)]), L[l(2847)][l(1943)](a), L[l(2847)].transformDirection(g), m++;
      } else if (A.isRectAreaLight) {
        const L = n.rectArea[y];
        L[l(3571)][l(683)](A[l(490)]), L[l(3571)][l(2442)](g), o[l(836)](), r.copy(A[l(490)]), r[l(3272)](g), o[l(524)](r), L.halfWidth.set(A[l(1631)] * 0.5, 0, 0), L.halfHeight[l(1260)](0, A[l(1674)] * 0.5, 0), L[l(903)][l(2442)](o), L[l(1431)][l(2442)](o), y++;
      } else if (A.isPointLight) {
        const L = n[l(1482)][p];
        L[l(3571)][l(683)](A[l(490)]), L.position.applyMatrix4(g), p++;
      } else if (A[l(1332)]) {
        const L = n.hemi[v];
        L.direction[l(683)](A[l(490)]), L[l(2847)].transformDirection(g), v++;
      }
    }
  }
  return { setup: c, setupView: h, state: n };
}
function Fo(d, e) {
  const x = new kp(d, e), t = [], i = [];
  function n() {
    const f = c0;
    t[f(3105)] = 0, i.length = 0;
  }
  function a(f) {
    t[c0(3156)](f);
  }
  function r(f) {
    i[c0(3156)](f);
  }
  function o(f) {
    x[c0(598)](t, f);
  }
  function c(f) {
    x.setupView(t, f);
  }
  return { init: n, state: { lightsArray: t, shadowsArray: i, lights: x }, setupLights: o, setupLightsView: c, pushLight: a, pushShadow: r };
}
function Vp(d, e) {
  let x = /* @__PURE__ */ new WeakMap();
  function t(n, a = 0) {
    const r = c0, o = x.get(n);
    let c;
    return o === void 0 ? (c = new Fo(d, e), x[r(1260)](n, [c])) : a >= o[r(3105)] ? (c = new Fo(d, e), o[r(3156)](c)) : c = o[a], c;
  }
  function i() {
    x = /* @__PURE__ */ new WeakMap();
  }
  return { get: t, dispose: i };
}
class I2 extends jx {
  constructor(e) {
    const x = s;
    super(), this[x(2043)] = !![], this[x(566)] = x(1072), this[x(1039)] = Nd, this.map = null, this.alphaMap = null, this.displacementMap = null, this[x(2693)] = 1, this[x(498)] = 0, this[x(1124)] = ![], this[x(977)] = 1, this[x(1104)](e);
  }
  [s(2875)](e) {
    const x = s;
    return super[x(2875)](e), this[x(1039)] = e[x(1039)], this.map = e[x(3644)], this[x(1453)] = e[x(1453)], this[x(629)] = e[x(629)], this[x(2693)] = e[x(2693)], this[x(498)] = e[x(498)], this[x(1124)] = e.wireframe, this.wireframeLinewidth = e[x(977)], this;
  }
}
class D2 extends jx {
  constructor(e) {
    const x = s;
    super(), this[x(2244)] = !![], this[x(566)] = "MeshDistanceMaterial", this[x(1115)] = new z(), this[x(1225)] = 1, this.farDistance = 1e3, this.map = null, this[x(1453)] = null, this[x(629)] = null, this[x(2693)] = 1, this[x(498)] = 0, this[x(1104)](e);
  }
  [s(2875)](e) {
    const x = s;
    return super[x(2875)](e), this.referencePosition[x(2875)](e[x(1115)]), this[x(1225)] = e.nearDistance, this[x(1492)] = e[x(1492)], this[x(3644)] = e[x(3644)], this[x(1453)] = e[x(1453)], this[x(629)] = e.displacementMap, this[x(2693)] = e.displacementScale, this[x(498)] = e[x(498)], this;
  }
}
const Wp = s(2268), jp = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function Xp(d, e, x) {
  const t = s;
  let i = new Ma();
  const n = new d0(), a = new d0(), r = new Mx(), o = new I2({ depthPacking: Ud }), c = new D2(), h = {}, f = x.maxTextureSize, u = { [Xe]: re, [re]: Xe, [ke]: ke }, l = new ee({ defines: { VSM_SAMPLES: 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new d0() }, radius: { value: 4 } }, vertexShader: Wp, fragmentShader: jp }), _ = l[t(2272)]();
  _[t(2264)][t(1627)] = 1;
  const p = new ox();
  p.setAttribute("position", new gx(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
  const m = new Wx(p, l), y = this;
  this.enabled = ![], this.autoUpdate = !![], this[t(3035)] = ![], this[t(566)] = p2, this.render = function(M, A, L) {
    const P = t;
    if (y[P(2679)] === ![] || y[P(1012)] === ![] && y.needsUpdate === ![] || M.length === 0)
      return;
    const S = d[P(427)](), I = d[P(2869)](), C = d[P(1436)](), G = d[P(739)];
    G.setBlending(Ve), G[P(2563)][P(3282)][P(2139)](1, 1, 1, 1), G[P(2563)][P(3611)][P(2942)](!![]), G.setScissorTest(![]);
    for (let $ = 0, N = M[P(3105)]; $ < N; $++) {
      const V = M[$], X = V[P(2145)];
      if (X === void 0) {
        console[P(3629)](P(2389), V, "has no shadow.");
        continue;
      }
      if (X.autoUpdate === ![] && X[P(3035)] === ![])
        continue;
      n[P(2875)](X.mapSize);
      const n0 = X.getFrameExtents();
      if (n[P(2246)](n0), a[P(2875)](X[P(1969)]), (n.x > f || n.y > f) && (n.x > f && (a.x = Math[P(2697)](f / n0.x), n.x = a.x * n0.x, X[P(1969)].x = a.x), n.y > f && (a.y = Math[P(2697)](f / n0.y), n.y = a.y * n0.y, X[P(1969)].y = a.y)), X.map === null) {
        const Q = this[P(566)] !== Ii ? { minFilter: Bx, magFilter: Bx } : {};
        X[P(3644)] = new oe(n.x, n.y, Q), X.map[P(2431)][P(3710)] = V[P(3710)] + ".shadowMap", X[P(2189)][P(1701)]();
      }
      d.setRenderTarget(X.map), d[P(1089)]();
      const b0 = X[P(1178)]();
      for (let Q = 0; Q < b0; Q++) {
        const r0 = X.getViewport(Q);
        r[P(1260)](a.x * r0.x, a.y * r0.y, a.x * r0.z, a.y * r0.w), G.viewport(r), X[P(1110)](V, Q), i = X[P(2917)](), b(A, L, X[P(2189)], V, this[P(566)]);
      }
      X[P(2955)] !== !![] && this.type === Ii && v(X, L), X[P(3035)] = ![];
    }
    y[P(3035)] = ![], d[P(2969)](S, I, C);
  };
  function v(M, A) {
    const L = t, P = e.update(m);
    l[L(2264)].VSM_SAMPLES !== M[L(1174)] && (l[L(2264)][L(1724)] = M[L(1174)], _[L(2264)][L(1724)] = M.blurSamples, l[L(3035)] = !![], _.needsUpdate = !![]), M[L(1695)] === null && (M[L(1695)] = new oe(n.x, n.y)), l.uniforms.shadow_pass[L(1811)] = M[L(3644)][L(2431)], l[L(2833)][L(613)][L(1811)] = M.mapSize, l.uniforms.radius.value = M[L(1232)], d[L(2969)](M[L(1695)]), d[L(1089)](), d[L(979)](A, null, P, l, m, null), _[L(2833)][L(606)][L(1811)] = M[L(1695)][L(2431)], _[L(2833)][L(613)].value = M.mapSize, _[L(2833)][L(1232)].value = M.radius, d[L(2969)](M[L(3644)]), d[L(1089)](), d[L(979)](A, null, P, _, m, null);
  }
  function g(M, A, L, P, S, I) {
    const C = t;
    let G = null;
    const $ = L[C(3266)] === !![] ? M[C(1455)] : M[C(1699)];
    if ($ !== void 0)
      G = $;
    else if (G = L[C(3266)] === !![] ? c : o, d[C(2575)] && A.clipShadows === !![] && Array[C(1609)](A[C(2617)]) && A[C(2617)].length !== 0 || A[C(629)] && A[C(2693)] !== 0 || A[C(1453)] && A[C(3303)] > 0 || A[C(3644)] && A.alphaTest > 0) {
      const N = G.uuid, V = A.uuid;
      let X = h[N];
      X === void 0 && (X = {}, h[N] = X);
      let n0 = X[V];
      n0 === void 0 && (n0 = G[C(2272)](), X[V] = n0), G = n0;
    }
    return G[C(2456)] = A[C(2456)], G[C(1124)] = A[C(1124)], I === Ii ? G[C(679)] = A[C(988)] !== null ? A[C(988)] : A[C(679)] : G.side = A[C(988)] !== null ? A[C(988)] : u[A[C(679)]], G[C(1453)] = A[C(1453)], G[C(3303)] = A.alphaTest, G[C(3644)] = A[C(3644)], G[C(1467)] = A[C(1467)], G[C(2617)] = A[C(2617)], G[C(1402)] = A[C(1402)], G.displacementMap = A[C(629)], G[C(2693)] = A.displacementScale, G[C(498)] = A[C(498)], G[C(977)] = A[C(977)], G[C(2968)] = A[C(2968)], L[C(3266)] === !![] && G[C(2244)] === !![] && (G[C(1115)][C(683)](L[C(490)]), G.nearDistance = P, G[C(1492)] = S), G;
  }
  function b(M, A, L, P, S) {
    const I = t;
    if (M[I(2456)] === ![])
      return;
    if (M[I(479)][I(1081)](A[I(479)]) && (M[I(3464)] || M[I(725)] || M.isPoints) && (M[I(2721)] || M[I(1719)] && S === Ii) && (!M[I(3431)] || i[I(1259)](M))) {
      M[I(2762)][I(3117)](L.matrixWorldInverse, M.matrixWorld);
      const $ = e[I(3452)](M), N = M.material;
      if (Array.isArray(N)) {
        const V = $[I(2751)];
        for (let X = 0, n0 = V.length; X < n0; X++) {
          const b0 = V[X], Q = N[b0.materialIndex];
          if (Q && Q.visible) {
            const r0 = g(M, Q, P, L[I(1448)], L.far, S);
            d.renderBufferDirect(L, null, $, r0, M, b0);
          }
        }
      } else if (N[I(2456)]) {
        const V = g(M, N, P, L[I(1448)], L[I(3691)], S);
        d[I(979)](L, null, $, V, M, null);
      }
    }
    const G = M[I(3049)];
    for (let $ = 0, N = G[I(3105)]; $ < N; $++)
      b(G[$], A, L, P, S);
  }
}
function qp(d, e, x) {
  const t = s, i = x[t(510)];
  function n() {
    let k = ![];
    const x0 = new Mx();
    let t0 = null;
    const A0 = new Mx(0, 0, 0, 0);
    return { setMask: function(w0) {
      t0 !== w0 && !k && (d[c0(785)](w0, w0, w0, w0), t0 = w0);
    }, setLocked: function(w0) {
      k = w0;
    }, setClear: function(w0, ax, Ex, kx, Px) {
      const Sx = c0;
      Px === !![] && (w0 *= kx, ax *= kx, Ex *= kx), x0[Sx(1260)](w0, ax, Ex, kx), A0[Sx(2828)](x0) === ![] && (d[Sx(2557)](w0, ax, Ex, kx), A0[Sx(2875)](x0));
    }, reset: function() {
      k = ![], t0 = null, A0.set(-1, 0, 0, 0);
    } };
  }
  function a() {
    let k = ![], x0 = null, t0 = null, A0 = null;
    return { setTest: function(w0) {
      w0 ? y0(2929) : L0(2929);
    }, setMask: function(w0) {
      x0 !== w0 && !k && (d[c0(3047)](w0), x0 = w0);
    }, setFunc: function(w0) {
      const ax = c0;
      if (t0 !== w0) {
        switch (w0) {
          case sd:
            d[ax(1844)](512);
            break;
          case ad:
            d[ax(1844)](519);
            break;
          case rd:
            d[ax(1844)](513);
            break;
          case fa:
            d[ax(1844)](515);
            break;
          case od:
            d[ax(1844)](514);
            break;
          case cd:
            d[ax(1844)](518);
            break;
          case dd:
            d[ax(1844)](516);
            break;
          case hd:
            d.depthFunc(517);
            break;
          default:
            d[ax(1844)](515);
        }
        t0 = w0;
      }
    }, setLocked: function(w0) {
      k = w0;
    }, setClear: function(w0) {
      A0 !== w0 && (d[c0(564)](w0), A0 = w0);
    }, reset: function() {
      k = ![], x0 = null, t0 = null, A0 = null;
    } };
  }
  function r() {
    let k = ![], x0 = null, t0 = null, A0 = null, w0 = null, ax = null, Ex = null, kx = null, Px = null;
    return { setTest: function(Sx) {
      !k && (Sx ? y0(2960) : L0(2960));
    }, setMask: function(Sx) {
      x0 !== Sx && !k && (d.stencilMask(Sx), x0 = Sx);
    }, setFunc: function(Sx, ie, we) {
      (t0 !== Sx || A0 !== ie || w0 !== we) && (d[c0(650)](Sx, ie, we), t0 = Sx, A0 = ie, w0 = we);
    }, setOp: function(Sx, ie, we) {
      (ax !== Sx || Ex !== ie || kx !== we) && (d[c0(2940)](Sx, ie, we), ax = Sx, Ex = ie, kx = we);
    }, setLocked: function(Sx) {
      k = Sx;
    }, setClear: function(Sx) {
      Px !== Sx && (d[c0(2901)](Sx), Px = Sx);
    }, reset: function() {
      k = ![], x0 = null, t0 = null, A0 = null, w0 = null, ax = null, Ex = null, kx = null, Px = null;
    } };
  }
  const o = new n(), c = new a(), h = new r(), f = /* @__PURE__ */ new WeakMap(), u = /* @__PURE__ */ new WeakMap();
  let l = {}, _ = {}, p = /* @__PURE__ */ new WeakMap(), m = [], y = null, v = ![], g = null, b = null, M = null, A = null, L = null, P = null, S = null, I = ![], C = null, G = null, $ = null, N = null, V = null;
  const X = d.getParameter(35661);
  let n0 = ![], b0 = 0;
  const Q = d[t(3516)](7938);
  Q[t(882)](t(2118)) !== -1 ? (b0 = parseFloat(/^WebGL (\d)/[t(625)](Q)[1]), n0 = b0 >= 1) : Q[t(882)](t(2084)) !== -1 && (b0 = parseFloat(/^OpenGL ES (\d)/.exec(Q)[1]), n0 = b0 >= 2);
  let r0 = null, l0 = {};
  const v0 = d.getParameter(3088), s0 = d[t(3516)](2978), q = new Mx()[t(666)](v0), a0 = new Mx()[t(666)](s0);
  function e0(k, x0, t0) {
    const A0 = t, w0 = new Uint8Array(4), ax = d[A0(3152)]();
    d.bindTexture(k, ax), d[A0(830)](k, 10241, 9728), d[A0(830)](k, 10240, 9728);
    for (let Ex = 0; Ex < t0; Ex++)
      d[A0(1774)](x0 + Ex, 0, 6408, 1, 1, 0, 6408, 5121, w0);
    return ax;
  }
  const p0 = {};
  p0[3553] = e0(3553, 3553, 1), p0[34067] = e0(34067, 34069, 6), o.setClear(0, 0, 0, 1), c[t(2139)](1), h[t(2139)](0), y0(2929), c.setFunc(fa), D0(![]), N0(Lr), y0(2884), E0(Ve);
  function y0(k) {
    const x0 = t;
    l[k] !== !![] && (d[x0(3167)](k), l[k] = !![]);
  }
  function L0(k) {
    l[k] !== ![] && (d.disable(k), l[k] = ![]);
  }
  function k0(k, x0) {
    return _[k] !== x0 ? (d.bindFramebuffer(k, x0), _[k] = x0, i && (k === 36009 && (_[36160] = x0), k === 36160 && (_[36009] = x0)), !![]) : ![];
  }
  function Q0(k, x0) {
    const t0 = t;
    let A0 = m, w0 = ![];
    if (k)
      if (A0 = p[t0(3016)](x0), A0 === void 0 && (A0 = [], p[t0(1260)](x0, A0)), k[t0(3230)]) {
        const ax = k.texture;
        if (A0[t0(3105)] !== ax[t0(3105)] || A0[0] !== 36064) {
          for (let Ex = 0, kx = ax[t0(3105)]; Ex < kx; Ex++)
            A0[Ex] = 36064 + Ex;
          A0[t0(3105)] = ax[t0(3105)], w0 = !![];
        }
      } else
        A0[0] !== 36064 && (A0[0] = 36064, w0 = !![]);
    else
      A0[0] !== 1029 && (A0[0] = 1029, w0 = !![]);
    w0 && (x[t0(510)] ? d[t0(1563)](A0) : e[t0(3016)](t0(2492))[t0(1896)](A0));
  }
  function U0(k) {
    const x0 = t;
    return y !== k ? (d[x0(2022)](k), y = k, !![]) : ![];
  }
  const xx = { [jt]: 32774, [Yc]: 32778, [Zc]: 32779 };
  if (i)
    xx[Ir] = 32775, xx[Dr] = 32776;
  else {
    const k = e[t(3016)](t(3209));
    k !== null && (xx[Ir] = k[t(1087)], xx[Dr] = k[t(3527)]);
  }
  const _0 = { [Kc]: 0, [$c]: 1, [Jc]: 768, [m2]: 770, [nd]: 776, [td]: 774, [xd]: 772, [Qc]: 769, [g2]: 771, [id]: 775, [ed]: 773 };
  function E0(k, x0, t0, A0, w0, ax, Ex, kx) {
    const Px = t;
    if (k === Ve) {
      v === !![] && (L0(3042), v = ![]);
      return;
    }
    if (v === ![] && (y0(3042), v = !![]), k !== qc) {
      if (k !== g || kx !== I) {
        if ((b !== jt || L !== jt) && (d.blendEquation(32774), b = jt, L = jt), kx)
          switch (k) {
            case ei:
              d[Px(2127)](1, 771, 1, 771);
              break;
            case ha:
              d.blendFunc(1, 1);
              break;
            case Rr:
              d[Px(2127)](0, 769, 0, 1);
              break;
            case Pr:
              d[Px(2127)](0, 768, 0, 770);
              break;
            default:
              console[Px(533)](Px(1024), k);
              break;
          }
        else
          switch (k) {
            case ei:
              d[Px(2127)](770, 771, 1, 771);
              break;
            case ha:
              d.blendFunc(770, 1);
              break;
            case Rr:
              d[Px(2127)](0, 769, 0, 1);
              break;
            case Pr:
              d.blendFunc(0, 768);
              break;
            default:
              console[Px(533)](Px(1024), k);
              break;
          }
        M = null, A = null, P = null, S = null, g = k, I = kx;
      }
      return;
    }
    w0 = w0 || x0, ax = ax || t0, Ex = Ex || A0, (x0 !== b || w0 !== L) && (d[Px(930)](xx[x0], xx[w0]), b = x0, L = w0), (t0 !== M || A0 !== A || ax !== P || Ex !== S) && (d[Px(2127)](_0[t0], _0[A0], _0[ax], _0[Ex]), M = t0, A = A0, P = ax, S = Ex), g = k, I = ![];
  }
  function O0(k, x0) {
    const t0 = t;
    k.side === ke ? L0(2884) : y0(2884);
    let A0 = k.side === re;
    x0 && (A0 = !A0), D0(A0), k[t0(3019)] === ei && k[t0(1885)] === ![] ? E0(Ve) : E0(k[t0(3019)], k[t0(2404)], k[t0(3260)], k[t0(1338)], k[t0(1556)], k.blendSrcAlpha, k[t0(2619)], k[t0(624)]), c[t0(562)](k[t0(1844)]), c[t0(2942)](k[t0(770)]), c[t0(926)](k[t0(3307)]), o[t0(926)](k[t0(860)]);
    const w0 = k.stencilWrite;
    h[t0(2942)](w0), w0 && (h.setMask(k.stencilWriteMask), h[t0(562)](k[t0(650)], k[t0(1532)], k[t0(2143)]), h[t0(2196)](k[t0(1832)], k.stencilZFail, k.stencilZPass)), X0(k[t0(2455)], k[t0(2914)], k[t0(911)]), k.alphaToCoverage === !![] ? y0(32926) : L0(32926);
  }
  function D0(k) {
    C !== k && (k ? d.frontFace(2304) : d[t(1723)](2305), C = k);
  }
  function N0(k) {
    const x0 = t;
    k !== Wc ? (y0(2884), k !== G && (k === Lr ? d.cullFace(1029) : k === jc ? d.cullFace(1028) : d[x0(1637)](1032))) : L0(2884), G = k;
  }
  function B0(k) {
    k !== $ && (n0 && d[t(605)](k), $ = k);
  }
  function X0(k, x0, t0) {
    k ? (y0(32823), (N !== x0 || V !== t0) && (d.polygonOffset(x0, t0), N = x0, V = t0)) : L0(32823);
  }
  function fx(k) {
    k ? y0(3089) : L0(3089);
  }
  function vx(k) {
    const x0 = t;
    k === void 0 && (k = 33984 + X - 1), r0 !== k && (d[x0(570)](k), r0 = k);
  }
  function B(k, x0, t0) {
    const A0 = t;
    t0 === void 0 && (r0 === null ? t0 = 33984 + X - 1 : t0 = r0);
    let w0 = l0[t0];
    w0 === void 0 && (w0 = { type: void 0, texture: void 0 }, l0[t0] = w0), (w0[A0(566)] !== k || w0[A0(2431)] !== x0) && (r0 !== t0 && (d.activeTexture(t0), r0 = t0), d.bindTexture(k, x0 || p0[k]), w0.type = k, w0.texture = x0);
  }
  function E() {
    const k = t, x0 = l0[r0];
    x0 !== void 0 && x0[k(566)] !== void 0 && (d[k(708)](x0[k(566)], null), x0.type = void 0, x0[k(2431)] = void 0);
  }
  function j() {
    const k = t;
    try {
      d[k(1002)].apply(d, arguments);
    } catch (x0) {
      console[k(533)](k(1321), x0);
    }
  }
  function R() {
    const k = t;
    try {
      d[k(1666)][k(555)](d, arguments);
    } catch (x0) {
      console.error(k(1321), x0);
    }
  }
  function h0() {
    const k = t;
    try {
      d[k(1282)][k(555)](d, arguments);
    } catch (x0) {
      console[k(533)](k(1321), x0);
    }
  }
  function S0() {
    const k = t;
    try {
      d[k(3543)][k(555)](d, arguments);
    } catch (x0) {
      console[k(533)](k(1321), x0);
    }
  }
  function R0() {
    const k = t;
    try {
      d[k(1777)][k(555)](d, arguments);
    } catch (x0) {
      console[k(533)]("THREE.WebGLState:", x0);
    }
  }
  function Z0() {
    const k = t;
    try {
      d[k(3661)][k(555)](d, arguments);
    } catch (x0) {
      console[k(533)](k(1321), x0);
    }
  }
  function H0() {
    const k = t;
    try {
      d[k(1914)].apply(d, arguments);
    } catch (x0) {
      console[k(533)](k(1321), x0);
    }
  }
  function u0() {
    const k = t;
    try {
      d.texStorage3D[k(555)](d, arguments);
    } catch (x0) {
      console[k(533)](k(1321), x0);
    }
  }
  function V0() {
    const k = t;
    try {
      d.texImage2D[k(555)](d, arguments);
    } catch (x0) {
      console[k(533)](k(1321), x0);
    }
  }
  function K0() {
    const k = t;
    try {
      d[k(1592)][k(555)](d, arguments);
    } catch (x0) {
      console.error("THREE.WebGLState:", x0);
    }
  }
  function j0(k) {
    const x0 = t;
    q[x0(2828)](k) === ![] && (d[x0(1833)](k.x, k.y, k.z, k.w), q.copy(k));
  }
  function $0(k) {
    const x0 = t;
    a0.equals(k) === ![] && (d[x0(2483)](k.x, k.y, k.z, k.w), a0.copy(k));
  }
  function Y0(k, x0) {
    const t0 = t;
    let A0 = u.get(x0);
    A0 === void 0 && (A0 = /* @__PURE__ */ new WeakMap(), u.set(x0, A0));
    let w0 = A0[t0(3016)](k);
    w0 === void 0 && (w0 = d.getUniformBlockIndex(x0, k[t0(3710)]), A0[t0(1260)](k, w0));
  }
  function sx(k, x0) {
    const t0 = t, A0 = u.get(x0), w0 = A0[t0(3016)](k);
    f[t0(3016)](x0) !== w0 && (d[t0(3633)](x0, w0, k[t0(3391)]), f.set(x0, w0));
  }
  function cx() {
    const k = t;
    d[k(1503)](3042), d[k(1503)](2884), d.disable(2929), d[k(1503)](32823), d[k(1503)](3089), d[k(1503)](2960), d.disable(32926), d[k(2404)](32774), d[k(588)](1, 0), d[k(2127)](1, 0, 1, 0), d[k(785)](!![], !![], !![], !![]), d.clearColor(0, 0, 0, 0), d[k(3047)](!![]), d.depthFunc(513), d[k(564)](1), d[k(2586)](4294967295), d.stencilFunc(519, 0, 4294967295), d[k(2940)](7680, 7680, 7680), d[k(2901)](0), d[k(1637)](1029), d[k(1723)](2305), d[k(2455)](0, 0), d[k(570)](33984), d[k(3781)](36160, null), i === !![] && (d.bindFramebuffer(36009, null), d[k(3781)](36008, null)), d[k(2022)](null), d[k(605)](1), d.scissor(0, 0, d.canvas[k(1631)], d.canvas[k(1674)]), d[k(2483)](0, 0, d[k(651)].width, d[k(651)].height), l = {}, r0 = null, l0 = {}, _ = {}, p = /* @__PURE__ */ new WeakMap(), m = [], y = null, v = ![], g = null, b = null, M = null, A = null, L = null, P = null, S = null, I = ![], C = null, G = null, $ = null, N = null, V = null, q[k(1260)](0, 0, d[k(651)][k(1631)], d[k(651)][k(1674)]), a0[k(1260)](0, 0, d[k(651)][k(1631)], d[k(651)][k(1674)]), o[k(2007)](), c.reset(), h[k(2007)]();
  }
  return { buffers: { color: o, depth: c, stencil: h }, enable: y0, disable: L0, bindFramebuffer: k0, drawBuffers: Q0, useProgram: U0, setBlending: E0, setMaterial: O0, setFlipSided: D0, setCullFace: N0, setLineWidth: B0, setPolygonOffset: X0, setScissorTest: fx, activeTexture: vx, bindTexture: B, unbindTexture: E, compressedTexImage2D: j, compressedTexImage3D: R, texImage2D: V0, texImage3D: K0, updateUBOMapping: Y0, uniformBlockBinding: sx, texStorage2D: H0, texStorage3D: u0, texSubImage2D: h0, texSubImage3D: S0, compressedTexSubImage2D: R0, compressedTexSubImage3D: Z0, scissor: j0, viewport: $0, reset: cx };
}
function Yp(d, e, x, t, i, n, a) {
  const r = s, o = i.isWebGL2, c = i[r(1834)], h = i.maxCubemapSize, f = i[r(2310)], u = i[r(2654)], l = e[r(2086)](r(2598)) ? e[r(3016)]("WEBGL_multisampled_render_to_texture") : null, _ = typeof navigator > "u" ? ![] : /OculusBrowser/g.test(navigator[r(3490)]), p = /* @__PURE__ */ new WeakMap();
  let m;
  const y = /* @__PURE__ */ new WeakMap();
  let v = ![];
  try {
    v = typeof OffscreenCanvas !== r(2011) && new OffscreenCanvas(1, 1)[r(3271)]("2d") !== null;
  } catch {
  }
  function g(B, E) {
    return v ? new OffscreenCanvas(B, E) : Un(r(651));
  }
  function b(B, E, j, R) {
    const h0 = r;
    let S0 = 1;
    if ((B[h0(1631)] > R || B[h0(1674)] > R) && (S0 = R / Math[h0(1803)](B[h0(1631)], B[h0(1674)])), S0 < 1 || E === !![])
      if (typeof HTMLImageElement !== h0(2011) && B instanceof HTMLImageElement || typeof HTMLCanvasElement !== h0(2011) && B instanceof HTMLCanvasElement || typeof ImageBitmap !== h0(2011) && B instanceof ImageBitmap) {
        const R0 = E ? Gd : Math[h0(2697)], Z0 = R0(S0 * B[h0(1631)]), H0 = R0(S0 * B[h0(1674)]);
        m === void 0 && (m = g(Z0, H0));
        const u0 = j ? g(Z0, H0) : m;
        return u0[h0(1631)] = Z0, u0[h0(1674)] = H0, u0[h0(3271)]("2d")[h0(3009)](B, 0, 0, Z0, H0), console[h0(3629)]("THREE.WebGLRenderer: Texture has been resized from (" + B[h0(1631)] + "x" + B.height + h0(529) + Z0 + "x" + H0 + ")."), u0;
      } else
        return h0(2416) in B && console[h0(3629)](h0(2798) + B[h0(1631)] + "x" + B[h0(1674)] + ")."), B;
    return B;
  }
  function M(B) {
    const E = r;
    return n2(B[E(1631)]) && n2(B[E(1674)]);
  }
  function A(B) {
    const E = r;
    return o ? ![] : B.wrapS !== Zx || B[E(3221)] !== Zx || B[E(991)] !== Bx && B[E(991)] !== Cx;
  }
  function L(B, E) {
    const j = r;
    return B[j(3632)] && E && B[j(991)] !== Bx && B[j(991)] !== Cx;
  }
  function P(B) {
    d[r(1700)](B);
  }
  function S(B, E, j, R, h0 = ![]) {
    const S0 = r;
    if (o === ![])
      return E;
    if (B !== null) {
      if (d[B] !== void 0)
        return d[B];
      console[S0(3629)](S0(1285) + B + "'");
    }
    let R0 = E;
    return E === 6403 && (j === 5126 && (R0 = 33326), j === 5131 && (R0 = 33325), j === 5121 && (R0 = 33321)), E === 33319 && (j === 5126 && (R0 = 33328), j === 5131 && (R0 = 33327), j === 5121 && (R0 = 33323)), E === 6408 && (j === 5126 && (R0 = 34836), j === 5131 && (R0 = 34842), j === 5121 && (R0 = R === _x && h0 === ![] ? 35907 : 32856), j === 32819 && (R0 = 32854), j === 32820 && (R0 = 32855)), (R0 === 33325 || R0 === 33326 || R0 === 33327 || R0 === 33328 || R0 === 34842 || R0 === 34836) && e[S0(3016)]("EXT_color_buffer_float"), R0;
  }
  function I(B, E, j) {
    const R = r;
    return L(B, j) === !![] || B.isFramebufferTexture && B[R(991)] !== Bx && B.minFilter !== Cx ? Math[R(3422)](Math[R(1803)](E[R(1631)], E.height)) + 1 : B[R(2004)] !== void 0 && B.mipmaps[R(3105)] > 0 ? B[R(2004)][R(3105)] : B.isCompressedTexture && Array[R(1609)](B.image) ? E.mipmaps[R(3105)] : 1;
  }
  function C(B) {
    return B === Bx || B === In || B === Ui ? 9728 : 9729;
  }
  function G(B) {
    const E = r, j = B.target;
    j.removeEventListener(E(3387), G), N(j), j[E(2119)] && p.delete(j);
  }
  function $(B) {
    const E = r, j = B[E(671)];
    j[E(1079)]("dispose", $), X(j);
  }
  function N(B) {
    const E = r, j = t[E(3016)](B);
    if (j[E(670)] === void 0)
      return;
    const R = B.source, h0 = y.get(R);
    if (h0) {
      const S0 = h0[j[E(3424)]];
      S0[E(3558)]--, S0.usedTimes === 0 && V(B), Object.keys(h0).length === 0 && y[E(2850)](R);
    }
    t[E(3137)](B);
  }
  function V(B) {
    const E = r, j = t[E(3016)](B);
    d[E(2952)](j[E(2046)]);
    const R = B[E(796)], h0 = y.get(R);
    delete h0[j[E(3424)]], a[E(2158)][E(1822)]--;
  }
  function X(B) {
    const E = r, j = B[E(2431)], R = t[E(3016)](B), h0 = t[E(3016)](j);
    if (h0.__webglTexture !== void 0 && (d[E(2952)](h0[E(2046)]), a[E(2158)][E(1822)]--), B[E(1708)] && B[E(1708)][E(3387)](), B[E(1676)])
      for (let S0 = 0; S0 < 6; S0++)
        d.deleteFramebuffer(R[E(1319)][S0]), R[E(1394)] && d[E(883)](R[E(1394)][S0]);
    else {
      if (d[E(3732)](R.__webglFramebuffer), R[E(1394)] && d[E(883)](R.__webglDepthbuffer), R[E(1244)] && d[E(3732)](R[E(1244)]), R[E(766)])
        for (let S0 = 0; S0 < R.__webglColorRenderbuffer[E(3105)]; S0++)
          R[E(766)][S0] && d.deleteRenderbuffer(R[E(766)][S0]);
      R.__webglDepthRenderbuffer && d.deleteRenderbuffer(R.__webglDepthRenderbuffer);
    }
    if (B[E(3230)])
      for (let S0 = 0, R0 = j.length; S0 < R0; S0++) {
        const Z0 = t.get(j[S0]);
        Z0[E(2046)] && (d[E(2952)](Z0.__webglTexture), a[E(2158)][E(1822)]--), t[E(3137)](j[S0]);
      }
    t[E(3137)](j), t[E(3137)](B);
  }
  let n0 = 0;
  function b0() {
    n0 = 0;
  }
  function Q() {
    const B = r, E = n0;
    return E >= c && console[B(3629)](B(466) + E + B(2324) + c), n0 += 1, E;
  }
  function r0(B) {
    const E = r, j = [];
    return j[E(3156)](B[E(578)]), j[E(3156)](B[E(3221)]), j[E(3156)](B[E(1139)] || 0), j[E(3156)](B[E(999)]), j[E(3156)](B[E(991)]), j[E(3156)](B[E(2447)]), j[E(3156)](B[E(2060)]), j[E(3156)](B[E(448)]), j.push(B[E(566)]), j[E(3156)](B[E(3632)]), j[E(3156)](B[E(3003)]), j[E(3156)](B[E(1739)]), j.push(B[E(2275)]), j[E(3156)](B[E(523)]), j.join();
  }
  function l0(B, E) {
    const j = r, R = t[j(3016)](B);
    if (B[j(2119)] && fx(B), B[j(546)] === ![] && B[j(2185)] > 0 && R[j(3053)] !== B.version) {
      const h0 = B.image;
      if (h0 === null)
        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      else if (h0.complete === ![])
        console[j(3629)]("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      else {
        L0(R, B, E);
        return;
      }
    }
    x[j(708)](3553, R[j(2046)], 33984 + E);
  }
  function v0(B, E) {
    const j = r, R = t[j(3016)](B);
    if (B[j(2185)] > 0 && R[j(3053)] !== B[j(2185)]) {
      L0(R, B, E);
      return;
    }
    x.bindTexture(35866, R.__webglTexture, 33984 + E);
  }
  function s0(B, E) {
    const j = r, R = t[j(3016)](B);
    if (B[j(2185)] > 0 && R[j(3053)] !== B[j(2185)]) {
      L0(R, B, E);
      return;
    }
    x.bindTexture(32879, R.__webglTexture, 33984 + E);
  }
  function q(B, E) {
    const j = r, R = t[j(3016)](B);
    if (B.version > 0 && R.__version !== B[j(2185)]) {
      k0(R, B, E);
      return;
    }
    x[j(708)](34067, R[j(2046)], 33984 + E);
  }
  const a0 = { [Et]: 10497, [Zx]: 33071, [Hi]: 33648 }, e0 = { [Bx]: 9728, [In]: 9984, [Ui]: 9986, [Cx]: 9729, [ga]: 9985, [qe]: 9987 };
  function p0(B, E, j) {
    const R = r;
    if (j ? (d[R(830)](B, 10242, a0[E[R(578)]]), d[R(830)](B, 10243, a0[E[R(3221)]]), (B === 32879 || B === 35866) && d.texParameteri(B, 32882, a0[E.wrapR]), d[R(830)](B, 10240, e0[E[R(999)]]), d[R(830)](B, 10241, e0[E.minFilter])) : (d[R(830)](B, 10242, 33071), d.texParameteri(B, 10243, 33071), (B === 32879 || B === 35866) && d[R(830)](B, 32882, 33071), (E.wrapS !== Zx || E[R(3221)] !== Zx) && console[R(3629)](R(1794)), d[R(830)](B, 10240, C(E[R(999)])), d[R(830)](B, 10241, C(E.minFilter)), E[R(991)] !== Bx && E.minFilter !== Cx && console[R(3629)]("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), e[R(2086)](R(1869)) === !![]) {
      const h0 = e.get(R(1869));
      if (E[R(999)] === Bx || E[R(991)] !== Ui && E[R(991)] !== qe || E[R(566)] === ae && e[R(2086)]("OES_texture_float_linear") === ![] || o === ![] && E.type === ue && e[R(2086)](R(740)) === ![])
        return;
      (E[R(2447)] > 1 || t[R(3016)](E)[R(1408)]) && (d[R(1848)](B, h0[R(957)], Math[R(3085)](E[R(2447)], i.getMaxAnisotropy())), t.get(E)[R(1408)] = E[R(2447)]);
    }
  }
  function y0(B, E) {
    const j = r;
    let R = ![];
    B[j(670)] === void 0 && (B.__webglInit = !![], E.addEventListener(j(3387), G));
    const h0 = E[j(796)];
    let S0 = y.get(h0);
    S0 === void 0 && (S0 = {}, y[j(1260)](h0, S0));
    const R0 = r0(E);
    if (R0 !== B.__cacheKey) {
      S0[R0] === void 0 && (S0[R0] = { texture: d[j(3152)](), usedTimes: 0 }, a[j(2158)].textures++, R = !![]), S0[R0][j(3558)]++;
      const Z0 = S0[B.__cacheKey];
      Z0 !== void 0 && (S0[B[j(3424)]][j(3558)]--, Z0.usedTimes === 0 && V(E)), B[j(3424)] = R0, B.__webglTexture = S0[R0][j(2431)];
    }
    return R;
  }
  function L0(B, E, j) {
    const R = r;
    let h0 = 3553;
    (E[R(1204)] || E[R(2101)]) && (h0 = 35866), E[R(1142)] && (h0 = 32879);
    const S0 = y0(B, E), R0 = E.source;
    x[R(708)](h0, B[R(2046)], 33984 + j);
    const Z0 = t[R(3016)](R0);
    if (R0[R(2185)] !== Z0[R(3053)] || S0 === !![]) {
      x[R(570)](33984 + j), d.pixelStorei(37440, E[R(1739)]), d[R(3761)](37441, E[R(3003)]), d[R(3761)](3317, E[R(2275)]), d[R(3761)](37443, 0);
      const H0 = A(E) && M(E[R(450)]) === ![];
      let u0 = b(E[R(450)], H0, ![], f);
      u0 = vx(E, u0);
      const V0 = M(u0) || o, K0 = n[R(2708)](E.format, E[R(523)]);
      let j0 = n[R(2708)](E.type), $0 = S(E[R(2060)], K0, j0, E[R(523)], E[R(2119)]);
      p0(h0, E, V0);
      let Y0;
      const sx = E[R(2004)], cx = o && E[R(2119)] !== !![], k = Z0.__version === void 0 || S0 === !![], x0 = I(E, u0, V0);
      if (E[R(3669)])
        $0 = 6402, o ? E.type === ae ? $0 = 36012 : E.type === _t ? $0 = 33190 : E[R(566)] === ti ? $0 = 35056 : $0 = 33189 : E.type === ae && console.error(R(612)), E[R(448)] === wt && $0 === 6402 && E[R(566)] !== v2 && E[R(566)] !== _t && (console[R(3629)](R(485)), E[R(566)] = _t, j0 = n[R(2708)](E[R(566)])), E[R(448)] === si && $0 === 6402 && ($0 = 34041, E[R(566)] !== ti && (console.warn(R(3250)), E[R(566)] = ti, j0 = n[R(2708)](E[R(566)]))), k && (cx ? x[R(1914)](3553, 1, $0, u0[R(1631)], u0[R(1674)]) : x[R(1774)](3553, 0, $0, u0[R(1631)], u0[R(1674)], 0, K0, j0, null));
      else if (E[R(1120)])
        if (sx.length > 0 && V0) {
          cx && k && x[R(1914)](3553, x0, $0, sx[0].width, sx[0][R(1674)]);
          for (let t0 = 0, A0 = sx[R(3105)]; t0 < A0; t0++)
            Y0 = sx[t0], cx ? x[R(1282)](3553, t0, 0, 0, Y0.width, Y0.height, K0, j0, Y0[R(2416)]) : x[R(1774)](3553, t0, $0, Y0[R(1631)], Y0[R(1674)], 0, K0, j0, Y0.data);
          E[R(3632)] = ![];
        } else
          cx ? (k && x[R(1914)](3553, x0, $0, u0.width, u0[R(1674)]), x[R(1282)](3553, 0, 0, 0, u0[R(1631)], u0[R(1674)], K0, j0, u0[R(2416)])) : x.texImage2D(3553, 0, $0, u0.width, u0.height, 0, K0, j0, u0[R(2416)]);
      else if (E[R(3090)])
        if (E[R(2101)]) {
          cx && k && x[R(1123)](35866, x0, $0, sx[0][R(1631)], sx[0].height, u0[R(3611)]);
          for (let t0 = 0, A0 = sx.length; t0 < A0; t0++)
            Y0 = sx[t0], E[R(448)] !== le ? K0 !== null ? cx ? x.compressedTexSubImage3D(35866, t0, 0, 0, 0, Y0[R(1631)], Y0[R(1674)], u0.depth, K0, Y0.data, 0, 0) : x[R(1666)](35866, t0, $0, Y0[R(1631)], Y0.height, u0.depth, 0, Y0[R(2416)], 0, 0) : console[R(3629)]("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : cx ? x.texSubImage3D(35866, t0, 0, 0, 0, Y0[R(1631)], Y0[R(1674)], u0[R(3611)], K0, j0, Y0[R(2416)]) : x[R(1592)](35866, t0, $0, Y0.width, Y0.height, u0.depth, 0, K0, j0, Y0[R(2416)]);
        } else {
          cx && k && x[R(1914)](3553, x0, $0, sx[0].width, sx[0].height);
          for (let t0 = 0, A0 = sx[R(3105)]; t0 < A0; t0++)
            Y0 = sx[t0], E[R(448)] !== le ? K0 !== null ? cx ? x[R(1777)](3553, t0, 0, 0, Y0[R(1631)], Y0[R(1674)], K0, Y0[R(2416)]) : x[R(1002)](3553, t0, $0, Y0[R(1631)], Y0[R(1674)], 0, Y0[R(2416)]) : console[R(3629)](R(2642)) : cx ? x[R(1282)](3553, t0, 0, 0, Y0[R(1631)], Y0.height, K0, j0, Y0[R(2416)]) : x[R(1774)](3553, t0, $0, Y0[R(1631)], Y0[R(1674)], 0, K0, j0, Y0[R(2416)]);
        }
      else if (E.isDataArrayTexture)
        cx ? (k && x[R(1123)](35866, x0, $0, u0.width, u0[R(1674)], u0.depth), x[R(3543)](35866, 0, 0, 0, 0, u0.width, u0.height, u0[R(3611)], K0, j0, u0.data)) : x.texImage3D(35866, 0, $0, u0[R(1631)], u0[R(1674)], u0[R(3611)], 0, K0, j0, u0[R(2416)]);
      else if (E.isData3DTexture)
        cx ? (k && x[R(1123)](32879, x0, $0, u0[R(1631)], u0[R(1674)], u0[R(3611)]), x.texSubImage3D(32879, 0, 0, 0, 0, u0[R(1631)], u0.height, u0[R(3611)], K0, j0, u0.data)) : x[R(1592)](32879, 0, $0, u0[R(1631)], u0[R(1674)], u0[R(3611)], 0, K0, j0, u0.data);
      else if (E.isFramebufferTexture) {
        if (k)
          if (cx)
            x[R(1914)](3553, x0, $0, u0[R(1631)], u0[R(1674)]);
          else {
            let t0 = u0[R(1631)], A0 = u0[R(1674)];
            for (let w0 = 0; w0 < x0; w0++)
              x[R(1774)](3553, w0, $0, t0, A0, 0, K0, j0, null), t0 >>= 1, A0 >>= 1;
          }
      } else if (sx[R(3105)] > 0 && V0) {
        cx && k && x[R(1914)](3553, x0, $0, sx[0][R(1631)], sx[0][R(1674)]);
        for (let t0 = 0, A0 = sx[R(3105)]; t0 < A0; t0++)
          Y0 = sx[t0], cx ? x[R(1282)](3553, t0, 0, 0, K0, j0, Y0) : x.texImage2D(3553, t0, $0, K0, j0, Y0);
        E[R(3632)] = ![];
      } else
        cx ? (k && x[R(1914)](3553, x0, $0, u0[R(1631)], u0[R(1674)]), x.texSubImage2D(3553, 0, 0, 0, K0, j0, u0)) : x[R(1774)](3553, 0, $0, K0, j0, u0);
      L(E, V0) && P(h0), Z0.__version = R0[R(2185)], E[R(1509)] && E[R(1509)](E);
    }
    B[R(3053)] = E[R(2185)];
  }
  function k0(B, E, j) {
    const R = r;
    if (E[R(450)][R(3105)] !== 6)
      return;
    const h0 = y0(B, E), S0 = E[R(796)];
    x[R(708)](34067, B.__webglTexture, 33984 + j);
    const R0 = t[R(3016)](S0);
    if (S0[R(2185)] !== R0[R(3053)] || h0 === !![]) {
      x[R(570)](33984 + j), d[R(3761)](37440, E.flipY), d[R(3761)](37441, E.premultiplyAlpha), d[R(3761)](3317, E.unpackAlignment), d[R(3761)](37443, 0);
      const Z0 = E[R(3090)] || E[R(450)][0][R(3090)], H0 = E[R(450)][0] && E[R(450)][0][R(1120)], u0 = [];
      for (let t0 = 0; t0 < 6; t0++)
        !Z0 && !H0 ? u0[t0] = b(E[R(450)][t0], ![], !![], h) : u0[t0] = H0 ? E[R(450)][t0][R(450)] : E[R(450)][t0], u0[t0] = vx(E, u0[t0]);
      const V0 = u0[0], K0 = M(V0) || o, j0 = n.convert(E[R(448)], E.encoding), $0 = n[R(2708)](E[R(566)]), Y0 = S(E[R(2060)], j0, $0, E.encoding), sx = o && E[R(2119)] !== !![], cx = R0[R(3053)] === void 0 || h0 === !![];
      let k = I(E, V0, K0);
      p0(34067, E, K0);
      let x0;
      if (Z0) {
        sx && cx && x.texStorage2D(34067, k, Y0, V0.width, V0.height);
        for (let t0 = 0; t0 < 6; t0++) {
          x0 = u0[t0][R(2004)];
          for (let A0 = 0; A0 < x0[R(3105)]; A0++) {
            const w0 = x0[A0];
            E[R(448)] !== le ? j0 !== null ? sx ? x.compressedTexSubImage2D(34069 + t0, A0, 0, 0, w0.width, w0[R(1674)], j0, w0[R(2416)]) : x[R(1002)](34069 + t0, A0, Y0, w0[R(1631)], w0.height, 0, w0[R(2416)]) : console[R(3629)](R(3427)) : sx ? x[R(1282)](34069 + t0, A0, 0, 0, w0[R(1631)], w0[R(1674)], j0, $0, w0[R(2416)]) : x.texImage2D(34069 + t0, A0, Y0, w0.width, w0[R(1674)], 0, j0, $0, w0[R(2416)]);
          }
        }
      } else {
        x0 = E.mipmaps, sx && cx && (x0[R(3105)] > 0 && k++, x[R(1914)](34067, k, Y0, u0[0][R(1631)], u0[0][R(1674)]));
        for (let t0 = 0; t0 < 6; t0++)
          if (H0) {
            sx ? x[R(1282)](34069 + t0, 0, 0, 0, u0[t0].width, u0[t0].height, j0, $0, u0[t0][R(2416)]) : x[R(1774)](34069 + t0, 0, Y0, u0[t0][R(1631)], u0[t0][R(1674)], 0, j0, $0, u0[t0][R(2416)]);
            for (let A0 = 0; A0 < x0[R(3105)]; A0++) {
              const w0 = x0[A0], ax = w0[R(450)][t0][R(450)];
              sx ? x[R(1282)](34069 + t0, A0 + 1, 0, 0, ax[R(1631)], ax[R(1674)], j0, $0, ax[R(2416)]) : x[R(1774)](34069 + t0, A0 + 1, Y0, ax[R(1631)], ax.height, 0, j0, $0, ax[R(2416)]);
            }
          } else {
            sx ? x[R(1282)](34069 + t0, 0, 0, 0, j0, $0, u0[t0]) : x[R(1774)](34069 + t0, 0, Y0, j0, $0, u0[t0]);
            for (let A0 = 0; A0 < x0.length; A0++) {
              const w0 = x0[A0];
              sx ? x.texSubImage2D(34069 + t0, A0 + 1, 0, 0, j0, $0, w0.image[t0]) : x.texImage2D(34069 + t0, A0 + 1, Y0, j0, $0, w0[R(450)][t0]);
            }
          }
      }
      L(E, K0) && P(34067), R0.__version = S0[R(2185)], E[R(1509)] && E[R(1509)](E);
    }
    B[R(3053)] = E.version;
  }
  function Q0(B, E, j, R, h0) {
    const S0 = r, R0 = n[S0(2708)](j[S0(448)], j[S0(523)]), Z0 = n[S0(2708)](j[S0(566)]), H0 = S(j[S0(2060)], R0, Z0, j[S0(523)]);
    !t.get(E)[S0(3648)] && (h0 === 32879 || h0 === 35866 ? x[S0(1592)](h0, 0, H0, E[S0(1631)], E[S0(1674)], E[S0(3611)], 0, R0, Z0, null) : x.texImage2D(h0, 0, H0, E[S0(1631)], E[S0(1674)], 0, R0, Z0, null)), x.bindFramebuffer(36160, B), X0(E) ? l.framebufferTexture2DMultisampleEXT(36160, R, h0, t[S0(3016)](j).__webglTexture, 0, B0(E)) : (h0 === 3553 || h0 >= 34069 && h0 <= 34074) && d[S0(3057)](36160, R, h0, t.get(j)[S0(2046)], 0), x[S0(3781)](36160, null);
  }
  function U0(B, E, j) {
    const R = r;
    if (d[R(3553)](36161, B), E[R(471)] && !E.stencilBuffer) {
      let h0 = 33189;
      if (j || X0(E)) {
        const S0 = E.depthTexture;
        S0 && S0[R(3669)] && (S0[R(566)] === ae ? h0 = 36012 : S0.type === _t && (h0 = 33190));
        const R0 = B0(E);
        X0(E) ? l.renderbufferStorageMultisampleEXT(36161, R0, h0, E[R(1631)], E[R(1674)]) : d[R(2471)](36161, R0, h0, E.width, E.height);
      } else
        d[R(1846)](36161, h0, E[R(1631)], E[R(1674)]);
      d[R(3210)](36160, 36096, 36161, B);
    } else if (E[R(471)] && E.stencilBuffer) {
      const h0 = B0(E);
      j && X0(E) === ![] ? d.renderbufferStorageMultisample(36161, h0, 35056, E[R(1631)], E[R(1674)]) : X0(E) ? l.renderbufferStorageMultisampleEXT(36161, h0, 35056, E.width, E[R(1674)]) : d[R(1846)](36161, 34041, E[R(1631)], E[R(1674)]), d[R(3210)](36160, 33306, 36161, B);
    } else {
      const h0 = E.isWebGLMultipleRenderTargets === !![] ? E[R(2431)] : [E.texture];
      for (let S0 = 0; S0 < h0[R(3105)]; S0++) {
        const R0 = h0[S0], Z0 = n.convert(R0[R(448)], R0[R(523)]), H0 = n[R(2708)](R0[R(566)]), u0 = S(R0[R(2060)], Z0, H0, R0.encoding), V0 = B0(E);
        j && X0(E) === ![] ? d[R(2471)](36161, V0, u0, E[R(1631)], E.height) : X0(E) ? l[R(2149)](36161, V0, u0, E.width, E.height) : d[R(1846)](36161, u0, E[R(1631)], E.height);
      }
    }
    d[R(3553)](36161, null);
  }
  function xx(B, E) {
    const j = r;
    if (E && E.isWebGLCubeRenderTarget)
      throw new Error("Depth Texture with cube render targets is not supported");
    if (x[j(3781)](36160, B), !(E[j(1708)] && E[j(1708)][j(3669)]))
      throw new Error(j(828));
    (!t.get(E[j(1708)])[j(2046)] || E[j(1708)].image[j(1631)] !== E[j(1631)] || E[j(1708)].image[j(1674)] !== E[j(1674)]) && (E.depthTexture[j(450)][j(1631)] = E[j(1631)], E[j(1708)][j(450)][j(1674)] = E[j(1674)], E.depthTexture[j(3035)] = !![]), l0(E[j(1708)], 0);
    const h0 = t[j(3016)](E[j(1708)]).__webglTexture, S0 = B0(E);
    if (E.depthTexture[j(448)] === wt)
      X0(E) ? l[j(2590)](36160, 36096, 3553, h0, 0, S0) : d[j(3057)](36160, 36096, 3553, h0, 0);
    else if (E[j(1708)][j(448)] === si)
      X0(E) ? l[j(2590)](36160, 33306, 3553, h0, 0, S0) : d[j(3057)](36160, 33306, 3553, h0, 0);
    else
      throw new Error(j(2772));
  }
  function _0(B) {
    const E = r, j = t[E(3016)](B), R = B[E(1676)] === !![];
    if (B[E(1708)] && !j[E(1962)]) {
      if (R)
        throw new Error(E(3491));
      xx(j.__webglFramebuffer, B);
    } else if (R) {
      j[E(1394)] = [];
      for (let h0 = 0; h0 < 6; h0++)
        x[E(3781)](36160, j[E(1319)][h0]), j.__webglDepthbuffer[h0] = d[E(3725)](), U0(j[E(1394)][h0], B, ![]);
    } else
      x[E(3781)](36160, j[E(1319)]), j[E(1394)] = d[E(3725)](), U0(j[E(1394)], B, ![]);
    x.bindFramebuffer(36160, null);
  }
  function E0(B, E, j) {
    const R = r, h0 = t[R(3016)](B);
    E !== void 0 && Q0(h0[R(1319)], B, B[R(2431)], 36064, 3553), j !== void 0 && _0(B);
  }
  function O0(B) {
    const E = r, j = B[E(2431)], R = t.get(B), h0 = t[E(3016)](j);
    B.addEventListener(E(3387), $), B.isWebGLMultipleRenderTargets !== !![] && (h0[E(2046)] === void 0 && (h0[E(2046)] = d[E(3152)]()), h0.__version = j[E(2185)], a.memory[E(1822)]++);
    const S0 = B[E(1676)] === !![], R0 = B[E(3230)] === !![], Z0 = M(B) || o;
    if (S0) {
      R[E(1319)] = [];
      for (let H0 = 0; H0 < 6; H0++)
        R[E(1319)][H0] = d[E(1047)]();
    } else {
      if (R[E(1319)] = d[E(1047)](), R0)
        if (i.drawBuffers) {
          const H0 = B.texture;
          for (let u0 = 0, V0 = H0[E(3105)]; u0 < V0; u0++) {
            const K0 = t[E(3016)](H0[u0]);
            K0[E(2046)] === void 0 && (K0.__webglTexture = d[E(3152)](), a.memory[E(1822)]++);
          }
        } else
          console[E(3629)](E(3413));
      if (o && B.samples > 0 && X0(B) === ![]) {
        const H0 = R0 ? j : [j];
        R[E(1244)] = d[E(1047)](), R[E(766)] = [], x[E(3781)](36160, R.__webglMultisampledFramebuffer);
        for (let u0 = 0; u0 < H0[E(3105)]; u0++) {
          const V0 = H0[u0];
          R[E(766)][u0] = d[E(3725)](), d.bindRenderbuffer(36161, R[E(766)][u0]);
          const K0 = n[E(2708)](V0[E(448)], V0[E(523)]), j0 = n.convert(V0.type), $0 = S(V0[E(2060)], K0, j0, V0[E(523)], B[E(2764)] === !![]), Y0 = B0(B);
          d[E(2471)](36161, Y0, $0, B[E(1631)], B[E(1674)]), d[E(3210)](36160, 36064 + u0, 36161, R.__webglColorRenderbuffer[u0]);
        }
        d.bindRenderbuffer(36161, null), B[E(471)] && (R[E(2510)] = d[E(3725)](), U0(R[E(2510)], B, !![])), x[E(3781)](36160, null);
      }
    }
    if (S0) {
      x[E(708)](34067, h0[E(2046)]), p0(34067, j, Z0);
      for (let H0 = 0; H0 < 6; H0++)
        Q0(R[E(1319)][H0], B, j, 36064, 34069 + H0);
      L(j, Z0) && P(34067), x[E(1346)]();
    } else if (R0) {
      const H0 = B[E(2431)];
      for (let u0 = 0, V0 = H0[E(3105)]; u0 < V0; u0++) {
        const K0 = H0[u0], j0 = t[E(3016)](K0);
        x[E(708)](3553, j0[E(2046)]), p0(3553, K0, Z0), Q0(R[E(1319)], B, K0, 36064 + u0, 3553), L(K0, Z0) && P(3553);
      }
      x[E(1346)]();
    } else {
      let H0 = 3553;
      (B[E(2182)] || B[E(3600)]) && (o ? H0 = B[E(2182)] ? 32879 : 35866 : console[E(533)]("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), x[E(708)](H0, h0[E(2046)]), p0(H0, j, Z0), Q0(R[E(1319)], B, j, 36064, H0), L(j, Z0) && P(H0), x[E(1346)]();
    }
    B[E(471)] && _0(B);
  }
  function D0(B) {
    const E = r, j = M(B) || o, R = B.isWebGLMultipleRenderTargets === !![] ? B[E(2431)] : [B[E(2431)]];
    for (let h0 = 0, S0 = R[E(3105)]; h0 < S0; h0++) {
      const R0 = R[h0];
      if (L(R0, j)) {
        const Z0 = B[E(1676)] ? 34067 : 3553, H0 = t[E(3016)](R0).__webglTexture;
        x.bindTexture(Z0, H0), P(Z0), x[E(1346)]();
      }
    }
  }
  function N0(B) {
    const E = r;
    if (o && B.samples > 0 && X0(B) === ![]) {
      const j = B[E(3230)] ? B.texture : [B[E(2431)]], R = B[E(1631)], h0 = B[E(1674)];
      let S0 = 16384;
      const R0 = [], Z0 = B[E(686)] ? 33306 : 36096, H0 = t.get(B), u0 = B[E(3230)] === !![];
      if (u0)
        for (let V0 = 0; V0 < j[E(3105)]; V0++)
          x[E(3781)](36160, H0[E(1244)]), d[E(3210)](36160, 36064 + V0, 36161, null), x[E(3781)](36160, H0[E(1319)]), d.framebufferTexture2D(36009, 36064 + V0, 3553, null, 0);
      x.bindFramebuffer(36008, H0[E(1244)]), x.bindFramebuffer(36009, H0[E(1319)]);
      for (let V0 = 0; V0 < j.length; V0++) {
        R0.push(36064 + V0), B.depthBuffer && R0[E(3156)](Z0);
        const K0 = H0.__ignoreDepthValues !== void 0 ? H0[E(2454)] : ![];
        if (K0 === ![] && (B[E(471)] && (S0 |= 256), B.stencilBuffer && (S0 |= 1024)), u0 && d[E(3210)](36008, 36064, 36161, H0.__webglColorRenderbuffer[V0]), K0 === !![] && (d[E(1155)](36008, [Z0]), d[E(1155)](36009, [Z0])), u0) {
          const j0 = t.get(j[V0]).__webglTexture;
          d[E(3057)](36009, 36064, 3553, j0, 0);
        }
        d[E(2509)](0, 0, R, h0, 0, 0, R, h0, S0, 9728), _ && d[E(1155)](36008, R0);
      }
      if (x[E(3781)](36008, null), x.bindFramebuffer(36009, null), u0)
        for (let V0 = 0; V0 < j[E(3105)]; V0++) {
          x[E(3781)](36160, H0[E(1244)]), d.framebufferRenderbuffer(36160, 36064 + V0, 36161, H0.__webglColorRenderbuffer[V0]);
          const K0 = t[E(3016)](j[V0])[E(2046)];
          x[E(3781)](36160, H0[E(1319)]), d[E(3057)](36009, 36064 + V0, 3553, K0, 0);
        }
      x[E(3781)](36009, H0[E(1244)]);
    }
  }
  function B0(B) {
    return Math[r(3085)](u, B.samples);
  }
  function X0(B) {
    const E = r, j = t[E(3016)](B);
    return o && B[E(1820)] > 0 && e[E(2086)](E(2598)) === !![] && j[E(2918)] !== ![];
  }
  function fx(B) {
    const E = r, j = a[E(489)][E(1320)];
    p.get(B) !== j && (p.set(B, j), B[E(3452)]());
  }
  function vx(B, E) {
    const j = r, R = B[j(523)], h0 = B[j(448)], S0 = B[j(566)];
    return B[j(3090)] === !![] || B.isVideoTexture === !![] || B[j(448)] === ua || R !== Ne && (R === _x ? o === ![] ? e[j(2086)]("EXT_sRGB") === !![] && h0 === le ? (B.format = ua, B[j(991)] = Cx, B.generateMipmaps = ![]) : E = A2[j(2408)](E) : (h0 !== le || S0 !== At) && console[j(3629)]("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console[j(533)](j(775), R)), E;
  }
  this[r(2931)] = Q, this[r(3437)] = b0, this.setTexture2D = l0, this[r(3161)] = v0, this[r(1884)] = s0, this[r(2188)] = q, this[r(2164)] = E0, this.setupRenderTarget = O0, this[r(2069)] = D0, this[r(2285)] = N0, this[r(1231)] = _0, this.setupFrameBufferTexture = Q0, this[r(1250)] = X0;
}
function Jd(d, e, x) {
  const t = s, i = x[t(510)];
  function n(a, r = null) {
    const o = t;
    let c;
    if (a === At)
      return 5121;
    if (a === yd)
      return 32819;
    if (a === wd)
      return 32820;
    if (a === gd)
      return 5120;
    if (a === _d)
      return 5122;
    if (a === v2)
      return 5123;
    if (a === vd)
      return 5124;
    if (a === _t)
      return 5125;
    if (a === ae)
      return 5126;
    if (a === ue)
      return i ? 5131 : (c = e[o(3016)](o(875)), c !== null ? c[o(2376)] : null);
    if (a === Md)
      return 6406;
    if (a === le)
      return 6408;
    if (a === Sd)
      return 6409;
    if (a === Td)
      return 6410;
    if (a === wt)
      return 6402;
    if (a === si)
      return 34041;
    if (a === ua)
      return c = e.get("EXT_sRGB"), c !== null ? c.SRGB_ALPHA_EXT : null;
    if (a === y2)
      return 6403;
    if (a === Ed)
      return 36244;
    if (a === Ad)
      return 33319;
    if (a === Cd)
      return 33320;
    if (a === Ld)
      return 36249;
    if (a === ia || a === na || a === sa || a === aa)
      if (r === _x)
        if (c = e[o(3016)](o(1256)), c !== null) {
          if (a === ia)
            return c[o(1926)];
          if (a === na)
            return c.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (a === sa)
            return c[o(2569)];
          if (a === aa)
            return c[o(2406)];
        } else
          return null;
      else if (c = e[o(3016)]("WEBGL_compressed_texture_s3tc"), c !== null) {
        if (a === ia)
          return c.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (a === na)
          return c[o(1562)];
        if (a === sa)
          return c[o(2990)];
        if (a === aa)
          return c[o(2536)];
      } else
        return null;
    if (a === Or || a === Nr || a === Ur || a === zr)
      if (c = e[o(3016)](o(2937)), c !== null) {
        if (a === Or)
          return c[o(2245)];
        if (a === Nr)
          return c[o(2673)];
        if (a === Ur)
          return c[o(2105)];
        if (a === zr)
          return c[o(511)];
      } else
        return null;
    if (a === Rd)
      return c = e.get("WEBGL_compressed_texture_etc1"), c !== null ? c[o(2729)] : null;
    if (a === Br || a === Fr)
      if (c = e[o(3016)]("WEBGL_compressed_texture_etc"), c !== null) {
        if (a === Br)
          return r === _x ? c[o(3580)] : c[o(1107)];
        if (a === Fr)
          return r === _x ? c[o(1080)] : c.COMPRESSED_RGBA8_ETC2_EAC;
      } else
        return null;
    if (a === Gr || a === Hr || a === kr || a === Vr || a === Wr || a === jr || a === Xr || a === qr || a === Yr || a === Zr || a === Kr || a === $r || a === Jr || a === Qr)
      if (c = e[o(3016)]("WEBGL_compressed_texture_astc"), c !== null) {
        if (a === Gr)
          return r === _x ? c[o(2533)] : c[o(3624)];
        if (a === Hr)
          return r === _x ? c[o(958)] : c[o(1270)];
        if (a === kr)
          return r === _x ? c.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : c[o(1355)];
        if (a === Vr)
          return r === _x ? c.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : c.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (a === Wr)
          return r === _x ? c.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : c.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (a === jr)
          return r === _x ? c.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : c.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (a === Xr)
          return r === _x ? c.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : c[o(462)];
        if (a === qr)
          return r === _x ? c[o(617)] : c.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (a === Yr)
          return r === _x ? c[o(947)] : c[o(2263)];
        if (a === Zr)
          return r === _x ? c[o(1505)] : c[o(2121)];
        if (a === Kr)
          return r === _x ? c[o(3354)] : c[o(1865)];
        if (a === $r)
          return r === _x ? c.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : c[o(1960)];
        if (a === Jr)
          return r === _x ? c.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : c[o(1301)];
        if (a === Qr)
          return r === _x ? c[o(2058)] : c.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else
        return null;
    if (a === ra)
      if (c = e[o(3016)](o(2236)), c !== null) {
        if (a === ra)
          return r === _x ? c[o(986)] : c[o(1295)];
      } else
        return null;
    if (a === Pd || a === x2 || a === e2 || a === t2)
      if (c = e[o(3016)](o(2724)), c !== null) {
        if (a === ra)
          return c[o(2684)];
        if (a === x2)
          return c[o(692)];
        if (a === e2)
          return c[o(2749)];
        if (a === t2)
          return c[o(2971)];
      } else
        return null;
    return a === ti ? i ? 34042 : (c = e[o(3016)](o(1542)), c !== null ? c[o(3448)] : null) : d[a] !== void 0 ? d[a] : null;
  }
  return { convert: n };
}
class Qd extends Vx {
  constructor(e = []) {
    const x = s;
    super(), this[x(1356)] = !![], this[x(1752)] = e;
  }
}
class nt extends px {
  constructor() {
    const e = s;
    super(), this[e(801)] = !![], this.type = "Group";
  }
}
const Zp = { type: s(1006) };
class rr {
  constructor() {
    const e = s;
    this[e(1268)] = null, this._grip = null, this[e(1593)] = null;
  }
  [s(2117)]() {
    const e = s;
    return this[e(1593)] === null && (this[e(1593)] = new nt(), this[e(1593)][e(1126)] = ![], this[e(1593)][e(2456)] = ![], this[e(1593)].joints = {}, this[e(1593)][e(2913)] = { pinching: ![] }), this[e(1593)];
  }
  getTargetRaySpace() {
    const e = s;
    return this[e(1268)] === null && (this[e(1268)] = new nt(), this[e(1268)].matrixAutoUpdate = ![], this[e(1268)][e(2456)] = ![], this[e(1268)][e(1077)] = ![], this[e(1268)][e(1866)] = new z(), this[e(1268)].hasAngularVelocity = ![], this[e(1268)].angularVelocity = new z()), this[e(1268)];
  }
  [s(2832)]() {
    const e = s;
    return this[e(600)] === null && (this[e(600)] = new nt(), this[e(600)][e(1126)] = ![], this[e(600)][e(2456)] = ![], this._grip.hasLinearVelocity = ![], this._grip[e(1866)] = new z(), this[e(600)][e(3366)] = ![], this[e(600)][e(3552)] = new z()), this[e(600)];
  }
  [s(3157)](e) {
    const x = s;
    return this[x(1268)] !== null && this[x(1268)][x(3157)](e), this[x(600)] !== null && this._grip[x(3157)](e), this[x(1593)] !== null && this._hand[x(3157)](e), this;
  }
  connect(e) {
    const x = s;
    if (e && e[x(736)]) {
      const t = this[x(1593)];
      if (t)
        for (const i of e.hand[x(910)]())
          this[x(3471)](t, i);
    }
    return this[x(3157)]({ type: x(3782), data: e }), this;
  }
  disconnect(e) {
    const x = s;
    return this[x(3157)]({ type: x(1845), data: e }), this[x(1268)] !== null && (this[x(1268)].visible = ![]), this._grip !== null && (this[x(600)][x(2456)] = ![]), this[x(1593)] !== null && (this._hand[x(2456)] = ![]), this;
  }
  [s(3452)](e, x, t) {
    const i = s;
    let n = null, a = null, r = null;
    const o = this[i(1268)], c = this[i(600)], h = this[i(1593)];
    if (e && x[i(599)][i(721)] !== "visible-blurred") {
      if (h && e[i(736)]) {
        r = !![];
        for (const m of e[i(736)].values()) {
          const y = x[i(2155)](m, t), v = this._getHandJoint(h, m);
          y !== null && (v[i(1067)][i(666)](y.transform[i(1067)]), v[i(1067)][i(3653)](v[i(3571)], v[i(591)], v.scale), v.jointRadius = y[i(1232)]), v.visible = y !== null;
        }
        const f = h[i(1205)][i(2355)], u = h[i(1205)][i(2819)], l = f[i(3571)][i(3570)](u[i(3571)]), _ = 0.02, p = 5e-3;
        h[i(2913)][i(834)] && l > _ + p ? (h[i(2913)][i(834)] = ![], this[i(3157)]({ type: i(3605), handedness: e[i(1476)], target: this })) : !h[i(2913)].pinching && l <= _ - p && (h[i(2913)].pinching = !![], this[i(3157)]({ type: i(2350), handedness: e[i(1476)], target: this }));
      } else
        c !== null && e.gripSpace && (a = x.getPose(e.gripSpace, t), a !== null && (c[i(1067)].fromArray(a[i(3337)][i(1067)]), c[i(1067)][i(3653)](c[i(3571)], c[i(591)], c[i(2204)]), a[i(1866)] ? (c[i(1077)] = !![], c[i(1866)].copy(a[i(1866)])) : c[i(1077)] = ![], a.angularVelocity ? (c[i(3366)] = !![], c[i(3552)][i(2875)](a.angularVelocity)) : c[i(3366)] = ![]));
      o !== null && (n = x[i(2932)](e[i(446)], t), n === null && a !== null && (n = a), n !== null && (o[i(1067)][i(666)](n[i(3337)].matrix), o[i(1067)][i(3653)](o[i(3571)], o[i(591)], o.scale), n.linearVelocity ? (o.hasLinearVelocity = !![], o[i(1866)].copy(n[i(1866)])) : o[i(1077)] = ![], n[i(3552)] ? (o[i(3366)] = !![], o.angularVelocity[i(2875)](n[i(3552)])) : o[i(3366)] = ![], this.dispatchEvent(Zp)));
    }
    return o !== null && (o[i(2456)] = n !== null), c !== null && (c[i(2456)] = a !== null), h !== null && (h[i(2456)] = r !== null), this;
  }
  _getHandJoint(e, x) {
    const t = s;
    if (e[t(1205)][x.jointName] === void 0) {
      const i = new nt();
      i[t(1126)] = ![], i.visible = ![], e[t(1205)][x.jointName] = i, e[t(3026)](i);
    }
    return e[t(1205)][x[t(3480)]];
  }
}
class xh extends Ux {
  constructor(e, x, t, i, n, a, r, o, c, h) {
    const f = s;
    if (h = h !== void 0 ? h : wt, h !== wt && h !== si)
      throw new Error(f(1516));
    t === void 0 && h === wt && (t = _t), t === void 0 && h === si && (t = ti), super(null, i, n, a, r, o, h, t, c), this[f(3669)] = !![], this[f(450)] = { width: e, height: x }, this[f(999)] = r !== void 0 ? r : Bx, this[f(991)] = o !== void 0 ? o : Bx, this[f(1739)] = ![], this[f(3632)] = ![];
  }
}
class Kp extends Ye {
  constructor(e, x) {
    const t = s;
    super();
    const i = this;
    let n = null, a = 1, r = null, o = "local-floor", c = 1, h = null, f = null, u = null, l = null, _ = null, p = null;
    const m = x[t(3522)]();
    let y = null, v = null;
    const g = [], b = [], M = /* @__PURE__ */ new Set(), A = /* @__PURE__ */ new Map(), L = new Vx();
    L[t(479)].enable(1), L.viewport = new Mx();
    const P = new Vx();
    P[t(479)][t(3167)](2), P[t(2483)] = new Mx();
    const S = [L, P], I = new Qd();
    I[t(479)][t(3167)](1), I[t(479)][t(3167)](2);
    let C = null, G = null;
    this[t(2929)] = !![], this[t(2679)] = ![], this[t(869)] = ![], this[t(1787)] = function(s0) {
      const q = t;
      let a0 = g[s0];
      return a0 === void 0 && (a0 = new rr(), g[s0] = a0), a0[q(3593)]();
    }, this[t(1709)] = function(s0) {
      let q = g[s0];
      return q === void 0 && (q = new rr(), g[s0] = q), q.getGripSpace();
    }, this[t(820)] = function(s0) {
      const q = t;
      let a0 = g[s0];
      return a0 === void 0 && (a0 = new rr(), g[s0] = a0), a0[q(2117)]();
    };
    function $(s0) {
      const q = t, a0 = b[q(882)](s0[q(2911)]);
      if (a0 === -1)
        return;
      const e0 = g[a0];
      e0 !== void 0 && e0[q(3157)]({ type: s0[q(566)], data: s0[q(2911)] });
    }
    function N() {
      const s0 = t;
      n[s0(1079)](s0(1916), $), n[s0(1079)](s0(852), $), n[s0(1079)]("selectend", $), n[s0(1079)](s0(2876), $), n[s0(1079)]("squeezestart", $), n[s0(1079)]("squeezeend", $), n.removeEventListener(s0(1475), N), n[s0(1079)]("inputsourceschange", V);
      for (let q = 0; q < g[s0(3105)]; q++) {
        const a0 = b[q];
        a0 !== null && (b[q] = null, g[q].disconnect(a0));
      }
      C = null, G = null, e[s0(2969)](y), _ = null, l = null, u = null, n = null, v = null, v0[s0(914)](), i[s0(869)] = ![], i.dispatchEvent({ type: s0(837) });
    }
    this[t(3236)] = function(s0) {
      const q = t;
      a = s0, i[q(869)] === !![] && console[q(3629)](q(3206));
    }, this[t(990)] = function(s0) {
      const q = t;
      o = s0, i.isPresenting === !![] && console[q(3629)](q(1564));
    }, this[t(855)] = function() {
      return h || r;
    }, this[t(2034)] = function(s0) {
      h = s0;
    }, this[t(1942)] = function() {
      return l !== null ? l : _;
    }, this[t(3301)] = function() {
      return u;
    }, this.getFrame = function() {
      return p;
    }, this.getSession = function() {
      return n;
    }, this.setSession = async function(s0) {
      const q = t;
      if (n = s0, n !== null) {
        if (y = e[q(427)](), n[q(818)](q(1916), $), n[q(818)](q(852), $), n.addEventListener(q(981), $), n.addEventListener("squeeze", $), n[q(818)]("squeezestart", $), n[q(818)](q(2313), $), n[q(818)]("end", N), n[q(818)](q(2467), V), m.xrCompatible !== !![] && await x[q(3601)](), n[q(1195)].layers === void 0 || e[q(1576)][q(510)] === ![]) {
          const a0 = { antialias: n.renderState[q(479)] === void 0 ? m.antialias : !![], alpha: m[q(800)], depth: m.depth, stencil: m.stencil, framebufferScaleFactor: a };
          _ = new XRWebGLLayer(n, x, a0), n[q(1189)]({ baseLayer: _ }), v = new oe(_.framebufferWidth, _.framebufferHeight, { format: le, type: At, encoding: e[q(3565)], stencilBuffer: m[q(1632)] });
        } else {
          let a0 = null, e0 = null, p0 = null;
          m[q(3611)] && (p0 = m[q(1632)] ? 35056 : 33190, a0 = m[q(1632)] ? si : wt, e0 = m[q(1632)] ? ti : _t);
          const y0 = { colorFormat: 32856, depthFormat: p0, scaleFactor: a };
          u = new XRWebGLBinding(n, x), l = u[q(1853)](y0), n[q(1189)]({ layers: [l] }), v = new oe(l[q(1784)], l.textureHeight, { format: le, type: At, depthTexture: new xh(l[q(1784)], l[q(3802)], e0, void 0, void 0, void 0, void 0, void 0, void 0, a0), stencilBuffer: m[q(1632)], encoding: e[q(3565)], samples: m[q(3614)] ? 4 : 0 });
          const L0 = e[q(1478)][q(3016)](v);
          L0[q(2454)] = l[q(1613)];
        }
        v[q(2764)] = !![], this.setFoveation(c), h = null, r = await n[q(1879)](o), v0[q(1993)](n), v0[q(1917)](), i[q(869)] = !![], i[q(3157)]({ type: "sessionstart" });
      }
    };
    function V(s0) {
      const q = t;
      for (let a0 = 0; a0 < s0[q(1801)][q(3105)]; a0++) {
        const e0 = s0[q(1801)][a0], p0 = b[q(882)](e0);
        p0 >= 0 && (b[p0] = null, g[p0][q(2496)](e0));
      }
      for (let a0 = 0; a0 < s0[q(1236)][q(3105)]; a0++) {
        const e0 = s0.added[a0];
        let p0 = b[q(882)](e0);
        if (p0 === -1) {
          for (let L0 = 0; L0 < g.length; L0++)
            if (L0 >= b[q(3105)]) {
              b[q(3156)](e0), p0 = L0;
              break;
            } else if (b[L0] === null) {
              b[L0] = e0, p0 = L0;
              break;
            }
          if (p0 === -1)
            break;
        }
        const y0 = g[p0];
        y0 && y0.connect(e0);
      }
    }
    const X = new z(), n0 = new z();
    function b0(s0, q, a0) {
      const e0 = t;
      X[e0(683)](q.matrixWorld), n0[e0(683)](a0[e0(490)]);
      const p0 = X[e0(3570)](n0), y0 = q[e0(1057)].elements, L0 = a0[e0(1057)].elements, k0 = y0[14] / (y0[10] - 1), Q0 = y0[14] / (y0[10] + 1), U0 = (y0[9] + 1) / y0[5], xx = (y0[9] - 1) / y0[5], _0 = (y0[8] - 1) / y0[0], E0 = (L0[8] + 1) / L0[0], O0 = k0 * _0, D0 = k0 * E0, N0 = p0 / (-_0 + E0), B0 = N0 * -_0;
      q[e0(490)].decompose(s0.position, s0[e0(3055)], s0.scale), s0[e0(2789)](B0), s0.translateZ(N0), s0[e0(490)][e0(1825)](s0[e0(3571)], s0[e0(3055)], s0[e0(2204)]), s0.matrixWorldInverse[e0(2875)](s0[e0(490)])[e0(1525)]();
      const X0 = k0 + N0, fx = Q0 + N0, vx = O0 - B0, B = D0 + (p0 - B0), E = U0 * Q0 / fx * X0, j = xx * Q0 / fx * X0;
      s0[e0(1057)][e0(1931)](vx, B, E, j, X0, fx);
    }
    function Q(s0, q) {
      const a0 = t;
      q === null ? s0[a0(490)][a0(2875)](s0.matrix) : s0[a0(490)][a0(3117)](q.matrixWorld, s0[a0(1067)]), s0.matrixWorldInverse.copy(s0.matrixWorld)[a0(1525)]();
    }
    this[t(3463)] = function(s0) {
      const q = t;
      if (n === null)
        return;
      I[q(1448)] = P[q(1448)] = L[q(1448)] = s0[q(1448)], I[q(3691)] = P[q(3691)] = L[q(3691)] = s0[q(3691)], (C !== I[q(1448)] || G !== I[q(3691)]) && (n[q(1189)]({ depthNear: I.near, depthFar: I[q(3691)] }), C = I[q(1448)], G = I[q(3691)]);
      const a0 = s0.parent, e0 = I[q(1752)];
      Q(I, a0);
      for (let y0 = 0; y0 < e0[q(3105)]; y0++)
        Q(e0[y0], a0);
      I.matrixWorld[q(3653)](I.position, I[q(3055)], I[q(2204)]), s0[q(1067)][q(2875)](I[q(1067)]), s0[q(1067)][q(3653)](s0[q(3571)], s0[q(3055)], s0[q(2204)]);
      const p0 = s0.children;
      for (let y0 = 0, L0 = p0.length; y0 < L0; y0++)
        p0[y0][q(3640)](!![]);
      e0[q(3105)] === 2 ? b0(I, L, P) : I[q(1057)][q(2875)](L.projectionMatrix);
    }, this[t(868)] = function() {
      return I;
    }, this[t(2878)] = function() {
      if (!(l === null && _ === null))
        return c;
    }, this[t(1950)] = function(s0) {
      const q = t;
      c = s0, l !== null && (l.fixedFoveation = s0), _ !== null && _[q(1750)] !== void 0 && (_[q(1750)] = s0);
    }, this[t(1135)] = function() {
      return M;
    };
    let r0 = null;
    function l0(s0, q) {
      const a0 = t;
      if (f = q[a0(1097)](h || r), p = q, f !== null) {
        const e0 = f[a0(1434)];
        _ !== null && (e[a0(1513)](v, _[a0(478)]), e.setRenderTarget(v));
        let p0 = ![];
        e0[a0(3105)] !== I[a0(1752)][a0(3105)] && (I[a0(1752)][a0(3105)] = 0, p0 = !![]);
        for (let y0 = 0; y0 < e0.length; y0++) {
          const L0 = e0[y0];
          let k0 = null;
          if (_ !== null)
            k0 = _[a0(3109)](L0);
          else {
            const U0 = u[a0(2418)](l, L0);
            k0 = U0[a0(2483)], y0 === 0 && (e[a0(3418)](v, U0.colorTexture, l[a0(1613)] ? void 0 : U0.depthStencilTexture), e.setRenderTarget(v));
          }
          let Q0 = S[y0];
          Q0 === void 0 && (Q0 = new Vx(), Q0[a0(479)][a0(3167)](y0), Q0.viewport = new Mx(), S[y0] = Q0), Q0[a0(1067)][a0(666)](L0[a0(3337)][a0(1067)]), Q0[a0(1057)].fromArray(L0[a0(1057)]), Q0[a0(2483)][a0(1260)](k0.x, k0.y, k0.width, k0.height), y0 === 0 && I[a0(1067)][a0(2875)](Q0[a0(1067)]), p0 === !![] && I[a0(1752)][a0(3156)](Q0);
        }
      }
      for (let e0 = 0; e0 < g[a0(3105)]; e0++) {
        const p0 = b[e0], y0 = g[e0];
        p0 !== null && y0 !== void 0 && y0[a0(3452)](p0, q, h || r);
      }
      if (r0 && r0(s0, q), q[a0(2709)]) {
        i[a0(3157)]({ type: a0(2623), data: q[a0(2709)] });
        let e0 = null;
        for (const p0 of M)
          !q[a0(2709)][a0(2086)](p0) && (e0 === null && (e0 = []), e0[a0(3156)](p0));
        if (e0 !== null)
          for (const p0 of e0)
            M.delete(p0), A[a0(2850)](p0), i.dispatchEvent({ type: a0(1924), data: p0 });
        for (const p0 of q[a0(2709)])
          if (!M[a0(2086)](p0))
            M.add(p0), A.set(p0, q.lastChangedTime), i[a0(3157)]({ type: a0(784), data: p0 });
          else {
            const y0 = A[a0(3016)](p0);
            p0[a0(1514)] > y0 && (A[a0(1260)](p0, p0[a0(1514)]), i[a0(3157)]({ type: a0(2120), data: p0 }));
          }
      }
      p = null;
    }
    const v0 = new qd();
    v0.setAnimationLoop(l0), this[t(2055)] = function(s0) {
      r0 = s0;
    }, this[t(3387)] = function() {
    };
  }
}
function $p(d, e) {
  function x(p, m) {
    const y = c0;
    m[y(3282)][y(2657)](p[y(1987)][y(1811)], Wd(d)), m[y(541)] ? (p.fogNear[y(1811)] = m[y(1448)], p[y(2555)][y(1811)] = m.far) : m[y(1003)] && (p[y(966)][y(1811)] = m[y(2294)]);
  }
  function t(p, m, y, v, g) {
    const b = c0;
    m[b(500)] || m[b(2251)] ? i(p, m) : m.isMeshToonMaterial ? (i(p, m), h(p, m)) : m[b(3052)] ? (i(p, m), c(p, m)) : m[b(2589)] ? (i(p, m), f(p, m), m.isMeshPhysicalMaterial && u(p, m, g)) : m[b(1966)] ? (i(p, m), l(p, m)) : m[b(2043)] ? i(p, m) : m.isMeshDistanceMaterial ? (i(p, m), _(p, m)) : m[b(3371)] ? i(p, m) : m[b(2198)] ? (n(p, m), m[b(1770)] && a(p, m)) : m.isPointsMaterial ? r(p, m, y, v) : m[b(1093)] ? o(p, m) : m[b(3769)] ? (p[b(3282)].value.copy(m[b(3282)]), p[b(3746)][b(1811)] = m[b(3746)]) : m[b(2488)] && (m[b(1623)] = ![]);
  }
  function i(p, m) {
    const y = c0;
    p[y(3746)][y(1811)] = m[y(3746)], m[y(3282)] && p.diffuse[y(1811)][y(2875)](m[y(3282)]), m[y(1599)] && p[y(1599)][y(1811)].copy(m.emissive)[y(580)](m[y(1148)]), m[y(3644)] && (p[y(3644)][y(1811)] = m.map), m[y(1453)] && (p.alphaMap[y(1811)] = m[y(1453)]), m.bumpMap && (p[y(758)].value = m[y(758)], p[y(470)].value = m.bumpScale, m.side === re && (p[y(470)][y(1811)] *= -1)), m[y(629)] && (p[y(629)][y(1811)] = m[y(629)], p[y(2693)][y(1811)] = m[y(2693)], p[y(498)][y(1811)] = m[y(498)]), m[y(2730)] && (p[y(2730)][y(1811)] = m.emissiveMap), m.normalMap && (p[y(811)][y(1811)] = m.normalMap, p[y(2650)].value.copy(m[y(2650)]), m.side === re && p[y(2650)][y(1811)][y(3515)]()), m[y(3470)] && (p[y(3470)][y(1811)] = m[y(3470)]), m.alphaTest > 0 && (p.alphaTest[y(1811)] = m[y(3303)]);
    const v = e[y(3016)](m)[y(1477)];
    if (v && (p.envMap.value = v, p[y(3234)][y(1811)] = v.isCubeTexture && v[y(546)] === ![] ? -1 : 1, p[y(2531)].value = m[y(2531)], p[y(3252)][y(1811)] = m[y(3252)], p[y(3759)][y(1811)] = m[y(3759)]), m[y(2399)]) {
      p[y(2399)][y(1811)] = m[y(2399)];
      const M = d[y(1218)] === !![] ? Math.PI : 1;
      p.lightMapIntensity.value = m[y(623)] * M;
    }
    m[y(2107)] && (p[y(2107)][y(1811)] = m.aoMap, p[y(2702)].value = m[y(2702)]);
    let g;
    m[y(3644)] ? g = m[y(3644)] : m[y(3470)] ? g = m.specularMap : m.displacementMap ? g = m.displacementMap : m[y(811)] ? g = m[y(811)] : m[y(758)] ? g = m.bumpMap : m.roughnessMap ? g = m.roughnessMap : m[y(989)] ? g = m[y(989)] : m[y(1453)] ? g = m.alphaMap : m[y(2730)] ? g = m[y(2730)] : m[y(945)] ? g = m.clearcoatMap : m.clearcoatNormalMap ? g = m[y(3674)] : m[y(1660)] ? g = m[y(1660)] : m[y(2734)] ? g = m.iridescenceMap : m.iridescenceThicknessMap ? g = m[y(3360)] : m[y(1581)] ? g = m.specularIntensityMap : m.specularColorMap ? g = m[y(3637)] : m[y(2325)] ? g = m[y(2325)] : m[y(1051)] ? g = m[y(1051)] : m[y(2078)] ? g = m[y(2078)] : m.sheenRoughnessMap && (g = m.sheenRoughnessMap), g !== void 0 && (g[y(426)] && (g = g[y(2431)]), g[y(1126)] === !![] && g.updateMatrix(), p[y(1275)][y(1811)][y(2875)](g[y(1067)]));
    let b;
    m[y(2107)] ? b = m.aoMap : m[y(2399)] && (b = m[y(2399)]), b !== void 0 && (b[y(426)] && (b = b[y(2431)]), b[y(1126)] === !![] && b.updateMatrix(), p[y(2168)][y(1811)].copy(b[y(1067)]));
  }
  function n(p, m) {
    const y = c0;
    p[y(1622)][y(1811)][y(2875)](m.color), p.opacity[y(1811)] = m.opacity;
  }
  function a(p, m) {
    const y = c0;
    p[y(1831)][y(1811)] = m[y(1831)], p[y(1930)][y(1811)] = m[y(1831)] + m[y(2514)], p[y(2204)].value = m.scale;
  }
  function r(p, m, y, v) {
    const g = c0;
    p.diffuse[g(1811)][g(2875)](m.color), p[g(3746)][g(1811)] = m.opacity, p.size[g(1811)] = m[g(3073)] * y, p[g(2204)][g(1811)] = v * 0.5, m[g(3644)] && (p[g(3644)][g(1811)] = m[g(3644)]), m[g(1453)] && (p[g(1453)].value = m[g(1453)]), m[g(3303)] > 0 && (p[g(3303)][g(1811)] = m[g(3303)]);
    let b;
    m[g(3644)] ? b = m[g(3644)] : m.alphaMap && (b = m[g(1453)]), b !== void 0 && (b[g(1126)] === !![] && b[g(1290)](), p[g(1275)].value.copy(b.matrix));
  }
  function o(p, m) {
    const y = c0;
    p.diffuse[y(1811)].copy(m[y(3282)]), p.opacity[y(1811)] = m[y(3746)], p[y(591)][y(1811)] = m.rotation, m[y(3644)] && (p.map[y(1811)] = m[y(3644)]), m[y(1453)] && (p.alphaMap[y(1811)] = m.alphaMap), m[y(3303)] > 0 && (p.alphaTest[y(1811)] = m[y(3303)]);
    let v;
    m[y(3644)] ? v = m[y(3644)] : m[y(1453)] && (v = m[y(1453)]), v !== void 0 && (v[y(1126)] === !![] && v[y(1290)](), p[y(1275)].value[y(2875)](v[y(1067)]));
  }
  function c(p, m) {
    const y = c0;
    p[y(881)][y(1811)][y(2875)](m[y(881)]), p.shininess[y(1811)] = Math[y(1803)](m[y(1274)], 1e-4);
  }
  function h(p, m) {
    const y = c0;
    m[y(2767)] && (p[y(2767)].value = m[y(2767)]);
  }
  function f(p, m) {
    const y = c0;
    p[y(771)][y(1811)] = m[y(771)], p[y(1586)].value = m.metalness, m[y(3213)] && (p[y(3213)][y(1811)] = m[y(3213)]), m.metalnessMap && (p.metalnessMap[y(1811)] = m.metalnessMap), e[y(3016)](m)[y(1477)] && (p[y(3176)][y(1811)] = m[y(3176)]);
  }
  function u(p, m, y) {
    const v = c0;
    p[v(3252)][v(1811)] = m[v(3252)], m[v(1031)] > 0 && (p[v(807)][v(1811)][v(2875)](m[v(807)])[v(580)](m.sheen), p[v(1915)][v(1811)] = m.sheenRoughness, m.sheenColorMap && (p[v(2078)][v(1811)] = m.sheenColorMap), m.sheenRoughnessMap && (p[v(3168)][v(1811)] = m[v(3168)])), m[v(2317)] > 0 && (p[v(2317)][v(1811)] = m[v(2317)], p[v(1163)].value = m.clearcoatRoughness, m[v(945)] && (p.clearcoatMap[v(1811)] = m.clearcoatMap), m[v(1660)] && (p[v(1660)][v(1811)] = m[v(1660)]), m.clearcoatNormalMap && (p.clearcoatNormalScale.value[v(2875)](m[v(1111)]), p[v(3674)][v(1811)] = m.clearcoatNormalMap, m.side === re && p[v(1111)].value[v(3515)]())), m[v(3727)] > 0 && (p[v(3727)][v(1811)] = m[v(3727)], p[v(477)].value = m[v(477)], p[v(644)][v(1811)] = m[v(2845)][0], p[v(2605)][v(1811)] = m.iridescenceThicknessRange[1], m[v(2734)] && (p[v(2734)].value = m[v(2734)]), m[v(3360)] && (p.iridescenceThicknessMap[v(1811)] = m[v(3360)])), m[v(2123)] > 0 && (p[v(2123)][v(1811)] = m[v(2123)], p[v(3024)].value = y[v(2431)], p[v(2546)].value[v(1260)](y[v(1631)], y[v(1674)]), m[v(2325)] && (p[v(2325)][v(1811)] = m[v(2325)]), p[v(2908)][v(1811)] = m[v(2908)], m.thicknessMap && (p.thicknessMap.value = m[v(1051)]), p[v(532)][v(1811)] = m[v(532)], p.attenuationColor[v(1811)][v(2875)](m.attenuationColor)), p[v(1354)].value = m.specularIntensity, p.specularColor[v(1811)][v(2875)](m[v(3367)]), m[v(1581)] && (p[v(1581)].value = m[v(1581)]), m[v(3637)] && (p.specularColorMap[v(1811)] = m[v(3637)]);
  }
  function l(p, m) {
    const y = c0;
    m[y(1247)] && (p[y(1247)][y(1811)] = m[y(1247)]);
  }
  function _(p, m) {
    const y = c0;
    p[y(1115)][y(1811)].copy(m[y(1115)]), p[y(1225)][y(1811)] = m.nearDistance, p.farDistance[y(1811)] = m.farDistance;
  }
  return { refreshFogUniforms: x, refreshMaterialUniforms: t };
}
function Jp(d, e, x, t) {
  let i = {}, n = {}, a = [];
  const r = x.isWebGL2 ? d.getParameter(35375) : 0;
  function o(v, g) {
    const b = c0, M = g[b(2302)];
    t[b(3633)](v, M);
  }
  function c(v, g) {
    const b = c0;
    let M = i[v.id];
    M === void 0 && (_(v), M = h(v), i[v.id] = M, v[b(818)](b(3387), m));
    const A = g[b(2302)];
    t[b(3004)](v, A);
    const L = e[b(489)][b(1320)];
    n[v.id] !== L && (u(v), n[v.id] = L);
  }
  function h(v) {
    const g = c0, b = f();
    v.__bindingPointIndex = b;
    const M = d.createBuffer(), A = v[g(1367)], L = v.usage;
    return d[g(3224)](35345, M), d[g(3513)](35345, A, L), d.bindBuffer(35345, null), d[g(526)](35345, b, M), M;
  }
  function f() {
    const v = c0;
    for (let g = 0; g < r; g++)
      if (a[v(882)](g) === -1)
        return a[v(3156)](g), g;
    return console[v(533)]("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
  }
  function u(v) {
    const g = c0, b = i[v.id], M = v.uniforms, A = v[g(900)];
    d.bindBuffer(35345, b);
    for (let L = 0, P = M[g(3105)]; L < P; L++) {
      const S = M[L];
      if (l(S, L, A) === !![]) {
        const I = S.__offset, C = Array[g(1609)](S[g(1811)]) ? S[g(1811)] : [S[g(1811)]];
        let G = 0;
        for (let $ = 0; $ < C[g(3105)]; $++) {
          const N = C[$], V = p(N);
          typeof N == "number" ? (S[g(3546)][0] = N, d[g(3107)](35345, I + G, S[g(3546)])) : N.isMatrix3 ? (S[g(3546)][0] = N[g(717)][0], S[g(3546)][1] = N[g(717)][1], S.__data[2] = N[g(717)][2], S.__data[3] = N[g(717)][0], S[g(3546)][4] = N[g(717)][3], S.__data[5] = N[g(717)][4], S.__data[6] = N[g(717)][5], S[g(3546)][7] = N[g(717)][0], S[g(3546)][8] = N[g(717)][6], S[g(3546)][9] = N[g(717)][7], S.__data[10] = N[g(717)][8], S[g(3546)][11] = N[g(717)][0]) : (N[g(1496)](S[g(3546)], G), G += V.storage / Float32Array[g(2823)]);
        }
        d[g(3107)](35345, I, S[g(3546)]);
      }
    }
    d.bindBuffer(35345, null);
  }
  function l(v, g, b) {
    const M = c0, A = v[M(1811)];
    if (b[g] === void 0) {
      if (typeof A === M(1407))
        b[g] = A;
      else {
        const L = Array[M(1609)](A) ? A : [A], P = [];
        for (let S = 0; S < L[M(3105)]; S++)
          P[M(3156)](L[S][M(2272)]());
        b[g] = P;
      }
      return !![];
    } else if (typeof A == "number") {
      if (b[g] !== A)
        return b[g] = A, !![];
    } else {
      const L = Array.isArray(b[g]) ? b[g] : [b[g]], P = Array[M(1609)](A) ? A : [A];
      for (let S = 0; S < L[M(3105)]; S++) {
        const I = L[S];
        if (I.equals(P[S]) === ![])
          return I.copy(P[S]), !![];
      }
    }
    return ![];
  }
  function _(v) {
    const g = c0, b = v[g(2833)];
    let M = 0;
    const A = 16;
    let L = 0;
    for (let P = 0, S = b[g(3105)]; P < S; P++) {
      const I = b[P], C = { boundary: 0, storage: 0 }, G = Array.isArray(I[g(1811)]) ? I[g(1811)] : [I[g(1811)]];
      for (let $ = 0, N = G[g(3105)]; $ < N; $++) {
        const V = G[$], X = p(V);
        C[g(1671)] += X[g(1671)], C[g(2886)] += X[g(2886)];
      }
      if (I[g(3546)] = new Float32Array(C[g(2886)] / Float32Array[g(2823)]), I[g(1907)] = M, P > 0) {
        L = M % A;
        const $ = A - L;
        L !== 0 && $ - C[g(1671)] < 0 && (M += A - L, I[g(1907)] = M);
      }
      M += C[g(2886)];
    }
    return L = M % A, L > 0 && (M += A - L), v[g(1367)] = M, v[g(900)] = {}, this;
  }
  function p(v) {
    const g = c0, b = { boundary: 0, storage: 0 };
    return typeof v === g(1407) ? (b[g(1671)] = 4, b[g(2886)] = 4) : v[g(2134)] ? (b.boundary = 8, b.storage = 8) : v[g(3804)] || v[g(1035)] ? (b.boundary = 16, b[g(2886)] = 12) : v[g(703)] ? (b[g(1671)] = 16, b[g(2886)] = 16) : v.isMatrix3 ? (b[g(1671)] = 48, b[g(2886)] = 48) : v[g(3146)] ? (b[g(1671)] = 64, b[g(2886)] = 64) : v[g(1714)] ? console[g(3629)](g(1979)) : console[g(3629)](g(987), v), b;
  }
  function m(v) {
    const g = c0, b = v[g(671)];
    b[g(1079)]("dispose", m);
    const M = a[g(882)](b.__bindingPointIndex);
    a[g(1733)](M, 1), d[g(2948)](i[b.id]), delete i[b.id], delete n[b.id];
  }
  function y() {
    const v = c0;
    for (const g in i)
      d[v(2948)](i[g]);
    a = [], i = {}, n = {};
  }
  return { bind: o, update: c, dispose: y };
}
function Qp() {
  const d = s, e = Un(d(651));
  return e[d(433)][d(1056)] = d(2181), e;
}
function Ta(d = {}) {
  const e = s;
  this.isWebGLRenderer = !![];
  const x = d[e(651)] !== void 0 ? d[e(651)] : Qp(), t = d.context !== void 0 ? d[e(1607)] : null, i = d.depth !== void 0 ? d[e(3611)] : !![], n = d.stencil !== void 0 ? d.stencil : !![], a = d[e(3614)] !== void 0 ? d[e(3614)] : ![], r = d[e(624)] !== void 0 ? d[e(624)] : !![], o = d[e(1995)] !== void 0 ? d[e(1995)] : ![], c = d[e(908)] !== void 0 ? d.powerPreference : e(2238), h = d[e(1307)] !== void 0 ? d[e(1307)] : ![];
  let f;
  t !== null ? f = t[e(3522)]()[e(800)] : f = d[e(800)] !== void 0 ? d[e(800)] : ![];
  let u = null, l = null;
  const _ = [], p = [];
  this[e(482)] = x, this.debug = { checkShaderErrors: !![] }, this[e(1363)] = !![], this[e(2e3)] = !![], this[e(3201)] = !![], this[e(2904)] = !![], this[e(476)] = !![], this.clippingPlanes = [], this[e(2575)] = ![], this[e(3565)] = Ne, this[e(1218)] = !![], this[e(602)] = We, this[e(950)] = 1;
  const m = this;
  let y = ![], v = 0, g = 0, b = null, M = -1, A = null;
  const L = new Mx(), P = new Mx();
  let S = null, I = x[e(1631)], C = x[e(1674)], G = 1, $ = null, N = null;
  const V = new Mx(0, 0, I, C), X = new Mx(0, 0, I, C);
  let n0 = ![];
  const b0 = new Ma();
  let Q = ![], r0 = ![], l0 = null;
  const v0 = new ix(), s0 = new z(), q = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !![] };
  function a0() {
    return b === null ? G : 1;
  }
  let e0 = t;
  function p0(O, K) {
    const Z = e;
    for (let D = 0; D < O.length; D++) {
      const W = O[D], F = x[Z(3271)](W, K);
      if (F !== null)
        return F;
    }
    return null;
  }
  try {
    const O = { alpha: !![], depth: i, stencil: n, antialias: a, premultipliedAlpha: r, preserveDrawingBuffer: o, powerPreference: c, failIfMajorPerformanceCaveat: h };
    if (e(3599) in x && x[e(3599)]("data-engine", e(3767) + pa), x.addEventListener("webglcontextlost", K0, ![]), x[e(818)](e(1396), j0, ![]), x[e(818)](e(2748), $0, ![]), e0 === null) {
      const K = [e(2991), e(2680), e(822)];
      if (m[e(3127)] === !![] && K[e(1184)](), e0 = p0(K, O), e0 === null)
        throw p0(K) ? new Error(e(2106)) : new Error(e(3013));
    }
    e0[e(3077)] === void 0 && (e0[e(3077)] = function() {
      return { rangeMin: 1, rangeMax: 1, precision: 1 };
    });
  } catch (O) {
    throw console.error(e(2412) + O[e(2622)]), O;
  }
  let y0, L0, k0, Q0, U0, xx, _0, E0, O0, D0, N0, B0, X0, fx, vx, B, E, j, R, h0, S0, R0, Z0, H0;
  function u0() {
    const O = e;
    y0 = new bb(e0), L0 = new cb(e0, y0, d), y0.init(L0), R0 = new Jd(e0, y0, L0), k0 = new qp(e0, y0, L0), Q0 = new gb(), U0 = new Np(), xx = new Yp(e0, y0, k0, U0, L0, R0, Q0), _0 = new hb(m), E0 = new ub(m), O0 = new Al(e0, L0), Z0 = new rb(e0, y0, O0, L0), D0 = new pb(e0, O0, Q0, Z0), N0 = new wb(e0, D0, O0, Q0), R = new yb(e0, L0, xx), B = new db(U0), B0 = new Op(m, _0, E0, y0, L0, Z0, B), X0 = new $p(m, U0), fx = new zp(), vx = new Vp(y0, L0), j = new ab(m, _0, E0, k0, N0, f, r), E = new Xp(m, N0, L0), H0 = new Jp(e0, Q0, L0, k0), h0 = new ob(e0, y0, Q0, L0), S0 = new mb(e0, y0, Q0, L0), Q0.programs = B0[O(2138)], m.capabilities = L0, m[O(3323)] = y0, m[O(1478)] = U0, m[O(1920)] = fx, m.shadowMap = E, m[O(739)] = k0, m.info = Q0;
  }
  u0();
  const V0 = new Kp(m, e0);
  this.xr = V0, this[e(3271)] = function() {
    return e0;
  }, this[e(3522)] = function() {
    return e0[e(3522)]();
  }, this[e(984)] = function() {
    const O = e, K = y0[O(3016)](O(1279));
    K && K.loseContext();
  }, this[e(3336)] = function() {
    const O = e, K = y0.get(O(1279));
    K && K[O(2054)]();
  }, this[e(3255)] = function() {
    return G;
  }, this[e(3797)] = function(O) {
    O !== void 0 && (G = O, this.setSize(I, C, ![]));
  }, this[e(561)] = function(O) {
    return O[e(1260)](I, C);
  }, this[e(531)] = function(O, K, Z = !![]) {
    const D = e;
    if (V0.isPresenting) {
      console[D(3629)](D(2420));
      return;
    }
    I = O, C = K, x[D(1631)] = Math[D(2697)](O * G), x[D(1674)] = Math[D(2697)](K * G), Z === !![] && (x[D(433)][D(1631)] = O + "px", x[D(433)].height = K + "px"), this[D(845)](0, 0, O, K);
  }, this.getDrawingBufferSize = function(O) {
    const K = e;
    return O.set(I * G, C * G)[K(2697)]();
  }, this.setDrawingBufferSize = function(O, K, Z) {
    const D = e;
    I = O, C = K, G = Z, x[D(1631)] = Math.floor(O * Z), x.height = Math.floor(K * Z), this[D(845)](0, 0, O, K);
  }, this.getCurrentViewport = function(O) {
    return O[e(2875)](L);
  }, this[e(3109)] = function(O) {
    return O.copy(V);
  }, this.setViewport = function(O, K, Z, D) {
    const W = e;
    O[W(703)] ? V.set(O.x, O.y, O.z, O.w) : V.set(O, K, Z, D), k0[W(2483)](L.copy(V)[W(580)](G).floor());
  }, this[e(2373)] = function(O) {
    return O[e(2875)](X);
  }, this[e(1921)] = function(O, K, Z, D) {
    const W = e;
    O[W(703)] ? X.set(O.x, O.y, O.z, O.w) : X[W(1260)](O, K, Z, D), k0[W(1833)](P[W(2875)](X)[W(580)](G)[W(2697)]());
  }, this[e(973)] = function() {
    return n0;
  }, this[e(732)] = function(O) {
    k0[e(732)](n0 = O);
  }, this[e(1076)] = function(O) {
    $ = O;
  }, this.setTransparentSort = function(O) {
    N = O;
  }, this[e(672)] = function(O) {
    const K = e;
    return O[K(2875)](j[K(672)]());
  }, this.setClearColor = function() {
    j[e(3203)].apply(j, arguments);
  }, this.getClearAlpha = function() {
    return j[e(942)]();
  }, this[e(1644)] = function() {
    const O = e;
    j[O(1644)][O(555)](j, arguments);
  }, this.clear = function(O = !![], K = !![], Z = !![]) {
    const D = e;
    let W = 0;
    O && (W |= 16384), K && (W |= 256), Z && (W |= 1024), e0[D(1089)](W);
  }, this[e(2557)] = function() {
    this[e(1089)](!![], ![], ![]);
  }, this[e(564)] = function() {
    this[e(1089)](![], !![], ![]);
  }, this[e(2901)] = function() {
    this.clear(![], ![], !![]);
  }, this[e(3387)] = function() {
    const O = e;
    x[O(1079)]("webglcontextlost", K0, ![]), x.removeEventListener(O(1396), j0, ![]), x[O(1079)](O(2748), $0, ![]), fx.dispose(), vx[O(3387)](), U0[O(3387)](), _0.dispose(), E0[O(3387)](), N0.dispose(), Z0[O(3387)](), H0.dispose(), B0[O(3387)](), V0[O(3387)](), V0[O(1079)](O(3289), t0), V0[O(1079)]("sessionend", A0), l0 && (l0[O(3387)](), l0 = null), w0.stop();
  };
  function K0(O) {
    const K = e;
    O[K(436)](), console[K(2773)](K(3585)), y = !![];
  }
  function j0() {
    const O = e;
    console.log(O(525)), y = ![];
    const K = Q0[O(744)], Z = E[O(2679)], D = E[O(1012)], W = E.needsUpdate, F = E[O(566)];
    u0(), Q0[O(744)] = K, E[O(2679)] = Z, E[O(1012)] = D, E[O(3035)] = W, E[O(566)] = F;
  }
  function $0(O) {
    const K = e;
    console[K(533)](K(3739), O[K(1763)]);
  }
  function Y0(O) {
    const K = e, Z = O.target;
    Z[K(1079)](K(3387), Y0), sx(Z);
  }
  function sx(O) {
    cx(O), U0.remove(O);
  }
  function cx(O) {
    const K = e, Z = U0.get(O)[K(2138)];
    Z !== void 0 && (Z[K(1220)](function(D) {
      B0.releaseProgram(D);
    }), O[K(2488)] && B0[K(1075)](O));
  }
  this.renderBufferDirect = function(O, K, Z, D, W, F) {
    const w = e;
    K === null && (K = q);
    const T = W.isMesh && W[w(490)].determinant() < 0, U = sn(O, K, Z, D, W);
    k0[w(709)](D, T);
    let H = Z.index, i0 = 1;
    D[w(1124)] === !![] && (H = D0[w(1540)](Z), i0 = 2);
    const Y = Z.drawRange, J = Z.attributes[w(3571)];
    let f0 = Y[w(1917)] * i0, T0 = (Y[w(1917)] + Y[w(1267)]) * i0;
    F !== null && (f0 = Math[w(1803)](f0, F[w(1917)] * i0), T0 = Math.min(T0, (F[w(1917)] + F.count) * i0)), H !== null ? (f0 = Math.max(f0, 0), T0 = Math[w(3085)](T0, H.count)) : J != null && (f0 = Math[w(1803)](f0, 0), T0 = Math[w(3085)](T0, J[w(1267)]));
    const g0 = T0 - f0;
    if (g0 < 0 || g0 === 1 / 0)
      return;
    Z0[w(598)](W, D, U, Z, H);
    let M0, m0 = h0;
    if (H !== null && (M0 = O0[w(3016)](H), m0 = S0, m0[w(2203)](M0)), W[w(3464)])
      D[w(1124)] === !![] ? (k0[w(3022)](D[w(977)] * a0()), m0[w(2392)](1)) : m0[w(2392)](4);
    else if (W.isLine) {
      let C0 = D[w(2968)];
      C0 === void 0 && (C0 = 1), k0[w(3022)](C0 * a0()), W[w(2505)] ? m0[w(2392)](1) : W.isLineLoop ? m0[w(2392)](2) : m0[w(2392)](3);
    } else
      W[w(3114)] ? m0[w(2392)](0) : W[w(516)] && m0[w(2392)](4);
    if (W[w(2342)])
      m0[w(2347)](f0, g0, W[w(1267)]);
    else if (Z.isInstancedBufferGeometry) {
      const C0 = Z._maxInstanceCount !== void 0 ? Z[w(2562)] : 1 / 0, z0 = Math[w(3085)](Z[w(1758)], C0);
      m0[w(2347)](f0, g0, z0);
    } else
      m0[w(489)](f0, g0);
  }, this.compile = function(O, K) {
    const Z = e;
    function D(W, F, w) {
      const T = c0;
      W[T(1885)] === !![] && W[T(679)] === ke && W[T(2611)] === ![] ? (W[T(679)] = re, W[T(3035)] = !![], ie(W, F, w), W[T(679)] = Xe, W[T(3035)] = !![], ie(W, F, w), W[T(679)] = ke) : ie(W, F, w);
    }
    l = vx[Z(3016)](O), l[Z(2156)](), p[Z(3156)](l), O[Z(2717)](function(W) {
      const F = Z;
      W.isLight && W[F(479)][F(1081)](K[F(479)]) && (l[F(2795)](W), W[F(2721)] && l[F(2778)](W));
    }), l.setupLights(m[Z(1218)]), O.traverse(function(W) {
      const F = Z, w = W[F(1870)];
      if (w)
        if (Array[F(1609)](w))
          for (let T = 0; T < w[F(3105)]; T++) {
            const U = w[T];
            D(U, O, W);
          }
        else
          D(w, O, W);
    }), p.pop(), l = null;
  };
  let k = null;
  function x0(O) {
    k && k(O);
  }
  function t0() {
    w0[e(914)]();
  }
  function A0() {
    w0[e(1917)]();
  }
  const w0 = new qd();
  w0[e(2055)](x0), typeof self < "u" && w0.setContext(self), this[e(2055)] = function(O) {
    const K = e;
    k = O, V0.setAnimationLoop(O), O === null ? w0.stop() : w0[K(1917)]();
  }, V0[e(818)]("sessionstart", t0), V0[e(818)](e(837), A0), this[e(489)] = function(O, K) {
    const Z = e;
    if (K !== void 0 && K.isCamera !== !![]) {
      console[Z(533)](Z(817));
      return;
    }
    if (y === !![])
      return;
    O[Z(3573)] === !![] && O.updateMatrixWorld(), K.parent === null && K[Z(3573)] === !![] && K.updateMatrixWorld(), V0[Z(2679)] === !![] && V0[Z(869)] === !![] && (V0[Z(2929)] === !![] && V0.updateCamera(K), K = V0[Z(868)]()), O.isScene === !![] && O[Z(3493)](m, O, K, b), l = vx[Z(3016)](O, p[Z(3105)]), l[Z(2156)](), p[Z(3156)](l), v0.multiplyMatrices(K.projectionMatrix, K[Z(1874)]), b0.setFromProjectionMatrix(v0), r0 = this[Z(2575)], Q = B[Z(2156)](this[Z(2617)], r0), u = fx[Z(3016)](O, _[Z(3105)]), u[Z(2156)](), _[Z(3156)](u), ax(O, K, 0, m[Z(476)]), u.finish(), m.sortObjects === !![] && u[Z(614)]($, N), Q === !![] && B[Z(2846)]();
    const D = l.state[Z(2049)];
    if (E[Z(489)](D, O, K), Q === !![] && B[Z(1616)](), this[Z(2128)][Z(744)] === !![] && this[Z(2128)][Z(2007)](), j[Z(489)](u, O), l[Z(1128)](m[Z(1218)]), K[Z(1356)]) {
      const W = K[Z(1752)];
      for (let F = 0, w = W.length; F < w; F++) {
        const T = W[F];
        Ex(u, O, T, T.viewport);
      }
    } else
      Ex(u, O, K);
    b !== null && (xx[Z(2285)](b), xx.updateRenderTargetMipmap(b)), O[Z(1444)] === !![] && O[Z(2564)](m, O, K), Z0.resetDefaultState(), M = -1, A = null, p[Z(465)](), p[Z(3105)] > 0 ? l = p[p.length - 1] : l = null, _[Z(465)](), _[Z(3105)] > 0 ? u = _[_[Z(3105)] - 1] : u = null;
  };
  function ax(O, K, Z, D) {
    const W = e;
    if (O[W(2456)] === ![])
      return;
    if (O.layers.test(K[W(479)])) {
      if (O[W(801)])
        Z = O[W(704)];
      else if (O.isLOD)
        O.autoUpdate === !![] && O[W(3452)](K);
      else if (O[W(669)])
        l[W(2795)](O), O[W(2721)] && l[W(2778)](O);
      else if (O.isSprite) {
        if (!O.frustumCulled || b0.intersectsSprite(O)) {
          D && s0[W(683)](O[W(490)]).applyMatrix4(v0);
          const T = N0[W(3452)](O), U = O.material;
          U[W(2456)] && u.push(O, T, U, Z, s0.z, null);
        }
      } else if ((O[W(3464)] || O.isLine || O[W(3114)]) && (O[W(1918)] && O[W(962)][W(1320)] !== Q0.render[W(1320)] && (O[W(962)][W(3452)](), O[W(962)][W(1320)] = Q0[W(489)].frame), !O[W(3431)] || b0[W(1259)](O))) {
        D && s0.setFromMatrixPosition(O[W(490)])[W(2442)](v0);
        const T = N0[W(3452)](O), U = O[W(1870)];
        if (Array[W(1609)](U)) {
          const H = T[W(2751)];
          for (let i0 = 0, Y = H[W(3105)]; i0 < Y; i0++) {
            const J = H[i0], f0 = U[J[W(2163)]];
            f0 && f0[W(2456)] && u[W(3156)](O, T, f0, Z, s0.z, J);
          }
        } else
          U[W(2456)] && u[W(3156)](O, T, U, Z, s0.z, null);
      }
    }
    const w = O[W(3049)];
    for (let T = 0, U = w[W(3105)]; T < U; T++)
      ax(w[T], K, Z, D);
  }
  function Ex(O, K, Z, D) {
    const W = e, F = O[W(3505)], w = O.transmissive, T = O[W(1885)];
    l[W(1944)](Z), Q === !![] && B[W(3274)](m[W(2617)], Z), w[W(3105)] > 0 && kx(F, K, Z), D && k0[W(2483)](L[W(2875)](D)), F[W(3105)] > 0 && Px(F, K, Z), w.length > 0 && Px(w, K, Z), T.length > 0 && Px(T, K, Z), k0[W(2563)][W(3611)][W(2942)](!![]), k0[W(2563)][W(3611)][W(926)](!![]), k0[W(2563)].color[W(926)](!![]), k0.setPolygonOffset(![]);
  }
  function kx(O, K, Z) {
    const D = e, W = L0.isWebGL2;
    l0 === null && (l0 = new oe(1024, 1024, { generateMipmaps: !![], type: y0[D(2086)]("EXT_color_buffer_half_float") ? ue : At, minFilter: qe, samples: W && a === !![] ? 4 : 0 }));
    const F = m[D(427)]();
    m.setRenderTarget(l0), m.clear();
    const w = m[D(602)];
    m[D(602)] = We, Px(O, K, Z), m[D(602)] = w, xx.updateMultisampleRenderTarget(l0), xx[D(2069)](l0), m.setRenderTarget(F);
  }
  function Px(O, K, Z) {
    const D = e, W = K[D(1444)] === !![] ? K.overrideMaterial : null;
    for (let F = 0, w = O[D(3105)]; F < w; F++) {
      const T = O[F], U = T.object, H = T[D(1353)], i0 = W === null ? T[D(1870)] : W, Y = T.group;
      U.layers[D(1081)](Z[D(479)]) && Sx(U, K, Z, H, i0, Y);
    }
  }
  function Sx(O, K, Z, D, W, F) {
    const w = e;
    O.onBeforeRender(m, K, Z, D, W, F), O[w(2762)].multiplyMatrices(Z.matrixWorldInverse, O.matrixWorld), O.normalMatrix[w(1424)](O.modelViewMatrix), W[w(3493)](m, K, Z, D, O, F), W[w(1885)] === !![] && W[w(679)] === ke && W[w(2611)] === ![] ? (W[w(679)] = re, W[w(3035)] = !![], m[w(979)](Z, K, D, W, O, F), W[w(679)] = Xe, W[w(3035)] = !![], m.renderBufferDirect(Z, K, D, W, O, F), W[w(679)] = ke) : m.renderBufferDirect(Z, K, D, W, O, F), O[w(2564)](m, K, Z, D, W, F);
  }
  function ie(O, K, Z) {
    const D = e;
    K.isScene !== !![] && (K = q);
    const W = U0.get(O), F = l[D(739)].lights, w = l[D(739)][D(2049)], T = F.state[D(2185)], U = B0[D(2112)](O, F[D(739)], w, K, Z), H = B0.getProgramCacheKey(U);
    let i0 = W[D(2138)];
    W[D(3169)] = O[D(2589)] ? K[D(3169)] : null, W.fog = K[D(3438)], W[D(1477)] = (O[D(2589)] ? E0 : _0)[D(3016)](O[D(1477)] || W[D(3169)]), i0 === void 0 && (O[D(818)](D(3387), Y0), i0 = /* @__PURE__ */ new Map(), W[D(2138)] = i0);
    let Y = i0[D(3016)](H);
    if (Y !== void 0) {
      if (W[D(3262)] === Y && W[D(2782)] === T)
        return we(O, U), Y;
    } else
      U[D(2833)] = B0.getUniforms(O), O[D(985)](Z, U, m), O[D(2610)](U, m), Y = B0[D(2478)](U, H), i0.set(H, Y), W[D(2833)] = U.uniforms;
    const J = W[D(2833)];
    (!O.isShaderMaterial && !O[D(3704)] || O[D(1976)] === !![]) && (J[D(2617)] = B[D(3080)]), we(O, U), W[D(715)] = di(O), W.lightsStateVersion = T, W[D(715)] && (J.ambientLightColor.value = F[D(739)][D(2800)], J.lightProbe[D(1811)] = F[D(739)][D(1212)], J[D(1461)].value = F.state[D(3705)], J[D(3618)][D(1811)] = F.state.directionalShadow, J.spotLights[D(1811)] = F.state[D(1337)], J[D(2126)][D(1811)] = F[D(739)].spotShadow, J[D(1974)][D(1811)] = F[D(739)][D(2364)], J[D(2113)][D(1811)] = F[D(739)][D(2785)], J[D(1795)][D(1811)] = F.state[D(1229)], J[D(2419)].value = F[D(739)][D(1482)], J[D(3334)][D(1811)] = F.state.pointShadow, J[D(1254)][D(1811)] = F[D(739)][D(544)], J.directionalShadowMap[D(1811)] = F.state[D(2311)], J[D(634)].value = F[D(739)][D(634)], J.spotShadowMap.value = F[D(739)][D(1864)], J.spotLightMatrix[D(1811)] = F[D(739)].spotLightMatrix, J[D(2095)].value = F.state[D(2095)], J[D(1871)][D(1811)] = F.state[D(1871)], J.pointShadowMatrix[D(1811)] = F.state[D(653)]);
    const f0 = Y[D(486)](), T0 = da[D(1744)](f0[D(1873)], J);
    return W[D(3262)] = Y, W[D(3428)] = T0, Y;
  }
  function we(O, K) {
    const Z = e, D = U0.get(O);
    D[Z(3565)] = K[Z(3565)], D[Z(2177)] = K.instancing, D[Z(1427)] = K[Z(1427)], D[Z(2461)] = K.morphTargets, D.morphNormals = K[Z(2193)], D[Z(2103)] = K[Z(2103)], D[Z(3122)] = K.morphTargetsCount, D[Z(1037)] = K[Z(1037)], D[Z(3508)] = K.numClipIntersection, D[Z(3451)] = K[Z(3451)], D[Z(3202)] = K[Z(3202)], D[Z(602)] = K.toneMapping;
  }
  function sn(O, K, Z, D, W) {
    const F = e;
    K[F(1444)] !== !![] && (K = q), xx[F(3437)]();
    const w = K[F(3438)], T = D[F(2589)] ? K.environment : null, U = b === null ? m[F(3565)] : b[F(2764)] === !![] ? b[F(2431)][F(523)] : Ne, H = (D[F(2589)] ? E0 : _0)[F(3016)](D[F(1477)] || T), i0 = D.vertexColors === !![] && !!Z[F(3265)][F(3282)] && Z[F(3265)][F(3282)].itemSize === 4, Y = !!D[F(811)] && !!Z.attributes.tangent, J = !!Z.morphAttributes[F(3571)], f0 = !!Z[F(1034)].normal, T0 = !!Z[F(1034)].color, g0 = D[F(626)] ? m[F(602)] : We, M0 = Z[F(1034)][F(3571)] || Z[F(1034)].normal || Z.morphAttributes[F(3282)], m0 = M0 !== void 0 ? M0[F(3105)] : 0, C0 = U0[F(3016)](D), z0 = l.state[F(3054)];
    if (Q === !![] && (r0 === !![] || O !== A)) {
      const Ox = O === A && D.id === M;
      B[F(1520)](D, O, Ox);
    }
    let F0 = ![];
    D[F(2185)] === C0.__version ? C0[F(715)] && C0[F(2782)] !== z0[F(739)][F(2185)] ? F0 = !![] : C0.outputEncoding !== U ? F0 = !![] : W[F(2342)] && C0[F(2177)] === ![] ? F0 = !![] : !W[F(2342)] && C0[F(2177)] === !![] ? F0 = !![] : W[F(1918)] && C0[F(1427)] === ![] ? F0 = !![] : !W[F(1918)] && C0[F(1427)] === !![] ? F0 = !![] : C0[F(1477)] !== H ? F0 = !![] : D[F(3438)] === !![] && C0[F(3438)] !== w ? F0 = !![] : C0[F(1037)] !== void 0 && (C0[F(1037)] !== B[F(1336)] || C0[F(3508)] !== B[F(3508)]) ? F0 = !![] : C0.vertexAlphas !== i0 ? F0 = !![] : C0[F(3202)] !== Y ? F0 = !![] : C0.morphTargets !== J ? F0 = !![] : C0[F(2193)] !== f0 ? F0 = !![] : C0[F(2103)] !== T0 ? F0 = !![] : C0[F(602)] !== g0 ? F0 = !![] : L0[F(510)] === !![] && C0[F(3122)] !== m0 && (F0 = !![]) : (F0 = !![], C0[F(3053)] = D[F(2185)]);
    let J0 = C0[F(3262)];
    F0 === !![] && (J0 = ie(D, K, W));
    let q0 = ![], G0 = ![], lx = ![];
    const hx = J0.getUniforms(), yx = C0.uniforms;
    if (k0.useProgram(J0[F(2302)]) && (q0 = !![], G0 = !![], lx = !![]), D.id !== M && (M = D.id, G0 = !![]), q0 || A !== O) {
      if (hx.setValue(e0, "projectionMatrix", O.projectionMatrix), L0[F(428)] && hx[F(2249)](e0, F(1382), 2 / (Math[F(2773)](O[F(3691)] + 1) / Math[F(3113)])), A !== O && (A = O, G0 = !![], lx = !![]), D.isShaderMaterial || D[F(3052)] || D[F(1560)] || D[F(2589)] || D.envMap) {
        const Ox = hx[F(3644)][F(1595)];
        Ox !== void 0 && Ox.setValue(e0, s0[F(683)](O[F(490)]));
      }
      (D[F(3052)] || D[F(1560)] || D[F(2251)] || D[F(500)] || D.isMeshStandardMaterial || D[F(2488)]) && hx[F(2249)](e0, F(3497), O[F(519)] === !![]), (D[F(3052)] || D[F(1560)] || D[F(2251)] || D[F(500)] || D.isMeshStandardMaterial || D.isShaderMaterial || D[F(3769)] || W[F(1918)]) && hx[F(2249)](e0, "viewMatrix", O[F(1874)]);
    }
    if (W[F(1918)]) {
      hx.setOptional(e0, W, F(3363)), hx[F(2283)](e0, W, F(2262));
      const Ox = W.skeleton;
      Ox && (L0.floatVertexTextures ? (Ox[F(2930)] === null && Ox.computeBoneTexture(), hx[F(2249)](e0, "boneTexture", Ox[F(2930)], xx), hx[F(2249)](e0, F(1796), Ox[F(1796)])) : console[F(3629)](F(1816)));
    }
    const mx = Z[F(1034)];
    if ((mx[F(3571)] !== void 0 || mx[F(2111)] !== void 0 || mx[F(3282)] !== void 0 && L0[F(510)] === !![]) && R.update(W, Z, J0), (G0 || C0.receiveShadow !== W[F(1719)]) && (C0[F(1719)] = W[F(1719)], hx.setValue(e0, F(1719), W[F(1719)])), D[F(3207)] && D[F(1477)] !== null && (yx[F(1477)][F(1811)] = H, yx[F(3234)].value = H[F(3038)] && H[F(546)] === ![] ? -1 : 1), G0 && (hx[F(2249)](e0, F(950), m[F(950)]), C0[F(715)] && Ba(yx, lx), w && D.fog === !![] && X0[F(3617)](yx, w), X0[F(3655)](yx, D, G, C, l0), da[F(639)](e0, C0.uniformsList, yx, xx)), D[F(2488)] && D[F(1623)] === !![] && (da[F(639)](e0, C0[F(3428)], yx, xx), D[F(1623)] = ![]), D.isSpriteMaterial && hx[F(2249)](e0, "center", W.center), hx[F(2249)](e0, "modelViewMatrix", W.modelViewMatrix), hx.setValue(e0, F(2352), W[F(2352)]), hx[F(2249)](e0, F(3714), W[F(490)]), D[F(2488)] || D[F(3704)]) {
      const Ox = D[F(997)];
      for (let ex = 0, de = Ox[F(3105)]; ex < de; ex++)
        if (L0.isWebGL2) {
          const he = Ox[ex];
          H0[F(3452)](he, J0), H0[F(3529)](he, J0);
        } else
          console.warn(F(2802));
    }
    return J0;
  }
  function Ba(O, K) {
    const Z = e;
    O[Z(731)][Z(3035)] = K, O[Z(3199)][Z(3035)] = K, O.directionalLights.needsUpdate = K, O[Z(3618)].needsUpdate = K, O[Z(2419)][Z(3035)] = K, O.pointLightShadows.needsUpdate = K, O.spotLights.needsUpdate = K, O.spotLightShadows[Z(3035)] = K, O[Z(1974)][Z(3035)] = K, O[Z(1254)][Z(3035)] = K;
  }
  function di(O) {
    const K = e;
    return O[K(2251)] || O[K(1560)] || O[K(3052)] || O[K(2589)] || O[K(3769)] || O[K(2488)] && O[K(3054)] === !![];
  }
  this[e(2869)] = function() {
    return v;
  }, this.getActiveMipmapLevel = function() {
    return g;
  }, this[e(427)] = function() {
    return b;
  }, this[e(3418)] = function(O, K, Z) {
    const D = e;
    U0.get(O[D(2431)])[D(2046)] = K, U0[D(3016)](O[D(1708)])[D(2046)] = Z;
    const W = U0[D(3016)](O);
    W[D(3648)] = !![], W[D(3648)] && (W[D(1962)] = Z === void 0, !W.__autoAllocateDepthBuffer && y0[D(2086)](D(2598)) === !![] && (console[D(3629)]("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), W[D(2918)] = ![]));
  }, this.setRenderTargetFramebuffer = function(O, K) {
    const Z = e, D = U0[Z(3016)](O);
    D.__webglFramebuffer = K, D.__useDefaultFramebuffer = K === void 0;
  }, this[e(2969)] = function(O, K = 0, Z = 0) {
    const D = e;
    b = O, v = K, g = Z;
    let W = !![], F = null, w = ![], T = ![];
    if (O) {
      const H = U0[D(3016)](O);
      H.__useDefaultFramebuffer !== void 0 ? (k0.bindFramebuffer(36160, null), W = ![]) : H[D(1319)] === void 0 ? xx[D(3664)](O) : H[D(3648)] && xx.rebindTextures(O, U0.get(O.texture)[D(2046)], U0[D(3016)](O[D(1708)])[D(2046)]);
      const i0 = O[D(2431)];
      (i0.isData3DTexture || i0[D(1204)] || i0[D(2101)]) && (T = !![]);
      const Y = U0[D(3016)](O)[D(1319)];
      O[D(1676)] ? (F = Y[K], w = !![]) : L0[D(510)] && O.samples > 0 && xx.useMultisampledRTT(O) === ![] ? F = U0.get(O)[D(1244)] : F = Y, L.copy(O[D(2483)]), P[D(2875)](O.scissor), S = O[D(1199)];
    } else
      L[D(2875)](V)[D(580)](G)[D(2697)](), P[D(2875)](X)[D(580)](G)[D(2697)](), S = n0;
    if (k0[D(3781)](36160, F) && L0[D(1563)] && W && k0[D(1563)](O, F), k0[D(2483)](L), k0.scissor(P), k0[D(732)](S), w) {
      const H = U0[D(3016)](O[D(2431)]);
      e0[D(3057)](36160, 36064, 34069 + K, H.__webglTexture, Z);
    } else if (T) {
      const H = U0[D(3016)](O[D(2431)]), i0 = K || 0;
      e0.framebufferTextureLayer(36160, 36064, H[D(2046)], Z || 0, i0);
    }
    M = -1;
  }, this[e(1922)] = function(O, K, Z, D, W, F, w) {
    const T = e;
    if (!(O && O.isWebGLRenderTarget)) {
      console[T(533)](T(2269));
      return;
    }
    let U = U0[T(3016)](O)[T(1319)];
    if (O.isWebGLCubeRenderTarget && w !== void 0 && (U = U[w]), U) {
      k0[T(3781)](36160, U);
      try {
        const H = O.texture, i0 = H[T(448)], Y = H[T(566)];
        if (i0 !== le && R0[T(2708)](i0) !== e0.getParameter(35739)) {
          console[T(533)](T(1030));
          return;
        }
        const J = Y === ue && (y0.has("EXT_color_buffer_half_float") || L0[T(510)] && y0.has(T(1371)));
        if (Y !== At && R0[T(2708)](Y) !== e0[T(3516)](35738) && !(Y === ae && (L0.isWebGL2 || y0[T(2086)]("OES_texture_float") || y0[T(2086)](T(1899)))) && !J) {
          console[T(533)](T(833));
          return;
        }
        K >= 0 && K <= O[T(1631)] - D && Z >= 0 && Z <= O[T(1674)] - W && e0[T(1264)](K, Z, D, W, R0[T(2708)](i0), R0[T(2708)](Y), F);
      } finally {
        const H = b !== null ? U0[T(3016)](b)[T(1319)] : null;
        k0.bindFramebuffer(36160, H);
      }
    }
  }, this.copyFramebufferToTexture = function(O, K, Z = 0) {
    const D = e, W = Math[D(3196)](2, -Z), F = Math[D(2697)](K[D(450)][D(1631)] * W), w = Math[D(2697)](K[D(450)].height * W);
    xx[D(3670)](K, 0), e0.copyTexSubImage2D(3553, Z, 0, 0, O.x, O.y, F, w), k0[D(1346)]();
  }, this[e(716)] = function(O, K, Z, D = 0) {
    const W = e, F = K[W(450)][W(1631)], w = K.image.height, T = R0.convert(Z[W(448)]), U = R0[W(2708)](Z[W(566)]);
    xx[W(3670)](Z, 0), e0[W(3761)](37440, Z[W(1739)]), e0[W(3761)](37441, Z[W(3003)]), e0[W(3761)](3317, Z[W(2275)]), K.isDataTexture ? e0[W(1282)](3553, D, O.x, O.y, F, w, T, U, K[W(450)][W(2416)]) : K[W(3090)] ? e0.compressedTexSubImage2D(3553, D, O.x, O.y, K[W(2004)][0][W(1631)], K[W(2004)][0][W(1674)], T, K[W(2004)][0][W(2416)]) : e0[W(1282)](3553, D, O.x, O.y, T, U, K[W(450)]), D === 0 && Z[W(3632)] && e0.generateMipmap(3553), k0[W(1346)]();
  }, this[e(3215)] = function(O, K, Z, D, W = 0) {
    const F = e;
    if (m.isWebGL1Renderer) {
      console.warn(F(2173));
      return;
    }
    const w = O[F(1803)].x - O[F(3085)].x + 1, T = O[F(1803)].y - O[F(3085)].y + 1, U = O[F(1803)].z - O[F(3085)].z + 1, H = R0.convert(D[F(448)]), i0 = R0[F(2708)](D[F(566)]);
    let Y;
    if (D[F(1142)])
      xx[F(1884)](D, 0), Y = 32879;
    else if (D.isDataArrayTexture)
      xx.setTexture2DArray(D, 0), Y = 35866;
    else {
      console[F(3629)]("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
      return;
    }
    e0.pixelStorei(37440, D.flipY), e0[F(3761)](37441, D[F(3003)]), e0.pixelStorei(3317, D[F(2275)]);
    const J = e0[F(3516)](3314), f0 = e0.getParameter(32878), T0 = e0.getParameter(3316), g0 = e0.getParameter(3315), M0 = e0[F(3516)](32877), m0 = Z[F(3090)] ? Z.mipmaps[0] : Z.image;
    e0[F(3761)](3314, m0[F(1631)]), e0[F(3761)](32878, m0[F(1674)]), e0.pixelStorei(3316, O[F(3085)].x), e0[F(3761)](3315, O.min.y), e0[F(3761)](32877, O.min.z), Z.isDataTexture || Z[F(1142)] ? e0[F(3543)](Y, W, K.x, K.y, K.z, w, T, U, H, i0, m0[F(2416)]) : Z.isCompressedArrayTexture ? (console.warn(F(1091)), e0[F(3661)](Y, W, K.x, K.y, K.z, w, T, U, H, m0[F(2416)])) : e0[F(3543)](Y, W, K.x, K.y, K.z, w, T, U, H, i0, m0), e0[F(3761)](3314, J), e0[F(3761)](32878, f0), e0.pixelStorei(3316, T0), e0.pixelStorei(3315, g0), e0[F(3761)](32877, M0), W === 0 && D[F(3632)] && e0[F(1700)](Y), k0.unbindTexture();
  }, this[e(3690)] = function(O) {
    const K = e;
    O.isCubeTexture ? xx.setTextureCube(O, 0) : O.isData3DTexture ? xx[K(1884)](O, 0) : O[K(1204)] || O.isCompressedArrayTexture ? xx[K(3161)](O, 0) : xx.setTexture2D(O, 0), k0.unbindTexture();
  }, this[e(1381)] = function() {
    const O = e;
    v = 0, g = 0, b = null, k0.reset(), Z0[O(2007)]();
  }, typeof __THREE_DEVTOOLS__ !== e(2011) && __THREE_DEVTOOLS__[e(3157)](new CustomEvent(e(3276), { detail: this }));
}
Object.defineProperties(Ta[s(2028)], { physicallyCorrectLights: { get: function() {
  const d = s;
  return console.warn(d(3574)), !this[d(1218)];
}, set: function(d) {
  const e = s;
  console[e(3629)](e(3574)), this[e(1218)] = !d;
} } });
class eh extends Ta {
}
eh[s(2028)].isWebGL1Renderer = !![];
class Ea {
  constructor(e, x = 25e-5) {
    const t = s;
    this[t(1003)] = !![], this[t(3710)] = "", this[t(3282)] = new P0(e), this[t(2294)] = x;
  }
  [s(2272)]() {
    const e = s;
    return new Ea(this[e(3282)], this.density);
  }
  [s(3139)]() {
    const e = s;
    return { type: e(3233), color: this[e(3282)][e(2862)](), density: this[e(2294)] };
  }
}
class Aa {
  constructor(e, x = 1, t = 1e3) {
    const i = s;
    this[i(541)] = !![], this.name = "", this[i(3282)] = new P0(e), this[i(1448)] = x, this[i(3691)] = t;
  }
  [s(2272)]() {
    const e = s;
    return new Aa(this[e(3282)], this.near, this.far);
  }
  toJSON() {
    const e = s;
    return { type: e(2703), color: this[e(3282)][e(2862)](), near: this.near, far: this.far };
  }
}
class O2 extends px {
  constructor() {
    const e = s;
    super(), this[e(1444)] = !![], this[e(566)] = e(3524), this.background = null, this[e(3169)] = null, this[e(3438)] = null, this.backgroundBlurriness = 0, this[e(2217)] = 1, this[e(3170)] = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  [s(2875)](e, x) {
    const t = s;
    return super[t(2875)](e, x), e.background !== null && (this[t(2525)] = e.background[t(2272)]()), e[t(3169)] !== null && (this[t(3169)] = e[t(3169)][t(2272)]()), e[t(3438)] !== null && (this[t(3438)] = e.fog[t(2272)]()), this[t(2812)] = e[t(2812)], this[t(2217)] = e.backgroundIntensity, e[t(3170)] !== null && (this[t(3170)] = e.overrideMaterial.clone()), this[t(1126)] = e.matrixAutoUpdate, this;
  }
  [s(3139)](e) {
    const x = s, t = super.toJSON(e);
    return this.fog !== null && (t.object.fog = this[x(3438)][x(3139)]()), this.backgroundBlurriness > 0 && (t[x(1413)][x(2812)] = this[x(2812)]), this[x(2217)] !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity), t;
  }
  get autoUpdate() {
    return console.warn(s(3298)), this.matrixWorldAutoUpdate;
  }
  set [s(1012)](e) {
    const x = s;
    console[x(3629)](x(3298)), this[x(3573)] = e;
  }
}
class Yn {
  constructor(e, x) {
    const t = s;
    this[t(2009)] = !![], this[t(2712)] = e, this.stride = x, this[t(1267)] = e !== void 0 ? e[t(3105)] / x : 0, this[t(3067)] = On, this[t(2270)] = { offset: 0, count: -1 }, this[t(2185)] = 0, this[t(3104)] = ve();
  }
  [s(3773)]() {
  }
  set [s(3035)](e) {
    const x = s;
    e === !![] && this[x(2185)]++;
  }
  [s(3542)](e) {
    return this.usage = e, this;
  }
  [s(2875)](e) {
    const x = s;
    return this[x(2712)] = new e.array[x(2787)](e.array), this.count = e[x(1267)], this.stride = e.stride, this[x(3067)] = e[x(3067)], this;
  }
  [s(3028)](e, x, t) {
    const i = s;
    e *= this[i(2479)], t *= x[i(2479)];
    for (let n = 0, a = this.stride; n < a; n++)
      this[i(2712)][e + n] = x[i(2712)][t + n];
    return this;
  }
  set(e, x = 0) {
    const t = s;
    return this.array[t(1260)](e, x), this;
  }
  clone(e) {
    const x = s;
    e[x(2482)] === void 0 && (e[x(2482)] = {}), this[x(2712)].buffer[x(2226)] === void 0 && (this.array[x(2770)][x(2226)] = ve()), e[x(2482)][this[x(2712)][x(2770)]._uuid] === void 0 && (e.arrayBuffers[this[x(2712)][x(2770)][x(2226)]] = this.array.slice(0)[x(2770)]);
    const t = new this[x(2712)][x(2787)](e.arrayBuffers[this[x(2712)][x(2770)][x(2226)]]), i = new this[x(2787)](t, this[x(2479)]);
    return i[x(3542)](this[x(3067)]), i;
  }
  [s(2848)](e) {
    const x = s;
    return this[x(3773)] = e, this;
  }
  toJSON(e) {
    const x = s;
    return e[x(2482)] === void 0 && (e[x(2482)] = {}), this[x(2712)][x(2770)][x(2226)] === void 0 && (this[x(2712)][x(2770)][x(2226)] = ve()), e[x(2482)][this[x(2712)][x(2770)][x(2226)]] === void 0 && (e[x(2482)][this.array[x(2770)][x(2226)]] = Array.from(new Uint32Array(this[x(2712)][x(2770)]))), { uuid: this[x(3104)], buffer: this.array.buffer[x(2226)], type: this[x(2712)][x(2787)][x(3710)], stride: this[x(2479)] };
  }
}
const ne = new z();
class Ct {
  constructor(e, x, t, i = ![]) {
    const n = s;
    this[n(3154)] = !![], this[n(3710)] = "", this[n(2416)] = e, this[n(3290)] = x, this[n(592)] = t, this[n(3320)] = i;
  }
  get [s(1267)]() {
    return this.data.count;
  }
  get [s(2712)]() {
    const e = s;
    return this[e(2416)][e(2712)];
  }
  set needsUpdate(e) {
    const x = s;
    this[x(2416)][x(3035)] = e;
  }
  [s(2442)](e) {
    const x = s;
    for (let t = 0, i = this[x(2416)][x(1267)]; t < i; t++)
      ne.fromBufferAttribute(this, t), ne.applyMatrix4(e), this[x(1167)](t, ne.x, ne.y, ne.z);
    return this;
  }
  applyNormalMatrix(e) {
    const x = s;
    for (let t = 0, i = this.count; t < i; t++)
      ne.fromBufferAttribute(this, t), ne.applyNormalMatrix(e), this[x(1167)](t, ne.x, ne.y, ne.z);
    return this;
  }
  [s(1657)](e) {
    const x = s;
    for (let t = 0, i = this[x(1267)]; t < i; t++)
      ne[x(804)](this, t), ne[x(1657)](e), this[x(1167)](t, ne.x, ne.y, ne.z);
    return this;
  }
  [s(2357)](e, x) {
    const t = s;
    return this.normalized && (x = Ax(x, this[t(2712)])), this[t(2416)][t(2712)][e * this[t(2416)][t(2479)] + this[t(592)]] = x, this;
  }
  [s(712)](e, x) {
    const t = s;
    return this[t(3320)] && (x = Ax(x, this[t(2712)])), this.data.array[e * this[t(2416)][t(2479)] + this[t(592)] + 1] = x, this;
  }
  setZ(e, x) {
    const t = s;
    return this[t(3320)] && (x = Ax(x, this[t(2712)])), this[t(2416)][t(2712)][e * this[t(2416)][t(2479)] + this.offset + 2] = x, this;
  }
  setW(e, x) {
    const t = s;
    return this[t(3320)] && (x = Ax(x, this[t(2712)])), this.data[t(2712)][e * this.data.stride + this.offset + 3] = x, this;
  }
  [s(781)](e) {
    const x = s;
    let t = this[x(2416)][x(2712)][e * this[x(2416)][x(2479)] + this[x(592)]];
    return this[x(3320)] && (t = it(t, this[x(2712)])), t;
  }
  getY(e) {
    const x = s;
    let t = this[x(2416)].array[e * this[x(2416)][x(2479)] + this.offset + 1];
    return this.normalized && (t = it(t, this[x(2712)])), t;
  }
  [s(1341)](e) {
    const x = s;
    let t = this[x(2416)].array[e * this.data[x(2479)] + this.offset + 2];
    return this.normalized && (t = it(t, this[x(2712)])), t;
  }
  getW(e) {
    const x = s;
    let t = this.data.array[e * this[x(2416)][x(2479)] + this[x(592)] + 3];
    return this.normalized && (t = it(t, this.array)), t;
  }
  [s(3011)](e, x, t) {
    const i = s;
    return e = e * this[i(2416)][i(2479)] + this[i(592)], this[i(3320)] && (x = Ax(x, this[i(2712)]), t = Ax(t, this[i(2712)])), this[i(2416)][i(2712)][e + 0] = x, this[i(2416)][i(2712)][e + 1] = t, this;
  }
  [s(1167)](e, x, t, i) {
    const n = s;
    return e = e * this[n(2416)][n(2479)] + this[n(592)], this[n(3320)] && (x = Ax(x, this.array), t = Ax(t, this[n(2712)]), i = Ax(i, this[n(2712)])), this.data[n(2712)][e + 0] = x, this[n(2416)][n(2712)][e + 1] = t, this[n(2416)][n(2712)][e + 2] = i, this;
  }
  [s(3002)](e, x, t, i, n) {
    const a = s;
    return e = e * this.data[a(2479)] + this.offset, this[a(3320)] && (x = Ax(x, this[a(2712)]), t = Ax(t, this.array), i = Ax(i, this.array), n = Ax(n, this[a(2712)])), this.data.array[e + 0] = x, this[a(2416)].array[e + 1] = t, this.data.array[e + 2] = i, this[a(2416)].array[e + 3] = n, this;
  }
  clone(e) {
    const x = s;
    if (e === void 0) {
      console[x(2773)](x(1109));
      const t = [];
      for (let i = 0; i < this[x(1267)]; i++) {
        const n = i * this[x(2416)][x(2479)] + this.offset;
        for (let a = 0; a < this.itemSize; a++)
          t.push(this[x(2416)][x(2712)][n + a]);
      }
      return new gx(new this.array.constructor(t), this[x(3290)], this[x(3320)]);
    } else
      return e[x(3379)] === void 0 && (e[x(3379)] = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e[x(3379)][this[x(2416)][x(3104)]] = this.data.clone(e)), new Ct(e[x(3379)][this[x(2416)][x(3104)]], this[x(3290)], this[x(592)], this[x(3320)]);
  }
  toJSON(e) {
    const x = s;
    if (e === void 0) {
      console[x(2773)](x(1888));
      const t = [];
      for (let i = 0; i < this[x(1267)]; i++) {
        const n = i * this[x(2416)].stride + this.offset;
        for (let a = 0; a < this[x(3290)]; a++)
          t[x(3156)](this[x(2416)][x(2712)][n + a]);
      }
      return { itemSize: this.itemSize, type: this.array[x(2787)].name, array: t, normalized: this[x(3320)] };
    } else
      return e[x(3379)] === void 0 && (e[x(3379)] = {}), e.interleavedBuffers[this[x(2416)][x(3104)]] === void 0 && (e[x(3379)][this[x(2416)][x(3104)]] = this[x(2416)][x(3139)](e)), { isInterleavedBufferAttribute: !![], itemSize: this.itemSize, data: this.data[x(3104)], offset: this.offset, normalized: this.normalized };
  }
}
class N2 extends jx {
  constructor(e) {
    const x = s;
    super(), this.isSpriteMaterial = !![], this[x(566)] = "SpriteMaterial", this[x(3282)] = new P0(16777215), this[x(3644)] = null, this[x(1453)] = null, this[x(591)] = 0, this.sizeAttenuation = !![], this[x(1885)] = !![], this.fog = !![], this[x(1104)](e);
  }
  [s(2875)](e) {
    const x = s;
    return super[x(2875)](e), this[x(3282)][x(2875)](e[x(3282)]), this.map = e[x(3644)], this.alphaMap = e[x(1453)], this[x(591)] = e[x(591)], this[x(2907)] = e.sizeAttenuation, this.fog = e[x(3438)], this;
  }
}
let Si;
const un = new z(), Ti = new z(), Ei = new z(), Ai = new d0(), bn = new d0(), th = new ix(), Rs = new z(), pn = new z(), Ps = new z(), Go = new d0(), or = new d0(), Ho = new d0();
class ih extends px {
  constructor(e) {
    const x = s;
    if (super(), this[x(516)] = !![], this[x(566)] = x(1626), Si === void 0) {
      Si = new ox();
      const t = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]), i = new Yn(t, 5);
      Si[x(2203)]([0, 1, 2, 0, 2, 3]), Si[x(3599)](x(3571), new Ct(i, 3, 0, ![])), Si[x(3599)]("uv", new Ct(i, 2, 3, ![]));
    }
    this[x(1353)] = Si, this[x(1870)] = e !== void 0 ? e : new N2(), this[x(551)] = new d0(0.5, 0.5);
  }
  [s(2803)](e, x) {
    const t = s;
    e[t(2189)] === null && console[t(533)](t(3681)), Ti[t(1827)](this[t(490)]), th[t(2875)](e[t(2189)][t(490)]), this[t(2762)][t(3117)](e[t(2189)][t(1874)], this[t(490)]), Ei[t(683)](this[t(2762)]), e[t(2189)].isPerspectiveCamera && this[t(1870)][t(2907)] === ![] && Ti[t(580)](-Ei.z);
    const i = this[t(1870)][t(591)];
    let n, a;
    i !== 0 && (a = Math[t(2063)](i), n = Math.sin(i));
    const r = this[t(551)];
    Is(Rs[t(1260)](-0.5, -0.5, 0), Ei, r, Ti, n, a), Is(pn[t(1260)](0.5, -0.5, 0), Ei, r, Ti, n, a), Is(Ps[t(1260)](0.5, 0.5, 0), Ei, r, Ti, n, a), Go[t(1260)](0, 0), or[t(1260)](1, 0), Ho[t(1260)](1, 1);
    let o = e[t(1096)][t(1131)](Rs, pn, Ps, ![], un);
    if (o === null && (Is(pn[t(1260)](-0.5, 0.5, 0), Ei, r, Ti, n, a), or[t(1260)](0, 1), o = e[t(1096)][t(1131)](Rs, Ps, pn, ![], un), o === null))
      return;
    const c = e[t(1096)][t(1149)].distanceTo(un);
    c < e.near || c > e.far || x[t(3156)]({ distance: c, point: un.clone(), uv: Ee[t(457)](un, Rs, pn, Ps, Go, or, Ho, new d0()), face: null, object: this });
  }
  [s(2875)](e, x) {
    const t = s;
    return super[t(2875)](e, x), e.center !== void 0 && this[t(551)][t(2875)](e[t(551)]), this.material = e[t(1870)], this;
  }
}
function Is(d, e, x, t, i, n) {
  const a = s;
  Ai.subVectors(d, x)[a(3688)](0.5)[a(2246)](t), i !== void 0 ? (bn.x = n * Ai.x - i * Ai.y, bn.y = i * Ai.x + n * Ai.y) : bn.copy(Ai), d[a(2875)](e), d.x += bn.x, d.y += bn.y, d[a(2442)](th);
}
const Ds = new z(), ko = new z();
class nh extends px {
  constructor() {
    const e = s;
    super(), this._currentLevel = 0, this[e(566)] = e(1122), Object.defineProperties(this, { levels: { enumerable: !![], value: [] }, isLOD: { value: !![] } }), this.autoUpdate = !![];
  }
  [s(2875)](e) {
    const x = s;
    super[x(2875)](e, ![]);
    const t = e[x(3494)];
    for (let i = 0, n = t[x(3105)]; i < n; i++) {
      const a = t[i];
      this[x(1335)](a.object[x(2272)](), a[x(1183)], a[x(2977)]);
    }
    return this[x(1012)] = e[x(1012)], this;
  }
  [s(1335)](e, x = 0, t = 0) {
    const i = s;
    x = Math[i(3373)](x);
    const n = this[i(3494)];
    let a;
    for (a = 0; a < n[i(3105)] && !(x < n[a][i(1183)]); a++)
      ;
    return n[i(1733)](a, 0, { distance: x, hysteresis: t, object: e }), this.add(e), this;
  }
  [s(2366)]() {
    return this[s(2637)];
  }
  [s(3225)](e) {
    const x = s, t = this.levels;
    if (t.length > 0) {
      let i, n;
      for (i = 1, n = t[x(3105)]; i < n; i++) {
        let a = t[i][x(1183)];
        if (t[i][x(1413)][x(2456)] && (a -= a * t[i].hysteresis), e < a)
          break;
      }
      return t[i - 1][x(1413)];
    }
    return null;
  }
  [s(2803)](e, x) {
    const t = s;
    if (this[t(3494)][t(3105)] > 0) {
      Ds.setFromMatrixPosition(this[t(490)]);
      const n = e[t(1096)].origin.distanceTo(Ds);
      this.getObjectForDistance(n)[t(2803)](e, x);
    }
  }
  update(e) {
    const x = s, t = this[x(3494)];
    if (t[x(3105)] > 1) {
      Ds[x(683)](e[x(490)]), ko.setFromMatrixPosition(this[x(490)]);
      const i = Ds[x(3570)](ko) / e[x(2477)];
      t[0][x(1413)][x(2456)] = !![];
      let n, a;
      for (n = 1, a = t[x(3105)]; n < a; n++) {
        let r = t[n].distance;
        if (t[n].object[x(2456)] && (r -= r * t[n].hysteresis), i >= r)
          t[n - 1][x(1413)].visible = ![], t[n][x(1413)][x(2456)] = !![];
        else
          break;
      }
      for (this[x(2637)] = n - 1; n < a; n++)
        t[n][x(1413)].visible = ![];
    }
  }
  [s(3139)](e) {
    const x = s, t = super[x(3139)](e);
    this[x(1012)] === ![] && (t.object[x(1012)] = ![]), t[x(1413)].levels = [];
    const i = this[x(3494)];
    for (let n = 0, a = i[x(3105)]; n < a; n++) {
      const r = i[n];
      t[x(1413)][x(3494)][x(3156)]({ object: r[x(1413)][x(3104)], distance: r.distance, hysteresis: r.hysteresis });
    }
    return t;
  }
}
const Vo = new z(), Wo = new Mx(), jo = new Mx(), xm = new z(), Xo = new ix();
class U2 extends Wx {
  constructor(e, x) {
    const t = s;
    super(e, x), this[t(1918)] = !![], this[t(566)] = t(647), this.bindMode = t(2486), this[t(3363)] = new ix(), this.bindMatrixInverse = new ix();
  }
  [s(2875)](e, x) {
    const t = s;
    return super[t(2875)](e, x), this[t(1886)] = e[t(1886)], this[t(3363)].copy(e.bindMatrix), this[t(2262)][t(2875)](e.bindMatrixInverse), this[t(962)] = e[t(962)], this;
  }
  [s(3529)](e, x) {
    const t = s;
    this.skeleton = e, x === void 0 && (this[t(3640)](!![]), this[t(962)][t(1567)](), x = this[t(490)]), this[t(3363)].copy(x), this.bindMatrixInverse[t(2875)](x).invert();
  }
  [s(567)]() {
    const e = s;
    this[e(962)][e(567)]();
  }
  [s(2197)]() {
    const e = s, x = new Mx(), t = this[e(1353)][e(3265)][e(3441)];
    for (let i = 0, n = t.count; i < n; i++) {
      x.fromBufferAttribute(t, i);
      const a = 1 / x[e(1776)]();
      a !== 1 / 0 ? x.multiplyScalar(a) : x.set(1, 0, 0, 0), t[e(3002)](i, x.x, x.y, x.z, x.w);
    }
  }
  [s(3640)](e) {
    const x = s;
    super.updateMatrixWorld(e), this[x(1886)] === x(2486) ? this[x(2262)][x(2875)](this.matrixWorld).invert() : this[x(1886)] === x(795) ? this[x(2262)][x(2875)](this.bindMatrix).invert() : console[x(3629)](x(2085) + this[x(1886)]);
  }
  [s(1682)](e, x) {
    const t = s, i = this.skeleton, n = this[t(1353)];
    Wo[t(804)](n[t(3265)][t(3625)], e), jo[t(804)](n[t(3265)][t(3441)], e), Vo.copy(x)[t(2442)](this.bindMatrix), x[t(1260)](0, 0, 0);
    for (let a = 0; a < 4; a++) {
      const r = jo[t(788)](a);
      if (r !== 0) {
        const o = Wo[t(788)](a);
        Xo[t(3117)](i[t(3694)][o][t(490)], i[t(571)][o]), x[t(1990)](xm[t(2875)](Vo)[t(2442)](Xo), r);
      }
    }
    return x[t(2442)](this[t(2262)]);
  }
}
class Ca extends px {
  constructor() {
    const e = s;
    super(), this[e(1317)] = !![], this[e(566)] = "Bone";
  }
}
class Bi extends Ux {
  constructor(e = null, x = 1, t = 1, i, n, a, r, o, c = Bx, h = Bx, f, u) {
    const l = s;
    super(null, a, r, o, c, h, i, n, f, u), this.isDataTexture = !![], this[l(450)] = { data: e, width: x, height: t }, this[l(3632)] = ![], this[l(1739)] = ![], this[l(2275)] = 1;
  }
}
const qo = new ix(), em = new ix();
class Zn {
  constructor(e = [], x = []) {
    const t = s;
    this[t(3104)] = ve(), this.bones = e.slice(0), this.boneInverses = x, this[t(550)] = null, this[t(2930)] = null, this[t(1796)] = 0, this[t(1320)] = -1, this.init();
  }
  [s(2156)]() {
    const e = s, x = this[e(3694)], t = this[e(571)];
    if (this[e(550)] = new Float32Array(x.length * 16), t[e(3105)] === 0)
      this[e(1567)]();
    else if (x[e(3105)] !== t[e(3105)]) {
      console[e(3629)](e(1417)), this[e(571)] = [];
      for (let i = 0, n = this.bones[e(3105)]; i < n; i++)
        this[e(571)].push(new ix());
    }
  }
  [s(1567)]() {
    const e = s;
    this[e(571)][e(3105)] = 0;
    for (let x = 0, t = this[e(3694)][e(3105)]; x < t; x++) {
      const i = new ix();
      this.bones[x] && i.copy(this[e(3694)][x].matrixWorld)[e(1525)](), this[e(571)].push(i);
    }
  }
  [s(567)]() {
    const e = s;
    for (let x = 0, t = this[e(3694)][e(3105)]; x < t; x++) {
      const i = this[e(3694)][x];
      i && i.matrixWorld[e(2875)](this.boneInverses[x])[e(1525)]();
    }
    for (let x = 0, t = this[e(3694)][e(3105)]; x < t; x++) {
      const i = this[e(3694)][x];
      i && (i[e(3562)] && i[e(3562)].isBone ? (i[e(1067)].copy(i[e(3562)][e(490)])[e(1525)](), i[e(1067)][e(2246)](i[e(490)])) : i[e(1067)][e(2875)](i[e(490)]), i.matrix.decompose(i[e(3571)], i[e(3055)], i[e(2204)]));
    }
  }
  [s(3452)]() {
    const e = s, x = this.bones, t = this[e(571)], i = this[e(550)], n = this[e(2930)];
    for (let a = 0, r = x[e(3105)]; a < r; a++) {
      const o = x[a] ? x[a].matrixWorld : em;
      qo[e(3117)](o, t[a]), qo.toArray(i, a * 16);
    }
    n !== null && (n[e(3035)] = !![]);
  }
  [s(2272)]() {
    const e = s;
    return new Zn(this[e(3694)], this[e(571)]);
  }
  computeBoneTexture() {
    const e = s;
    let x = Math[e(713)](this[e(3694)][e(3105)] * 4);
    x = Fd(x), x = Math[e(1803)](x, 4);
    const t = new Float32Array(x * x * 4);
    t.set(this[e(550)]);
    const i = new Bi(t, x, x, le, ae);
    return i[e(3035)] = !![], this[e(550)] = t, this[e(2930)] = i, this[e(1796)] = x, this;
  }
  [s(504)](e) {
    const x = s;
    for (let t = 0, i = this[x(3694)][x(3105)]; t < i; t++) {
      const n = this[x(3694)][t];
      if (n[x(3710)] === e)
        return n;
    }
  }
  [s(3387)]() {
    const e = s;
    this[e(2930)] !== null && (this[e(2930)].dispose(), this.boneTexture = null);
  }
  [s(3037)](e, x) {
    const t = s;
    this[t(3104)] = e.uuid;
    for (let i = 0, n = e[t(3694)][t(3105)]; i < n; i++) {
      const a = e[t(3694)][i];
      let r = x[a];
      r === void 0 && (console[t(3629)](t(1633), a), r = new Ca()), this.bones[t(3156)](r), this[t(571)][t(3156)](new ix()[t(666)](e[t(571)][i]));
    }
    return this[t(2156)](), this;
  }
  [s(3139)]() {
    const e = s, x = { metadata: { version: 4.5, type: e(1735), generator: e(3541) }, bones: [], boneInverses: [] };
    x[e(3104)] = this[e(3104)];
    const t = this[e(3694)], i = this.boneInverses;
    for (let n = 0, a = t.length; n < a; n++) {
      const r = t[n];
      x.bones.push(r[e(3104)]);
      const o = i[n];
      x[e(571)].push(o[e(1496)]());
    }
    return x;
  }
}
class Wi extends gx {
  constructor(e, x, t, i = 1) {
    const n = s;
    super(e, x, t), this.isInstancedBufferAttribute = !![], this[n(656)] = i;
  }
  [s(2875)](e) {
    const x = s;
    return super.copy(e), this[x(656)] = e[x(656)], this;
  }
  toJSON() {
    const e = s, x = super[e(3139)]();
    return x.meshPerAttribute = this[e(656)], x[e(1242)] = !![], x;
  }
}
const Yo = new ix(), Zo = new ix(), Os = [], tm = new ix(), mn = new Wx();
class z2 extends Wx {
  constructor(e, x, t) {
    const i = s;
    super(e, x), this[i(2342)] = !![], this[i(1312)] = new Wi(new Float32Array(t * 16), 16), this[i(752)] = null, this[i(1267)] = t, this[i(3431)] = ![];
    for (let n = 0; n < t; n++)
      this[i(3651)](n, tm);
  }
  [s(2875)](e, x) {
    const t = s;
    return super[t(2875)](e, x), this[t(1312)][t(2875)](e.instanceMatrix), e[t(752)] !== null && (this.instanceColor = e[t(752)][t(2272)]()), this[t(1267)] = e[t(1267)], this;
  }
  getColorAt(e, x) {
    const t = s;
    x[t(666)](this[t(752)][t(2712)], e * 3);
  }
  [s(2278)](e, x) {
    const t = s;
    x.fromArray(this.instanceMatrix[t(2712)], e * 16);
  }
  [s(2803)](e, x) {
    const t = s, i = this.matrixWorld, n = this.count;
    if (mn[t(1353)] = this[t(1353)], mn[t(1870)] = this[t(1870)], mn[t(1870)] !== void 0)
      for (let a = 0; a < n; a++) {
        this[t(2278)](a, Yo), Zo[t(3117)](i, Yo), mn[t(490)] = Zo, mn.raycast(e, Os);
        for (let r = 0, o = Os[t(3105)]; r < o; r++) {
          const c = Os[r];
          c.instanceId = a, c[t(1413)] = this, x.push(c);
        }
        Os.length = 0;
      }
  }
  [s(3325)](e, x) {
    const t = s;
    this[t(752)] === null && (this.instanceColor = new Wi(new Float32Array(this[t(1312)][t(1267)] * 3), 3)), x[t(1496)](this.instanceColor[t(2712)], e * 3);
  }
  [s(3651)](e, x) {
    const t = s;
    x[t(1496)](this[t(1312)].array, e * 16);
  }
  [s(697)]() {
  }
  [s(3387)]() {
    const e = s;
    this[e(3157)]({ type: e(3387) });
  }
}
class te extends jx {
  constructor(e) {
    const x = s;
    super(), this[x(2198)] = !![], this[x(566)] = x(1249), this[x(3282)] = new P0(16777215), this.linewidth = 1, this.linecap = x(1981), this[x(3521)] = x(1981), this[x(3438)] = !![], this[x(1104)](e);
  }
  copy(e) {
    const x = s;
    return super[x(2875)](e), this[x(3282)][x(2875)](e[x(3282)]), this[x(2968)] = e[x(2968)], this[x(967)] = e[x(967)], this[x(3521)] = e[x(3521)], this[x(3438)] = e[x(3438)], this;
  }
}
const Ko = new z(), $o = new z(), Jo = new ix(), cr = new jn(), Ns = new Pt();
class st extends px {
  constructor(e = new ox(), x = new te()) {
    const t = s;
    super(), this[t(725)] = !![], this.type = t(2250), this[t(1353)] = e, this[t(1870)] = x, this[t(697)]();
  }
  copy(e, x) {
    const t = s;
    return super[t(2875)](e, x), this.material = e[t(1870)], this[t(1353)] = e[t(1353)], this;
  }
  [s(3613)]() {
    const e = s, x = this.geometry;
    if (x[e(3678)] === null) {
      const t = x.attributes[e(3571)], i = [0];
      for (let n = 1, a = t[e(1267)]; n < a; n++)
        Ko[e(804)](t, n - 1), $o[e(804)](t, n), i[n] = i[n - 1], i[n] += Ko[e(3570)]($o);
      x[e(3599)]("lineDistance", new W0(i, 1));
    } else
      console[e(3629)](e(3453));
    return this;
  }
  [s(2803)](e, x) {
    const t = s, i = this.geometry, n = this[t(490)], a = e[t(517)][t(2250)][t(556)], r = i[t(2499)];
    if (i[t(3689)] === null && i.computeBoundingSphere(), Ns.copy(i[t(3689)]), Ns[t(2442)](n), Ns.radius += a, e[t(1096)].intersectsSphere(Ns) === ![])
      return;
    Jo.copy(n).invert(), cr[t(2875)](e[t(1096)])[t(2442)](Jo);
    const o = a / ((this[t(2204)].x + this[t(2204)].y + this[t(2204)].z) / 3), c = o * o, h = new z(), f = new z(), u = new z(), l = new z(), _ = this.isLineSegments ? 2 : 1, p = i[t(3678)], m = i[t(3265)], y = m[t(3571)];
    if (p !== null) {
      const v = Math[t(1803)](0, r[t(1917)]), g = Math[t(3085)](p[t(1267)], r[t(1917)] + r[t(1267)]);
      for (let b = v, M = g - 1; b < M; b += _) {
        const A = p[t(781)](b), L = p[t(781)](b + 1);
        if (h[t(804)](y, A), f.fromBufferAttribute(y, L), cr[t(3069)](h, f, l, u) > c)
          continue;
        l[t(2442)](this[t(490)]);
        const S = e[t(1096)][t(1149)][t(3570)](l);
        S < e[t(1448)] || S > e[t(3691)] || x[t(3156)]({ distance: S, point: u[t(2272)]()[t(2442)](this[t(490)]), index: b, face: null, faceIndex: null, object: this });
      }
    } else {
      const v = Math[t(1803)](0, r[t(1917)]), g = Math[t(3085)](y[t(1267)], r[t(1917)] + r.count);
      for (let b = v, M = g - 1; b < M; b += _) {
        if (h[t(804)](y, b), f[t(804)](y, b + 1), cr[t(3069)](h, f, l, u) > c)
          continue;
        l[t(2442)](this[t(490)]);
        const L = e.ray[t(1149)][t(3570)](l);
        L < e[t(1448)] || L > e.far || x.push({ distance: L, point: u.clone()[t(2442)](this[t(490)]), index: b, face: null, faceIndex: null, object: this });
      }
    }
  }
  [s(697)]() {
    const e = s, x = this[e(1353)], t = x.morphAttributes, i = Object.keys(t);
    if (i[e(3105)] > 0) {
      const n = t[i[0]];
      if (n !== void 0) {
        this[e(2072)] = [], this[e(3398)] = {};
        for (let a = 0, r = n.length; a < r; a++) {
          const o = n[a].name || String(a);
          this.morphTargetInfluences[e(3156)](0), this.morphTargetDictionary[o] = a;
        }
      }
    }
  }
}
const Qo = new z(), xc = new z();
class Ue extends st {
  constructor(e, x) {
    const t = s;
    super(e, x), this[t(2505)] = !![], this[t(566)] = "LineSegments";
  }
  computeLineDistances() {
    const e = s, x = this[e(1353)];
    if (x[e(3678)] === null) {
      const t = x[e(3265)][e(3571)], i = [];
      for (let n = 0, a = t.count; n < a; n += 2)
        Qo.fromBufferAttribute(t, n), xc.fromBufferAttribute(t, n + 1), i[n] = n === 0 ? 0 : i[n - 1], i[n + 1] = i[n] + Qo[e(3570)](xc);
      x.setAttribute(e(480), new W0(i, 1));
    } else
      console[e(3629)](e(3402));
    return this;
  }
}
class B2 extends st {
  constructor(e, x) {
    const t = s;
    super(e, x), this[t(3396)] = !![], this[t(566)] = t(3132);
  }
}
class La extends jx {
  constructor(e) {
    const x = s;
    super(), this.isPointsMaterial = !![], this.type = x(3098), this[x(3282)] = new P0(16777215), this[x(3644)] = null, this[x(1453)] = null, this[x(3073)] = 1, this[x(2907)] = !![], this[x(3438)] = !![], this.setValues(e);
  }
  [s(2875)](e) {
    const x = s;
    return super[x(2875)](e), this[x(3282)][x(2875)](e[x(3282)]), this[x(3644)] = e[x(3644)], this[x(1453)] = e.alphaMap, this.size = e[x(3073)], this[x(2907)] = e[x(2907)], this[x(3438)] = e[x(3438)], this;
  }
}
const ec = new ix(), a2 = new jn(), Us = new Pt(), zs = new z();
class F2 extends px {
  constructor(e = new ox(), x = new La()) {
    const t = s;
    super(), this[t(3114)] = !![], this[t(566)] = t(2972), this.geometry = e, this[t(1870)] = x, this.updateMorphTargets();
  }
  copy(e, x) {
    const t = s;
    return super[t(2875)](e, x), this[t(1870)] = e[t(1870)], this.geometry = e[t(1353)], this;
  }
  raycast(e, x) {
    const t = s, i = this[t(1353)], n = this[t(490)], a = e[t(517)][t(2972)].threshold, r = i.drawRange;
    if (i.boundingSphere === null && i[t(2613)](), Us[t(2875)](i.boundingSphere), Us[t(2442)](n), Us[t(1232)] += a, e[t(1096)][t(2935)](Us) === ![])
      return;
    ec[t(2875)](n)[t(1525)](), a2.copy(e[t(1096)])[t(2442)](ec);
    const o = a / ((this[t(2204)].x + this[t(2204)].y + this.scale.z) / 3), c = o * o, h = i[t(3678)], f = i[t(3265)], u = f[t(3571)];
    if (h !== null) {
      const l = Math[t(1803)](0, r.start), _ = Math[t(3085)](h[t(1267)], r[t(1917)] + r[t(1267)]);
      for (let p = l, m = _; p < m; p++) {
        const y = h[t(781)](p);
        zs.fromBufferAttribute(u, y), tc(zs, y, c, n, e, x, this);
      }
    } else {
      const l = Math[t(1803)](0, r.start), _ = Math[t(3085)](u[t(1267)], r[t(1917)] + r.count);
      for (let p = l, m = _; p < m; p++)
        zs[t(804)](u, p), tc(zs, p, c, n, e, x, this);
    }
  }
  [s(697)]() {
    const e = s, x = this[e(1353)], t = x[e(1034)], i = Object[e(2070)](t);
    if (i.length > 0) {
      const n = t[i[0]];
      if (n !== void 0) {
        this[e(2072)] = [], this.morphTargetDictionary = {};
        for (let a = 0, r = n.length; a < r; a++) {
          const o = n[a][e(3710)] || String(a);
          this[e(2072)][e(3156)](0), this[e(3398)][o] = a;
        }
      }
    }
  }
}
function tc(d, e, x, t, i, n, a) {
  const r = s, o = a2[r(3786)](d);
  if (o < x) {
    const c = new z();
    a2[r(2559)](d, c), c[r(2442)](t);
    const h = i[r(1096)].origin[r(3570)](c);
    if (h < i[r(1448)] || h > i[r(3691)])
      return;
    n[r(3156)]({ distance: h, distanceToRay: Math[r(713)](o), point: c, index: e, face: null, object: a });
  }
}
class im extends Ux {
  constructor(e, x, t, i, n, a, r, o, c) {
    const h = s;
    super(e, x, t, i, n, a, r, o, c), this[h(2119)] = !![], this[h(991)] = a !== void 0 ? a : Cx, this[h(999)] = n !== void 0 ? n : Cx, this[h(3632)] = ![];
    const f = this;
    function u() {
      const l = h;
      f[l(3035)] = !![], e[l(2592)](u);
    }
    h(2592) in e && e[h(2592)](u);
  }
  [s(2272)]() {
    const e = s;
    return new this.constructor(this[e(450)])[e(2875)](this);
  }
  [s(3452)]() {
    const e = s, x = this.image;
    e(2592) in x === ![] && x[e(2686)] >= x[e(1963)] && (this.needsUpdate = !![]);
  }
}
class nm extends Ux {
  constructor(e, x, t) {
    const i = s;
    super({ width: e, height: x }), this[i(2591)] = !![], this[i(448)] = t, this.magFilter = Bx, this.minFilter = Bx, this[i(3632)] = ![], this[i(3035)] = !![];
  }
}
class G2 extends Ux {
  constructor(e, x, t, i, n, a, r, o, c, h, f, u) {
    const l = s;
    super(null, a, r, o, c, h, i, n, f, u), this[l(3090)] = !![], this[l(450)] = { width: x, height: t }, this[l(2004)] = e, this.flipY = ![], this[l(3632)] = ![];
  }
}
class sm extends G2 {
  constructor(e, x, t, i, n, a) {
    const r = s;
    super(e, x, t, n, a), this[r(2101)] = !![], this[r(450)].depth = i, this.wrapR = Zx;
  }
}
class am extends Ux {
  constructor(e, x, t, i, n, a, r, o, c) {
    const h = s;
    super(e, x, t, i, n, a, r, o, c), this[h(3317)] = !![], this[h(3035)] = !![];
  }
}
class ze {
  constructor() {
    const e = s;
    this[e(566)] = "Curve", this[e(1162)] = 200;
  }
  [s(538)]() {
    return console.warn(s(2752)), null;
  }
  getPointAt(e, x) {
    const t = s, i = this[t(1393)](e);
    return this[t(538)](i, x);
  }
  [s(2137)](e = 5) {
    const x = s, t = [];
    for (let i = 0; i <= e; i++)
      t[x(3156)](this.getPoint(i / e));
    return t;
  }
  [s(2649)](e = 5) {
    const x = s, t = [];
    for (let i = 0; i <= e; i++)
      t.push(this[x(1778)](i / e));
    return t;
  }
  [s(1296)]() {
    const e = s, x = this[e(2606)]();
    return x[x[e(3105)] - 1];
  }
  getLengths(e = this[s(1162)]) {
    const x = s;
    if (this[x(1975)] && this[x(1975)][x(3105)] === e + 1 && !this[x(3035)])
      return this[x(1975)];
    this[x(3035)] = ![];
    const t = [];
    let i, n = this.getPoint(0), a = 0;
    t[x(3156)](0);
    for (let r = 1; r <= e; r++)
      i = this[x(538)](r / e), a += i[x(3570)](n), t[x(3156)](a), n = i;
    return this[x(1975)] = t, t;
  }
  [s(3072)]() {
    const e = s;
    this[e(3035)] = !![], this[e(2606)]();
  }
  getUtoTmapping(e, x) {
    const t = s, i = this[t(2606)]();
    let n = 0;
    const a = i[t(3105)];
    let r;
    x ? r = x : r = e * i[a - 1];
    let o = 0, c = a - 1, h;
    for (; o <= c; )
      if (n = Math[t(2697)](o + (c - o) / 2), h = i[n] - r, h < 0)
        o = n + 1;
      else if (h > 0)
        c = n - 1;
      else {
        c = n;
        break;
      }
    if (n = c, i[n] === r)
      return n / (a - 1);
    const f = i[n], u = i[n + 1], l = u - f, _ = (r - f) / l;
    return (n + _) / (a - 1);
  }
  [s(2687)](e, x) {
    const t = s, i = 1e-4;
    let n = e - i, a = e + i;
    n < 0 && (n = 0), a > 1 && (a = 1);
    const r = this[t(538)](n), o = this[t(538)](a), c = x || (r[t(2134)] ? new d0() : new z());
    return c[t(2875)](o).sub(r).normalize(), c;
  }
  [s(1078)](e, x) {
    const t = s, i = this[t(1393)](e);
    return this[t(2687)](i, x);
  }
  computeFrenetFrames(e, x) {
    const t = s, i = new z(), n = [], a = [], r = [], o = new z(), c = new ix();
    for (let _ = 0; _ <= e; _++) {
      const p = _ / e;
      n[_] = this[t(1078)](p, new z());
    }
    a[0] = new z(), r[0] = new z();
    let h = Number[t(1445)];
    const f = Math.abs(n[0].x), u = Math[t(3373)](n[0].y), l = Math[t(3373)](n[0].z);
    f <= h && (h = f, i[t(1260)](1, 0, 0)), u <= h && (h = u, i.set(0, 1, 0)), l <= h && i[t(1260)](0, 0, 1), o.crossVectors(n[0], i)[t(608)](), a[0][t(956)](n[0], o), r[0][t(956)](n[0], a[0]);
    for (let _ = 1; _ <= e; _++) {
      if (a[_] = a[_ - 1][t(2272)](), r[_] = r[_ - 1].clone(), o[t(956)](n[_ - 1], n[_]), o[t(3105)]() > Number.EPSILON) {
        o[t(608)]();
        const p = Math[t(2765)](Gx(n[_ - 1][t(1454)](n[_]), -1, 1));
        a[_][t(2442)](c[t(2857)](o, p));
      }
      r[_][t(956)](n[_], a[_]);
    }
    if (x === !![]) {
      let _ = Math[t(2765)](Gx(a[0].dot(a[e]), -1, 1));
      _ /= e, n[0][t(1454)](o[t(956)](a[0], a[e])) > 0 && (_ = -_);
      for (let p = 1; p <= e; p++)
        a[p].applyMatrix4(c[t(2857)](n[p], _ * p)), r[p][t(956)](n[p], a[p]);
    }
    return { tangents: n, normals: a, binormals: r };
  }
  [s(2272)]() {
    const e = s;
    return new this[e(2787)]()[e(2875)](this);
  }
  copy(e) {
    const x = s;
    return this[x(1162)] = e[x(1162)], this;
  }
  toJSON() {
    const e = s, x = { metadata: { version: 4.5, type: e(3784), generator: e(2059) } };
    return x.arcLengthDivisions = this[e(1162)], x[e(566)] = this.type, x;
  }
  [s(3037)](e) {
    const x = s;
    return this[x(1162)] = e[x(1162)], this;
  }
}
class Ra extends ze {
  constructor(e = 0, x = 0, t = 1, i = 1, n = 0, a = Math.PI * 2, r = ![], o = 0) {
    const c = s;
    super(), this[c(3350)] = !![], this[c(566)] = "EllipseCurve", this.aX = e, this.aY = x, this[c(1892)] = t, this[c(3304)] = i, this[c(3394)] = n, this.aEndAngle = a, this[c(2234)] = r, this[c(2315)] = o;
  }
  [s(538)](e, x) {
    const t = s, i = x || new d0(), n = Math.PI * 2;
    let a = this[t(889)] - this[t(3394)];
    const r = Math[t(3373)](a) < Number[t(633)];
    for (; a < 0; )
      a += n;
    for (; a > n; )
      a -= n;
    a < Number.EPSILON && (r ? a = 0 : a = n), this[t(2234)] === !![] && !r && (a === n ? a = -n : a = a - n);
    const o = this[t(3394)] + e * a;
    let c = this.aX + this[t(1892)] * Math[t(2063)](o), h = this.aY + this[t(3304)] * Math.sin(o);
    if (this[t(2315)] !== 0) {
      const f = Math[t(2063)](this[t(2315)]), u = Math.sin(this.aRotation), l = c - this.aX, _ = h - this.aY;
      c = l * f - _ * u + this.aX, h = l * u + _ * f + this.aY;
    }
    return i.set(c, h);
  }
  [s(2875)](e) {
    const x = s;
    return super[x(2875)](e), this.aX = e.aX, this.aY = e.aY, this[x(1892)] = e[x(1892)], this[x(3304)] = e.yRadius, this[x(3394)] = e[x(3394)], this[x(889)] = e.aEndAngle, this[x(2234)] = e[x(2234)], this[x(2315)] = e.aRotation, this;
  }
  [s(3139)]() {
    const e = s, x = super[e(3139)]();
    return x.aX = this.aX, x.aY = this.aY, x.xRadius = this[e(1892)], x[e(3304)] = this.yRadius, x[e(3394)] = this.aStartAngle, x.aEndAngle = this[e(889)], x[e(2234)] = this[e(2234)], x[e(2315)] = this[e(2315)], x;
  }
  fromJSON(e) {
    const x = s;
    return super[x(3037)](e), this.aX = e.aX, this.aY = e.aY, this[x(1892)] = e[x(1892)], this[x(3304)] = e.yRadius, this.aStartAngle = e[x(3394)], this[x(889)] = e[x(889)], this[x(2234)] = e[x(2234)], this.aRotation = e.aRotation, this;
  }
}
class sh extends Ra {
  constructor(e, x, t, i, n, a) {
    const r = s;
    super(e, x, t, t, i, n, a), this[r(1085)] = !![], this[r(566)] = r(2593);
  }
}
function H2() {
  let d = 0, e = 0, x = 0, t = 0;
  function i(n, a, r, o) {
    d = n, e = r, x = -3 * n + 3 * a - 2 * r - o, t = 2 * n - 2 * a + r + o;
  }
  return { initCatmullRom: function(n, a, r, o, c) {
    i(a, r, c * (r - n), c * (o - a));
  }, initNonuniformCatmullRom: function(n, a, r, o, c, h, f) {
    let u = (a - n) / c - (r - n) / (c + h) + (r - a) / h, l = (r - a) / h - (o - a) / (h + f) + (o - r) / f;
    u *= h, l *= h, i(a, r, u, l);
  }, calc: function(n) {
    const a = n * n, r = a * n;
    return d + e * n + x * a + t * r;
  } };
}
const Bs = new z(), dr = new H2(), hr = new H2(), fr = new H2();
class ah extends ze {
  constructor(e = [], x = ![], t = s(2839), i = 0.5) {
    const n = s;
    super(), this.isCatmullRomCurve3 = !![], this[n(566)] = n(1289), this[n(1197)] = e, this[n(2089)] = x, this[n(1725)] = t, this[n(1849)] = i;
  }
  getPoint(e, x = new z()) {
    const t = s, i = x, n = this[t(1197)], a = n.length, r = (a - (this[t(2089)] ? 0 : 1)) * e;
    let o = Math[t(2697)](r), c = r - o;
    this[t(2089)] ? o += o > 0 ? 0 : (Math[t(2697)](Math[t(3373)](o) / a) + 1) * a : c === 0 && o === a - 1 && (o = a - 2, c = 1);
    let h, f;
    this[t(2089)] || o > 0 ? h = n[(o - 1) % a] : (Bs[t(1061)](n[0], n[1]).add(n[0]), h = Bs);
    const u = n[o % a], l = n[(o + 1) % a];
    if (this[t(2089)] || o + 2 < a ? f = n[(o + 2) % a] : (Bs[t(1061)](n[a - 1], n[a - 2])[t(3026)](n[a - 1]), f = Bs), this.curveType === t(2839) || this[t(1725)] === t(3125)) {
      const _ = this[t(1725)] === "chordal" ? 0.5 : 0.25;
      let p = Math[t(3196)](h[t(1679)](u), _), m = Math[t(3196)](u[t(1679)](l), _), y = Math[t(3196)](l[t(1679)](f), _);
      m < 1e-4 && (m = 1), p < 1e-4 && (p = m), y < 1e-4 && (y = m), dr[t(3353)](h.x, u.x, l.x, f.x, p, m, y), hr[t(3353)](h.y, u.y, l.y, f.y, p, m, y), fr[t(3353)](h.z, u.z, l.z, f.z, p, m, y);
    } else
      this.curveType === t(1345) && (dr[t(1712)](h.x, u.x, l.x, f.x, this[t(1849)]), hr.initCatmullRom(h.y, u.y, l.y, f.y, this[t(1849)]), fr[t(1712)](h.z, u.z, l.z, f.z, this.tension));
    return i[t(1260)](dr.calc(c), hr[t(1580)](c), fr[t(1580)](c)), i;
  }
  copy(e) {
    const x = s;
    super[x(2875)](e), this[x(1197)] = [];
    for (let t = 0, i = e[x(1197)][x(3105)]; t < i; t++) {
      const n = e.points[t];
      this[x(1197)][x(3156)](n[x(2272)]());
    }
    return this.closed = e[x(2089)], this[x(1725)] = e[x(1725)], this[x(1849)] = e[x(1849)], this;
  }
  [s(3139)]() {
    const e = s, x = super[e(3139)]();
    x.points = [];
    for (let t = 0, i = this[e(1197)][e(3105)]; t < i; t++) {
      const n = this[e(1197)][t];
      x.points[e(3156)](n[e(1496)]());
    }
    return x[e(2089)] = this[e(2089)], x.curveType = this[e(1725)], x[e(1849)] = this[e(1849)], x;
  }
  fromJSON(e) {
    const x = s;
    super[x(3037)](e), this[x(1197)] = [];
    for (let t = 0, i = e[x(1197)][x(3105)]; t < i; t++) {
      const n = e.points[t];
      this[x(1197)][x(3156)](new z()[x(666)](n));
    }
    return this[x(2089)] = e[x(2089)], this.curveType = e.curveType, this.tension = e[x(1849)], this;
  }
}
function ic(d, e, x, t, i) {
  const n = (t - e) * 0.5, a = (i - x) * 0.5, r = d * d, o = d * r;
  return (2 * x - 2 * t + n + a) * o + (-3 * x + 3 * t - 2 * n - a) * r + n * d + x;
}
function rm(d, e) {
  const x = 1 - d;
  return x * x * e;
}
function om(d, e) {
  return 2 * (1 - d) * d * e;
}
function cm(d, e) {
  return d * d * e;
}
function Cn(d, e, x, t) {
  return rm(d, e) + om(d, x) + cm(d, t);
}
function dm(d, e) {
  const x = 1 - d;
  return x * x * x * e;
}
function hm(d, e) {
  const x = 1 - d;
  return 3 * x * x * d * e;
}
function fm(d, e) {
  return 3 * (1 - d) * d * d * e;
}
function lm(d, e) {
  return d * d * d * e;
}
function Ln(d, e, x, t, i) {
  return dm(d, e) + hm(d, x) + fm(d, t) + lm(d, i);
}
class k2 extends ze {
  constructor(e = new d0(), x = new d0(), t = new d0(), i = new d0()) {
    const n = s;
    super(), this[n(843)] = !![], this[n(566)] = n(1648), this.v0 = e, this.v1 = x, this.v2 = t, this.v3 = i;
  }
  [s(538)](e, x = new d0()) {
    const t = x, i = this.v0, n = this.v1, a = this.v2, r = this.v3;
    return t.set(Ln(e, i.x, n.x, a.x, r.x), Ln(e, i.y, n.y, a.y, r.y)), t;
  }
  copy(e) {
    const x = s;
    return super[x(2875)](e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3[x(2875)](e.v3), this;
  }
  [s(3139)]() {
    const e = s, x = super[e(3139)]();
    return x.v0 = this.v0[e(1496)](), x.v1 = this.v1[e(1496)](), x.v2 = this.v2.toArray(), x.v3 = this.v3[e(1496)](), x;
  }
  fromJSON(e) {
    const x = s;
    return super[x(3037)](e), this.v0[x(666)](e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3[x(666)](e.v3), this;
  }
}
class rh extends ze {
  constructor(e = new z(), x = new z(), t = new z(), i = new z()) {
    const n = s;
    super(), this[n(1710)] = !![], this[n(566)] = "CubicBezierCurve3", this.v0 = e, this.v1 = x, this.v2 = t, this.v3 = i;
  }
  [s(538)](e, x = new z()) {
    const t = s, i = x, n = this.v0, a = this.v1, r = this.v2, o = this.v3;
    return i[t(1260)](Ln(e, n.x, a.x, r.x, o.x), Ln(e, n.y, a.y, r.y, o.y), Ln(e, n.z, a.z, r.z, o.z)), i;
  }
  [s(2875)](e) {
    const x = s;
    return super[x(2875)](e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3[x(2875)](e.v3), this;
  }
  [s(3139)]() {
    const e = s, x = super.toJSON();
    return x.v0 = this.v0[e(1496)](), x.v1 = this.v1[e(1496)](), x.v2 = this.v2[e(1496)](), x.v3 = this.v3[e(1496)](), x;
  }
  [s(3037)](e) {
    const x = s;
    return super.fromJSON(e), this.v0[x(666)](e.v0), this.v1[x(666)](e.v1), this.v2.fromArray(e.v2), this.v3[x(666)](e.v3), this;
  }
}
class Pa extends ze {
  constructor(e = new d0(), x = new d0()) {
    const t = s;
    super(), this.isLineCurve = !![], this[t(566)] = t(1604), this.v1 = e, this.v2 = x;
  }
  getPoint(e, x = new d0()) {
    const t = s, i = x;
    return e === 1 ? i[t(2875)](this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e)[t(3026)](this.v1)), i;
  }
  [s(1778)](e, x) {
    return this[s(538)](e, x);
  }
  [s(2687)](e, x = new d0()) {
    return x.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, x) {
    return this.getTangent(e, x);
  }
  [s(2875)](e) {
    const x = s;
    return super[x(2875)](e), this.v1[x(2875)](e.v1), this.v2[x(2875)](e.v2), this;
  }
  [s(3139)]() {
    const e = s, x = super.toJSON();
    return x.v1 = this.v1[e(1496)](), x.v2 = this.v2[e(1496)](), x;
  }
  [s(3037)](e) {
    const x = s;
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2[x(666)](e.v2), this;
  }
}
class oh extends ze {
  constructor(e = new z(), x = new z()) {
    const t = s;
    super(), this.isLineCurve3 = !![], this[t(566)] = t(2102), this.v1 = e, this.v2 = x;
  }
  [s(538)](e, x = new z()) {
    const t = s, i = x;
    return e === 1 ? i[t(2875)](this.v2) : (i[t(2875)](this.v2).sub(this.v1), i.multiplyScalar(e)[t(3026)](this.v1)), i;
  }
  [s(1778)](e, x) {
    return this[s(538)](e, x);
  }
  [s(2687)](e, x = new z()) {
    const t = s;
    return x[t(1061)](this.v2, this.v1)[t(608)]();
  }
  [s(1078)](e, x) {
    return this[s(2687)](e, x);
  }
  copy(e) {
    const x = s;
    return super[x(2875)](e), this.v1[x(2875)](e.v1), this.v2[x(2875)](e.v2), this;
  }
  toJSON() {
    const e = s, x = super[e(3139)]();
    return x.v1 = this.v1[e(1496)](), x.v2 = this.v2[e(1496)](), x;
  }
  [s(3037)](e) {
    const x = s;
    return super[x(3037)](e), this.v1[x(666)](e.v1), this.v2[x(666)](e.v2), this;
  }
}
class V2 extends ze {
  constructor(e = new d0(), x = new d0(), t = new d0()) {
    const i = s;
    super(), this[i(1716)] = !![], this[i(566)] = "QuadraticBezierCurve", this.v0 = e, this.v1 = x, this.v2 = t;
  }
  [s(538)](e, x = new d0()) {
    const t = s, i = x, n = this.v0, a = this.v1, r = this.v2;
    return i[t(1260)](Cn(e, n.x, a.x, r.x), Cn(e, n.y, a.y, r.y)), i;
  }
  [s(2875)](e) {
    const x = s;
    return super[x(2875)](e), this.v0[x(2875)](e.v0), this.v1[x(2875)](e.v1), this.v2[x(2875)](e.v2), this;
  }
  toJSON() {
    const e = s, x = super[e(3139)]();
    return x.v0 = this.v0[e(1496)](), x.v1 = this.v1[e(1496)](), x.v2 = this.v2.toArray(), x;
  }
  [s(3037)](e) {
    const x = s;
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1[x(666)](e.v1), this.v2[x(666)](e.v2), this;
  }
}
class W2 extends ze {
  constructor(e = new z(), x = new z(), t = new z()) {
    super(), this.isQuadraticBezierCurve3 = !![], this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = x, this.v2 = t;
  }
  getPoint(e, x = new z()) {
    const t = s, i = x, n = this.v0, a = this.v1, r = this.v2;
    return i[t(1260)](Cn(e, n.x, a.x, r.x), Cn(e, n.y, a.y, r.y), Cn(e, n.z, a.z, r.z)), i;
  }
  copy(e) {
    const x = s;
    return super[x(2875)](e), this.v0[x(2875)](e.v0), this.v1.copy(e.v1), this.v2[x(2875)](e.v2), this;
  }
  toJSON() {
    const e = s, x = super[e(3139)]();
    return x.v0 = this.v0[e(1496)](), x.v1 = this.v1.toArray(), x.v2 = this.v2[e(1496)](), x;
  }
  [s(3037)](e) {
    const x = s;
    return super[x(3037)](e), this.v0.fromArray(e.v0), this.v1[x(666)](e.v1), this.v2[x(666)](e.v2), this;
  }
}
class j2 extends ze {
  constructor(e = []) {
    const x = s;
    super(), this[x(673)] = !![], this[x(566)] = x(866), this[x(1197)] = e;
  }
  [s(538)](e, x = new d0()) {
    const t = s, i = x, n = this.points, a = (n[t(3105)] - 1) * e, r = Math[t(2697)](a), o = a - r, c = n[r === 0 ? r : r - 1], h = n[r], f = n[r > n[t(3105)] - 2 ? n[t(3105)] - 1 : r + 1], u = n[r > n[t(3105)] - 3 ? n[t(3105)] - 1 : r + 2];
    return i[t(1260)](ic(o, c.x, h.x, f.x, u.x), ic(o, c.y, h.y, f.y, u.y)), i;
  }
  copy(e) {
    const x = s;
    super.copy(e), this.points = [];
    for (let t = 0, i = e[x(1197)][x(3105)]; t < i; t++) {
      const n = e[x(1197)][t];
      this[x(1197)].push(n[x(2272)]());
    }
    return this;
  }
  [s(3139)]() {
    const e = s, x = super[e(3139)]();
    x[e(1197)] = [];
    for (let t = 0, i = this[e(1197)][e(3105)]; t < i; t++) {
      const n = this[e(1197)][t];
      x[e(1197)].push(n[e(1496)]());
    }
    return x;
  }
  [s(3037)](e) {
    const x = s;
    super[x(3037)](e), this[x(1197)] = [];
    for (let t = 0, i = e[x(1197)][x(3105)]; t < i; t++) {
      const n = e[x(1197)][t];
      this.points.push(new d0()[x(666)](n));
    }
    return this;
  }
}
var X2 = Object.freeze({ __proto__: null, ArcCurve: sh, CatmullRomCurve3: ah, CubicBezierCurve: k2, CubicBezierCurve3: rh, EllipseCurve: Ra, LineCurve: Pa, LineCurve3: oh, QuadraticBezierCurve: V2, QuadraticBezierCurve3: W2, SplineCurve: j2 });
class ch extends ze {
  constructor() {
    const e = s;
    super(), this[e(566)] = e(1316), this[e(2554)] = [], this[e(3687)] = ![];
  }
  [s(3026)](e) {
    const x = s;
    this[x(2554)][x(3156)](e);
  }
  [s(2100)]() {
    const e = s, x = this[e(2554)][0][e(538)](0), t = this[e(2554)][this[e(2554)][e(3105)] - 1][e(538)](1);
    !x[e(2828)](t) && this.curves[e(3156)](new Pa(t, x));
  }
  getPoint(e, x) {
    const t = s, i = e * this[t(1296)](), n = this[t(3280)]();
    let a = 0;
    for (; a < n[t(3105)]; ) {
      if (n[a] >= i) {
        const r = n[a] - i, o = this[t(2554)][a], c = o.getLength(), h = c === 0 ? 0 : 1 - r / c;
        return o[t(1778)](h, x);
      }
      a++;
    }
    return null;
  }
  [s(1296)]() {
    const e = s, x = this[e(3280)]();
    return x[x[e(3105)] - 1];
  }
  [s(3072)]() {
    const e = s;
    this.needsUpdate = !![], this[e(1388)] = null, this.getCurveLengths();
  }
  [s(3280)]() {
    const e = s;
    if (this[e(1388)] && this[e(1388)][e(3105)] === this[e(2554)][e(3105)])
      return this[e(1388)];
    const x = [];
    let t = 0;
    for (let i = 0, n = this[e(2554)][e(3105)]; i < n; i++)
      t += this[e(2554)][i][e(1296)](), x.push(t);
    return this[e(1388)] = x, x;
  }
  [s(2649)](e = 40) {
    const x = s, t = [];
    for (let i = 0; i <= e; i++)
      t[x(3156)](this[x(538)](i / e));
    return this.autoClose && t[x(3156)](t[0]), t;
  }
  [s(2137)](e = 12) {
    const x = s, t = [];
    let i;
    for (let n = 0, a = this.curves; n < a[x(3105)]; n++) {
      const r = a[n], o = r.isEllipseCurve ? e * 2 : r[x(1802)] || r[x(2733)] ? 1 : r.isSplineCurve ? e * r[x(1197)][x(3105)] : e, c = r[x(2137)](o);
      for (let h = 0; h < c[x(3105)]; h++) {
        const f = c[h];
        i && i.equals(f) || (t.push(f), i = f);
      }
    }
    return this[x(3687)] && t[x(3105)] > 1 && !t[t[x(3105)] - 1][x(2828)](t[0]) && t[x(3156)](t[0]), t;
  }
  [s(2875)](e) {
    const x = s;
    super[x(2875)](e), this.curves = [];
    for (let t = 0, i = e[x(2554)][x(3105)]; t < i; t++) {
      const n = e[x(2554)][t];
      this.curves[x(3156)](n[x(2272)]());
    }
    return this[x(3687)] = e[x(3687)], this;
  }
  [s(3139)]() {
    const e = s, x = super.toJSON();
    x[e(3687)] = this.autoClose, x.curves = [];
    for (let t = 0, i = this[e(2554)][e(3105)]; t < i; t++) {
      const n = this.curves[t];
      x[e(2554)][e(3156)](n.toJSON());
    }
    return x;
  }
  fromJSON(e) {
    const x = s;
    super.fromJSON(e), this[x(3687)] = e[x(3687)], this[x(2554)] = [];
    for (let t = 0, i = e.curves[x(3105)]; t < i; t++) {
      const n = e.curves[t];
      this.curves.push(new X2[n[x(566)]]()[x(3037)](n));
    }
    return this;
  }
}
class Fn extends ch {
  constructor(e) {
    const x = s;
    super(), this[x(566)] = x(1718), this[x(2148)] = new d0(), e && this.setFromPoints(e);
  }
  [s(646)](e) {
    const x = s;
    this.moveTo(e[0].x, e[0].y);
    for (let t = 1, i = e[x(3105)]; t < i; t++)
      this[x(3200)](e[t].x, e[t].y);
    return this;
  }
  [s(1729)](e, x) {
    const t = s;
    return this[t(2148)][t(1260)](e, x), this;
  }
  [s(3200)](e, x) {
    const t = s, i = new Pa(this[t(2148)][t(2272)](), new d0(e, x));
    return this[t(2554)][t(3156)](i), this[t(2148)][t(1260)](e, x), this;
  }
  [s(2423)](e, x, t, i) {
    const n = s, a = new V2(this[n(2148)][n(2272)](), new d0(e, x), new d0(t, i));
    return this[n(2554)][n(3156)](a), this[n(2148)][n(1260)](t, i), this;
  }
  bezierCurveTo(e, x, t, i, n, a) {
    const r = s, o = new k2(this[r(2148)][r(2272)](), new d0(e, x), new d0(t, i), new d0(n, a));
    return this[r(2554)][r(3156)](o), this[r(2148)].set(n, a), this;
  }
  [s(3517)](e) {
    const x = s, t = [this[x(2148)].clone()].concat(e), i = new j2(t);
    return this[x(2554)][x(3156)](i), this[x(2148)][x(2875)](e[e[x(3105)] - 1]), this;
  }
  [s(2714)](e, x, t, i, n, a) {
    const r = s, o = this.currentPoint.x, c = this[r(2148)].y;
    return this[r(2231)](e + o, x + c, t, i, n, a), this;
  }
  [s(2231)](e, x, t, i, n, a) {
    return this[s(641)](e, x, t, t, i, n, a), this;
  }
  ellipse(e, x, t, i, n, a, r, o) {
    const c = s, h = this[c(2148)].x, f = this[c(2148)].y;
    return this[c(641)](e + h, x + f, t, i, n, a, r, o), this;
  }
  [s(641)](e, x, t, i, n, a, r, o) {
    const c = s, h = new Ra(e, x, t, i, n, a, r, o);
    if (this[c(2554)][c(3105)] > 0) {
      const u = h[c(538)](0);
      !u[c(2828)](this[c(2148)]) && this.lineTo(u.x, u.y);
    }
    this[c(2554)].push(h);
    const f = h[c(538)](1);
    return this[c(2148)][c(2875)](f), this;
  }
  [s(2875)](e) {
    const x = s;
    return super[x(2875)](e), this[x(2148)].copy(e.currentPoint), this;
  }
  toJSON() {
    const e = s, x = super.toJSON();
    return x[e(2148)] = this[e(2148)][e(1496)](), x;
  }
  [s(3037)](e) {
    const x = s;
    return super[x(3037)](e), this[x(2148)][x(666)](e[x(2148)]), this;
  }
}
class xn extends ox {
  constructor(e = [new d0(0, -0.5), new d0(0.5, 0), new d0(0, 0.5)], x = 12, t = 0, i = Math.PI * 2) {
    const n = s;
    super(), this.type = n(1214), this.parameters = { points: e, segments: x, phiStart: t, phiLength: i }, x = Math[n(2697)](x), i = Gx(i, 0, Math.PI * 2);
    const a = [], r = [], o = [], c = [], h = [], f = 1 / x, u = new z(), l = new d0(), _ = new z(), p = new z(), m = new z();
    let y = 0, v = 0;
    for (let g = 0; g <= e[n(3105)] - 1; g++)
      switch (g) {
        case 0:
          y = e[g + 1].x - e[g].x, v = e[g + 1].y - e[g].y, _.x = v * 1, _.y = -y, _.z = v * 0, m.copy(_), _[n(608)](), c[n(3156)](_.x, _.y, _.z);
          break;
        case e[n(3105)] - 1:
          c[n(3156)](m.x, m.y, m.z);
          break;
        default:
          y = e[g + 1].x - e[g].x, v = e[g + 1].y - e[g].y, _.x = v * 1, _.y = -y, _.z = v * 0, p[n(2875)](_), _.x += m.x, _.y += m.y, _.z += m.z, _[n(608)](), c[n(3156)](_.x, _.y, _.z), m[n(2875)](p);
      }
    for (let g = 0; g <= x; g++) {
      const b = t + g * f * i, M = Math[n(2626)](b), A = Math.cos(b);
      for (let L = 0; L <= e[n(3105)] - 1; L++) {
        u.x = e[L].x * M, u.y = e[L].y, u.z = e[L].x * A, r[n(3156)](u.x, u.y, u.z), l.x = g / x, l.y = L / (e[n(3105)] - 1), o.push(l.x, l.y);
        const P = c[3 * L + 0] * M, S = c[3 * L + 1], I = c[3 * L + 0] * A;
        h[n(3156)](P, S, I);
      }
    }
    for (let g = 0; g < x; g++)
      for (let b = 0; b < e[n(3105)] - 1; b++) {
        const M = b + g * e.length, A = M, L = M + e[n(3105)], P = M + e[n(3105)] + 1, S = M + 1;
        a[n(3156)](A, L, S), a.push(P, S, L);
      }
    this[n(2203)](a), this.setAttribute(n(3571), new W0(r, 3)), this.setAttribute("uv", new W0(o, 2)), this[n(3599)](n(2111), new W0(h, 3));
  }
  [s(2875)](e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    const x = s;
    return new xn(e[x(1197)], e[x(3273)], e[x(3686)], e[x(931)]);
  }
}
class Kn extends xn {
  constructor(e = 1, x = 1, t = 4, i = 8) {
    const n = s, a = new Fn();
    a[n(2231)](0, -x / 2, e, Math.PI * 1.5, 0), a[n(2231)](0, x / 2, e, 0, Math.PI * 0.5), super(a[n(2137)](t), i), this[n(566)] = n(2130), this[n(1063)] = { radius: e, height: x, capSegments: t, radialSegments: i };
  }
  static [s(3037)](e) {
    const x = s;
    return new Kn(e[x(1232)], e[x(3105)], e.capSegments, e[x(1224)]);
  }
}
class $n extends ox {
  constructor(e = 1, x = 32, t = 0, i = Math.PI * 2) {
    const n = s;
    super(), this.type = n(1703), this.parameters = { radius: e, segments: x, thetaStart: t, thetaLength: i }, x = Math.max(3, x);
    const a = [], r = [], o = [], c = [], h = new z(), f = new d0();
    r[n(3156)](0, 0, 0), o.push(0, 0, 1), c.push(0.5, 0.5);
    for (let u = 0, l = 3; u <= x; u++, l += 3) {
      const _ = t + u / x * i;
      h.x = e * Math.cos(_), h.y = e * Math.sin(_), r[n(3156)](h.x, h.y, h.z), o[n(3156)](0, 0, 1), f.x = (r[l] / e + 1) / 2, f.y = (r[l + 1] / e + 1) / 2, c.push(f.x, f.y);
    }
    for (let u = 1; u <= x; u++)
      a[n(3156)](u, u + 1, 0);
    this[n(2203)](a), this.setAttribute(n(3571), new W0(r, 3)), this.setAttribute("normal", new W0(o, 3)), this[n(3599)]("uv", new W0(c, 2));
  }
  [s(2875)](e) {
    const x = s;
    return super.copy(e), this.parameters = Object[x(1188)]({}, e.parameters), this;
  }
  static [s(3037)](e) {
    const x = s;
    return new $n(e[x(1232)], e[x(3273)], e[x(2466)], e.thetaLength);
  }
}
class ci extends ox {
  constructor(e = 1, x = 1, t = 1, i = 32, n = 1, a = ![], r = 0, o = Math.PI * 2) {
    const c = s;
    super(), this[c(566)] = "CylinderGeometry", this.parameters = { radiusTop: e, radiusBottom: x, height: t, radialSegments: i, heightSegments: n, openEnded: a, thetaStart: r, thetaLength: o };
    const h = this;
    i = Math[c(2697)](i), n = Math[c(2697)](n);
    const f = [], u = [], l = [], _ = [];
    let p = 0;
    const m = [], y = t / 2;
    let v = 0;
    g(), a === ![] && (e > 0 && b(!![]), x > 0 && b(![])), this[c(2203)](f), this[c(3599)](c(3571), new W0(u, 3)), this.setAttribute("normal", new W0(l, 3)), this.setAttribute("uv", new W0(_, 2));
    function g() {
      const M = c, A = new z(), L = new z();
      let P = 0;
      const S = (x - e) / t;
      for (let I = 0; I <= n; I++) {
        const C = [], G = I / n, $ = G * (x - e) + e;
        for (let N = 0; N <= i; N++) {
          const V = N / i, X = V * o + r, n0 = Math[M(2626)](X), b0 = Math.cos(X);
          L.x = $ * n0, L.y = -G * t + y, L.z = $ * b0, u.push(L.x, L.y, L.z), A[M(1260)](n0, S, b0)[M(608)](), l[M(3156)](A.x, A.y, A.z), _[M(3156)](V, 1 - G), C[M(3156)](p++);
        }
        m[M(3156)](C);
      }
      for (let I = 0; I < i; I++)
        for (let C = 0; C < n; C++) {
          const G = m[C][I], $ = m[C + 1][I], N = m[C + 1][I + 1], V = m[C][I + 1];
          f.push(G, $, V), f.push($, N, V), P += 6;
        }
      h.addGroup(v, P, 0), v += P;
    }
    function b(M) {
      const A = c, L = p, P = new d0(), S = new z();
      let I = 0;
      const C = M === !![] ? e : x, G = M === !![] ? 1 : -1;
      for (let N = 1; N <= i; N++)
        u.push(0, y * G, 0), l[A(3156)](0, G, 0), _.push(0.5, 0.5), p++;
      const $ = p;
      for (let N = 0; N <= i; N++) {
        const V = N / i, X = V * o + r, n0 = Math[A(2063)](X), b0 = Math[A(2626)](X);
        S.x = C * b0, S.y = y * G, S.z = C * n0, u.push(S.x, S.y, S.z), l[A(3156)](0, G, 0), P.x = n0 * 0.5 + 0.5, P.y = b0 * 0.5 * G + 0.5, _[A(3156)](P.x, P.y), p++;
      }
      for (let N = 0; N < i; N++) {
        const V = L + N, X = $ + N;
        M === !![] ? f[A(3156)](X, X + 1, V) : f[A(3156)](X + 1, X, V), I += 3;
      }
      h[A(3597)](v, I, M === !![] ? 1 : 2), v += I;
    }
  }
  [s(2875)](e) {
    const x = s;
    return super[x(2875)](e), this[x(1063)] = Object[x(1188)]({}, e[x(1063)]), this;
  }
  static [s(3037)](e) {
    const x = s;
    return new ci(e[x(1638)], e.radiusBottom, e[x(1674)], e[x(1224)], e[x(3563)], e[x(3519)], e[x(2466)], e[x(2769)]);
  }
}
class Jn extends ci {
  constructor(e = 1, x = 1, t = 32, i = 1, n = ![], a = 0, r = Math.PI * 2) {
    const o = s;
    super(0, e, x, t, i, n, a, r), this[o(566)] = o(2026), this.parameters = { radius: e, height: x, radialSegments: t, heightSegments: i, openEnded: n, thetaStart: a, thetaLength: r };
  }
  static [s(3037)](e) {
    const x = s;
    return new Jn(e.radius, e[x(1674)], e[x(1224)], e.heightSegments, e.openEnded, e[x(2466)], e.thetaLength);
  }
}
class rt extends ox {
  constructor(e = [], x = [], t = 1, i = 0) {
    const n = s;
    super(), this[n(566)] = "PolyhedronGeometry", this.parameters = { vertices: e, indices: x, radius: t, detail: i };
    const a = [], r = [];
    o(i), h(t), f(), this[n(3599)](n(3571), new W0(a, 3)), this.setAttribute(n(2111), new W0(a.slice(), 3)), this.setAttribute("uv", new W0(r, 2)), i === 0 ? this[n(3287)]() : this[n(1730)]();
    function o(g) {
      const b = n, M = new z(), A = new z(), L = new z();
      for (let P = 0; P < x[b(3105)]; P += 3)
        _(x[P + 0], M), _(x[P + 1], A), _(x[P + 2], L), c(M, A, L, g);
    }
    function c(g, b, M, A) {
      const L = n, P = A + 1, S = [];
      for (let I = 0; I <= P; I++) {
        S[I] = [];
        const C = g[L(2272)]()[L(2841)](M, I / P), G = b.clone()[L(2841)](M, I / P), $ = P - I;
        for (let N = 0; N <= $; N++)
          N === 0 && I === P ? S[I][N] = C : S[I][N] = C.clone().lerp(G, N / $);
      }
      for (let I = 0; I < P; I++)
        for (let C = 0; C < 2 * (P - I) - 1; C++) {
          const G = Math.floor(C / 2);
          C % 2 === 0 ? (l(S[I][G + 1]), l(S[I + 1][G]), l(S[I][G])) : (l(S[I][G + 1]), l(S[I + 1][G + 1]), l(S[I + 1][G]));
        }
    }
    function h(g) {
      const b = n, M = new z();
      for (let A = 0; A < a[b(3105)]; A += 3)
        M.x = a[A + 0], M.y = a[A + 1], M.z = a[A + 2], M.normalize().multiplyScalar(g), a[A + 0] = M.x, a[A + 1] = M.y, a[A + 2] = M.z;
    }
    function f() {
      const g = n, b = new z();
      for (let M = 0; M < a[g(3105)]; M += 3) {
        b.x = a[M + 0], b.y = a[M + 1], b.z = a[M + 2];
        const A = y(b) / 2 / Math.PI + 0.5, L = v(b) / Math.PI + 0.5;
        r[g(3156)](A, 1 - L);
      }
      p(), u();
    }
    function u() {
      const g = n;
      for (let b = 0; b < r[g(3105)]; b += 6) {
        const M = r[b + 0], A = r[b + 2], L = r[b + 4], P = Math[g(1803)](M, A, L), S = Math[g(3085)](M, A, L);
        P > 0.9 && S < 0.1 && (M < 0.2 && (r[b + 0] += 1), A < 0.2 && (r[b + 2] += 1), L < 0.2 && (r[b + 4] += 1));
      }
    }
    function l(g) {
      a[n(3156)](g.x, g.y, g.z);
    }
    function _(g, b) {
      const M = g * 3;
      b.x = e[M + 0], b.y = e[M + 1], b.z = e[M + 2];
    }
    function p() {
      const g = n, b = new z(), M = new z(), A = new z(), L = new z(), P = new d0(), S = new d0(), I = new d0();
      for (let C = 0, G = 0; C < a.length; C += 9, G += 6) {
        b[g(1260)](a[C + 0], a[C + 1], a[C + 2]), M.set(a[C + 3], a[C + 4], a[C + 5]), A[g(1260)](a[C + 6], a[C + 7], a[C + 8]), P[g(1260)](r[G + 0], r[G + 1]), S.set(r[G + 2], r[G + 3]), I[g(1260)](r[G + 4], r[G + 5]), L[g(2875)](b)[g(3026)](M).add(A).divideScalar(3);
        const $ = y(L);
        m(P, G + 0, b, $), m(S, G + 2, M, $), m(I, G + 4, A, $);
      }
    }
    function m(g, b, M, A) {
      A < 0 && g.x === 1 && (r[b] = g.x - 1), M.x === 0 && M.z === 0 && (r[b] = A / 2 / Math.PI + 0.5);
    }
    function y(g) {
      return Math.atan2(g.z, -g.x);
    }
    function v(g) {
      const b = n;
      return Math[b(1722)](-g.y, Math[b(713)](g.x * g.x + g.z * g.z));
    }
  }
  [s(2875)](e) {
    const x = s;
    return super[x(2875)](e), this[x(1063)] = Object[x(1188)]({}, e.parameters), this;
  }
  static [s(3037)](e) {
    const x = s;
    return new rt(e[x(3036)], e.indices, e.radius, e[x(3064)]);
  }
}
class Qn extends rt {
  constructor(e = 1, x = 0) {
    const t = s, i = (1 + Math[t(713)](5)) / 2, n = 1 / i, a = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, 0, -i, 0, -n, i, 0, -n, -i, 0, n, i, 0, n], r = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
    super(a, r, e, x), this.type = "DodecahedronGeometry", this[t(1063)] = { radius: e, detail: x };
  }
  static [s(3037)](e) {
    const x = s;
    return new Qn(e[x(1232)], e[x(3641)]);
  }
}
const Fs = new z(), Gs = new z(), lr = new z(), Hs = new Ee();
class dh extends ox {
  constructor(e = null, x = 1) {
    const t = s;
    if (super(), this[t(566)] = t(874), this[t(1063)] = { geometry: e, thresholdAngle: x }, e !== null) {
      const n = Math.pow(10, 4), a = Math[t(2063)](ii * x), r = e[t(2570)](), o = e.getAttribute(t(3571)), c = r ? r[t(1267)] : o[t(1267)], h = [0, 0, 0], f = ["a", "b", "c"], u = new Array(3), l = {}, _ = [];
      for (let p = 0; p < c; p += 3) {
        r ? (h[0] = r[t(781)](p), h[1] = r[t(781)](p + 1), h[2] = r.getX(p + 2)) : (h[0] = p, h[1] = p + 1, h[2] = p + 2);
        const { a: m, b: y, c: v } = Hs;
        if (m.fromBufferAttribute(o, h[0]), y[t(804)](o, h[1]), v[t(804)](o, h[2]), Hs.getNormal(lr), u[0] = Math[t(1981)](m.x * n) + "," + Math[t(1981)](m.y * n) + "," + Math[t(1981)](m.z * n), u[1] = Math[t(1981)](y.x * n) + "," + Math[t(1981)](y.y * n) + "," + Math.round(y.z * n), u[2] = Math[t(1981)](v.x * n) + "," + Math.round(v.y * n) + "," + Math.round(v.z * n), !(u[0] === u[1] || u[1] === u[2] || u[2] === u[0]))
          for (let g = 0; g < 3; g++) {
            const b = (g + 1) % 3, M = u[g], A = u[b], L = Hs[f[g]], P = Hs[f[b]], S = M + "_" + A, I = A + "_" + M;
            I in l && l[I] ? (lr[t(1454)](l[I][t(2111)]) <= a && (_[t(3156)](L.x, L.y, L.z), _[t(3156)](P.x, P.y, P.z)), l[I] = null) : !(S in l) && (l[S] = { index0: h[g], index1: h[b], normal: lr[t(2272)]() });
          }
      }
      for (const p in l)
        if (l[p]) {
          const { index0: m, index1: y } = l[p];
          Fs.fromBufferAttribute(o, m), Gs[t(804)](o, y), _[t(3156)](Fs.x, Fs.y, Fs.z), _[t(3156)](Gs.x, Gs.y, Gs.z);
        }
      this.setAttribute(t(3571), new W0(_, 3));
    }
  }
  [s(2875)](e) {
    const x = s;
    return super[x(2875)](e), this[x(1063)] = Object[x(1188)]({}, e[x(1063)]), this;
  }
}
class ni extends Fn {
  constructor(e) {
    const x = s;
    super(e), this[x(3104)] = ve(), this[x(566)] = x(2835), this[x(2254)] = [];
  }
  [s(3590)](e) {
    const x = s, t = [];
    for (let i = 0, n = this[x(2254)].length; i < n; i++)
      t[i] = this[x(2254)][i][x(2137)](e);
    return t;
  }
  extractPoints(e) {
    const x = s;
    return { shape: this[x(2137)](e), holes: this[x(3590)](e) };
  }
  [s(2875)](e) {
    const x = s;
    super[x(2875)](e), this.holes = [];
    for (let t = 0, i = e[x(2254)][x(3105)]; t < i; t++) {
      const n = e.holes[t];
      this[x(2254)][x(3156)](n.clone());
    }
    return this;
  }
  [s(3139)]() {
    const e = s, x = super[e(3139)]();
    x[e(3104)] = this[e(3104)], x[e(2254)] = [];
    for (let t = 0, i = this[e(2254)].length; t < i; t++) {
      const n = this[e(2254)][t];
      x[e(2254)][e(3156)](n.toJSON());
    }
    return x;
  }
  [s(3037)](e) {
    const x = s;
    super[x(3037)](e), this[x(3104)] = e[x(3104)], this[x(2254)] = [];
    for (let t = 0, i = e.holes[x(3105)]; t < i; t++) {
      const n = e.holes[t];
      this.holes.push(new Fn()[x(3037)](n));
    }
    return this;
  }
}
const um = { triangulate: function(d, e, x = 2) {
  const t = s, i = e && e[t(3105)], n = i ? e[0] * x : d[t(3105)];
  let a = hh(d, 0, n, x, !![]);
  const r = [];
  if (!a || a[t(1021)] === a[t(2260)])
    return r;
  let o, c, h, f, u, l, _;
  if (i && (a = _m(d, e, a, x)), d.length > 80 * x) {
    o = h = d[0], c = f = d[1];
    for (let p = x; p < n; p += x)
      u = d[p], l = d[p + 1], u < o && (o = u), l < c && (c = l), u > h && (h = u), l > f && (f = l);
    _ = Math[t(1803)](h - o, f - c), _ = _ !== 0 ? 32767 / _ : 0;
  }
  return Gn(a, r, x, o, c, _, 0), r;
} };
function hh(d, e, x, t, i) {
  const n = s;
  let a, r;
  if (i === Rm(d, e, x, t) > 0)
    for (a = e; a < x; a += t)
      r = nc(a, d[a], d[a + 1], r);
  else
    for (a = x - t; a >= e; a -= t)
      r = nc(a, d[a], d[a + 1], r);
  return r && Ia(r, r.next) && (kn(r), r = r[n(1021)]), r;
}
function oi(d, e) {
  const x = s;
  if (!d)
    return d;
  e || (e = d);
  let t = d, i;
  do
    if (i = ![], !t[x(2641)] && (Ia(t, t[x(1021)]) || Nx(t[x(2260)], t, t[x(1021)]) === 0)) {
      if (kn(t), t = e = t.prev, t === t[x(1021)])
        break;
      i = !![];
    } else
      t = t.next;
  while (i || t !== e);
  return e;
}
function Gn(d, e, x, t, i, n, a) {
  const r = s;
  if (!d)
    return;
  !a && n && Sm(d, t, i, n);
  let o = d, c, h;
  for (; d[r(2260)] !== d.next; ) {
    if (c = d[r(2260)], h = d.next, n ? pm(d, t, i, n) : bm(d)) {
      e[r(3156)](c.i / x | 0), e[r(3156)](d.i / x | 0), e[r(3156)](h.i / x | 0), kn(d), d = h.next, o = h.next;
      continue;
    }
    if (d = h, d === o) {
      a ? a === 1 ? (d = mm(oi(d), e, x), Gn(d, e, x, t, i, n, 2)) : a === 2 && gm(d, e, x, t, i, n) : Gn(oi(d), e, x, t, i, n, 1);
      break;
    }
  }
}
function bm(d) {
  const e = s, x = d[e(2260)], t = d, i = d.next;
  if (Nx(x, t, i) >= 0)
    return ![];
  const n = x.x, a = t.x, r = i.x, o = x.y, c = t.y, h = i.y, f = n < a ? n < r ? n : r : a < r ? a : r, u = o < c ? o < h ? o : h : c < h ? c : h, l = n > a ? n > r ? n : r : a > r ? a : r, _ = o > c ? o > h ? o : h : c > h ? c : h;
  let p = i[e(1021)];
  for (; p !== x; ) {
    if (p.x >= f && p.x <= l && p.y >= u && p.y <= _ && Ni(n, o, a, c, r, h, p.x, p.y) && Nx(p.prev, p, p[e(1021)]) >= 0)
      return ![];
    p = p[e(1021)];
  }
  return !![];
}
function pm(d, e, x, t) {
  const i = s, n = d.prev, a = d, r = d[i(1021)];
  if (Nx(n, a, r) >= 0)
    return ![];
  const o = n.x, c = a.x, h = r.x, f = n.y, u = a.y, l = r.y, _ = o < c ? o < h ? o : h : c < h ? c : h, p = f < u ? f < l ? f : l : u < l ? u : l, m = o > c ? o > h ? o : h : c > h ? c : h, y = f > u ? f > l ? f : l : u > l ? u : l, v = r2(_, p, e, x, t), g = r2(m, y, e, x, t);
  let b = d[i(3698)], M = d[i(1333)];
  for (; b && b.z >= v && M && M.z <= g; ) {
    if (b.x >= _ && b.x <= m && b.y >= p && b.y <= y && b !== n && b !== r && Ni(o, f, c, u, h, l, b.x, b.y) && Nx(b[i(2260)], b, b[i(1021)]) >= 0)
      return ![];
    if (b = b.prevZ, M.x >= _ && M.x <= m && M.y >= p && M.y <= y && M !== n && M !== r && Ni(o, f, c, u, h, l, M.x, M.y) && Nx(M[i(2260)], M, M[i(1021)]) >= 0)
      return ![];
    M = M[i(1333)];
  }
  for (; b && b.z >= v; ) {
    if (b.x >= _ && b.x <= m && b.y >= p && b.y <= y && b !== n && b !== r && Ni(o, f, c, u, h, l, b.x, b.y) && Nx(b[i(2260)], b, b.next) >= 0)
      return ![];
    b = b[i(3698)];
  }
  for (; M && M.z <= g; ) {
    if (M.x >= _ && M.x <= m && M.y >= p && M.y <= y && M !== n && M !== r && Ni(o, f, c, u, h, l, M.x, M.y) && Nx(M.prev, M, M.next) >= 0)
      return ![];
    M = M[i(1333)];
  }
  return !![];
}
function mm(d, e, x) {
  const t = s;
  let i = d;
  do {
    const n = i[t(2260)], a = i.next[t(1021)];
    !Ia(n, a) && fh(n, i, i.next, a) && Hn(n, a) && Hn(a, n) && (e[t(3156)](n.i / x | 0), e[t(3156)](i.i / x | 0), e[t(3156)](a.i / x | 0), kn(i), kn(i[t(1021)]), i = d = a), i = i[t(1021)];
  } while (i !== d);
  return oi(i);
}
function gm(d, e, x, t, i, n) {
  const a = s;
  let r = d;
  do {
    let o = r[a(1021)][a(1021)];
    for (; o !== r[a(2260)]; ) {
      if (r.i !== o.i && Am(r, o)) {
        let c = lh(r, o);
        r = oi(r, r.next), c = oi(c, c[a(1021)]), Gn(r, e, x, t, i, n, 0), Gn(c, e, x, t, i, n, 0);
        return;
      }
      o = o[a(1021)];
    }
    r = r.next;
  } while (r !== d);
}
function _m(d, e, x, t) {
  const i = s, n = [];
  let a, r, o, c, h;
  for (a = 0, r = e[i(3105)]; a < r; a++)
    o = e[a] * t, c = a < r - 1 ? e[a + 1] * t : d[i(3105)], h = hh(d, o, c, t, ![]), h === h[i(1021)] && (h[i(2641)] = !![]), n[i(3156)](Em(h));
  for (n[i(614)](vm), a = 0; a < n[i(3105)]; a++)
    x = ym(n[a], x);
  return x;
}
function vm(d, e) {
  return d.x - e.x;
}
function ym(d, e) {
  const x = s, t = wm(d, e);
  if (!t)
    return e;
  const i = lh(t, d);
  return oi(i, i[x(1021)]), oi(t, t.next);
}
function wm(d, e) {
  const x = s;
  let t = e, i = -1 / 0, n;
  const a = d.x, r = d.y;
  do {
    if (r <= t.y && r >= t[x(1021)].y && t[x(1021)].y !== t.y) {
      const l = t.x + (r - t.y) * (t[x(1021)].x - t.x) / (t.next.y - t.y);
      if (l <= a && l > i && (i = l, n = t.x < t[x(1021)].x ? t : t.next, l === a))
        return n;
    }
    t = t[x(1021)];
  } while (t !== e);
  if (!n)
    return null;
  const o = n, c = n.x, h = n.y;
  let f = 1 / 0, u;
  t = n;
  do
    a >= t.x && t.x >= c && a !== t.x && Ni(r < h ? a : i, r, c, h, r < h ? i : a, r, t.x, t.y) && (u = Math.abs(r - t.y) / (a - t.x), Hn(t, d) && (u < f || u === f && (t.x > n.x || t.x === n.x && Mm(n, t))) && (n = t, f = u)), t = t[x(1021)];
  while (t !== o);
  return n;
}
function Mm(d, e) {
  const x = s;
  return Nx(d.prev, d, e[x(2260)]) < 0 && Nx(e[x(1021)], d, d[x(1021)]) < 0;
}
function Sm(d, e, x, t) {
  const i = s;
  let n = d;
  do
    n.z === 0 && (n.z = r2(n.x, n.y, e, x, t)), n[i(3698)] = n.prev, n.nextZ = n[i(1021)], n = n[i(1021)];
  while (n !== d);
  n[i(3698)].nextZ = null, n[i(3698)] = null, Tm(n);
}
function Tm(d) {
  const e = s;
  let x, t, i, n, a, r, o, c, h = 1;
  do {
    for (t = d, d = null, a = null, r = 0; t; ) {
      for (r++, i = t, o = 0, x = 0; x < h && (o++, i = i[e(1333)], !!i); x++)
        ;
      for (c = h; o > 0 || c > 0 && i; )
        o !== 0 && (c === 0 || !i || t.z <= i.z) ? (n = t, t = t[e(1333)], o--) : (n = i, i = i[e(1333)], c--), a ? a[e(1333)] = n : d = n, n[e(3698)] = a, a = n;
      t = i;
    }
    a[e(1333)] = null, h *= 2;
  } while (r > 1);
  return d;
}
function r2(d, e, x, t, i) {
  return d = (d - x) * i | 0, e = (e - t) * i | 0, d = (d | d << 8) & 16711935, d = (d | d << 4) & 252645135, d = (d | d << 2) & 858993459, d = (d | d << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, d | e << 1;
}
function Em(d) {
  const e = s;
  let x = d, t = d;
  do
    (x.x < t.x || x.x === t.x && x.y < t.y) && (t = x), x = x[e(1021)];
  while (x !== d);
  return t;
}
function Ni(d, e, x, t, i, n, a, r) {
  return (i - a) * (e - r) >= (d - a) * (n - r) && (d - a) * (t - r) >= (x - a) * (e - r) && (x - a) * (n - r) >= (i - a) * (t - r);
}
function Am(d, e) {
  const x = s;
  return d.next.i !== e.i && d[x(2260)].i !== e.i && !Cm(d, e) && (Hn(d, e) && Hn(e, d) && Lm(d, e) && (Nx(d.prev, d, e.prev) || Nx(d, e[x(2260)], e)) || Ia(d, e) && Nx(d[x(2260)], d, d.next) > 0 && Nx(e[x(2260)], e, e[x(1021)]) > 0);
}
function Nx(d, e, x) {
  return (e.y - d.y) * (x.x - e.x) - (e.x - d.x) * (x.y - e.y);
}
function Ia(d, e) {
  return d.x === e.x && d.y === e.y;
}
function fh(d, e, x, t) {
  const i = Vs(Nx(d, e, x)), n = Vs(Nx(d, e, t)), a = Vs(Nx(x, t, d)), r = Vs(Nx(x, t, e));
  return i !== n && a !== r ? !![] : i === 0 && ks(d, x, e) ? !![] : n === 0 && ks(d, t, e) ? !![] : a === 0 && ks(x, d, t) ? !![] : r === 0 && ks(x, e, t) ? !![] : ![];
}
function ks(d, e, x) {
  const t = s;
  return e.x <= Math[t(1803)](d.x, x.x) && e.x >= Math.min(d.x, x.x) && e.y <= Math[t(1803)](d.y, x.y) && e.y >= Math[t(3085)](d.y, x.y);
}
function Vs(d) {
  return d > 0 ? 1 : d < 0 ? -1 : 0;
}
function Cm(d, e) {
  const x = s;
  let t = d;
  do {
    if (t.i !== d.i && t.next.i !== d.i && t.i !== e.i && t.next.i !== e.i && fh(t, t.next, d, e))
      return !![];
    t = t[x(1021)];
  } while (t !== d);
  return ![];
}
function Hn(d, e) {
  const x = s;
  return Nx(d[x(2260)], d, d[x(1021)]) < 0 ? Nx(d, e, d[x(1021)]) >= 0 && Nx(d, d[x(2260)], e) >= 0 : Nx(d, e, d[x(2260)]) < 0 || Nx(d, d[x(1021)], e) < 0;
}
function Lm(d, e) {
  const x = s;
  let t = d, i = ![];
  const n = (d.x + e.x) / 2, a = (d.y + e.y) / 2;
  do
    t.y > a != t[x(1021)].y > a && t[x(1021)].y !== t.y && n < (t.next.x - t.x) * (a - t.y) / (t[x(1021)].y - t.y) + t.x && (i = !i), t = t[x(1021)];
  while (t !== d);
  return i;
}
function lh(d, e) {
  const x = s, t = new o2(d.i, d.x, d.y), i = new o2(e.i, e.x, e.y), n = d[x(1021)], a = e[x(2260)];
  return d[x(1021)] = e, e[x(2260)] = d, t[x(1021)] = n, n[x(2260)] = t, i[x(1021)] = t, t.prev = i, a[x(1021)] = i, i[x(2260)] = a, i;
}
function nc(d, e, x, t) {
  const i = s, n = new o2(d, e, x);
  return t ? (n[i(1021)] = t.next, n[i(2260)] = t, t[i(1021)][i(2260)] = n, t[i(1021)] = n) : (n[i(2260)] = n, n[i(1021)] = n), n;
}
function kn(d) {
  const e = s;
  d.next[e(2260)] = d[e(2260)], d.prev[e(1021)] = d.next, d[e(3698)] && (d[e(3698)][e(1333)] = d[e(1333)]), d[e(1333)] && (d.nextZ[e(3698)] = d[e(3698)]);
}
function o2(d, e, x) {
  const t = s;
  this.i = d, this.x = e, this.y = x, this[t(2260)] = null, this.next = null, this.z = 0, this[t(3698)] = null, this.nextZ = null, this[t(2641)] = ![];
}
function Rm(d, e, x, t) {
  let i = 0;
  for (let n = e, a = x - t; n < x; n += t)
    i += (d[a] - d[n]) * (d[n + 1] + d[a + 1]), a = n;
  return i;
}
class je {
  static [s(1936)](e) {
    const x = e.length;
    let t = 0;
    for (let i = x - 1, n = 0; n < x; i = n++)
      t += e[i].x * e[n].y - e[n].x * e[i].y;
    return t * 0.5;
  }
  static [s(506)](e) {
    return je[s(1936)](e) < 0;
  }
  static [s(2233)](e, x) {
    const t = s, i = [], n = [], a = [];
    sc(e), ac(i, e);
    let r = e[t(3105)];
    x.forEach(sc);
    for (let c = 0; c < x[t(3105)]; c++)
      n[t(3156)](r), r += x[c].length, ac(i, x[c]);
    const o = um[t(3654)](i, n);
    for (let c = 0; c < o[t(3105)]; c += 3)
      a[t(3156)](o[t(3482)](c, c + 3));
    return a;
  }
}
function sc(d) {
  const e = s, x = d[e(3105)];
  x > 2 && d[x - 1].equals(d[0]) && d[e(465)]();
}
function ac(d, e) {
  const x = s;
  for (let t = 0; t < e[x(3105)]; t++)
    d[x(3156)](e[t].x), d.push(e[t].y);
}
class xs extends ox {
  constructor(e = new ni([new d0(0.5, 0.5), new d0(-0.5, 0.5), new d0(-0.5, -0.5), new d0(0.5, -0.5)]), x = {}) {
    const t = s;
    super(), this[t(566)] = "ExtrudeGeometry", this[t(1063)] = { shapes: e, options: x }, e = Array.isArray(e) ? e : [e];
    const i = this, n = [], a = [];
    for (let o = 0, c = e[t(3105)]; o < c; o++) {
      const h = e[o];
      r(h);
    }
    this[t(3599)](t(3571), new W0(n, 3)), this[t(3599)]("uv", new W0(a, 2)), this[t(3287)]();
    function r(o) {
      const c = t, h = [], f = x[c(792)] !== void 0 ? x.curveSegments : 12, u = x[c(1420)] !== void 0 ? x[c(1420)] : 1, l = x[c(3611)] !== void 0 ? x.depth : 1;
      let _ = x.bevelEnabled !== void 0 ? x[c(3751)] : !![], p = x[c(2866)] !== void 0 ? x[c(2866)] : 0.2, m = x[c(2051)] !== void 0 ? x.bevelSize : p - 0.1, y = x[c(1366)] !== void 0 ? x[c(1366)] : 0, v = x[c(841)] !== void 0 ? x[c(841)] : 3;
      const g = x[c(1782)], b = x[c(3697)] !== void 0 ? x.UVGenerator : Pm;
      let M, A = ![], L, P, S, I;
      g && (M = g[c(2649)](u), A = !![], _ = ![], L = g[c(1230)](u, ![]), P = new z(), S = new z(), I = new z()), !_ && (v = 0, p = 0, m = 0, y = 0);
      const C = o.extractPoints(f);
      let G = C.shape;
      const $ = C[c(2254)];
      if (!je[c(506)](G)) {
        G = G[c(1334)]();
        for (let _0 = 0, E0 = $[c(3105)]; _0 < E0; _0++) {
          const O0 = $[_0];
          je[c(506)](O0) && ($[_0] = O0[c(1334)]());
        }
      }
      const V = je[c(2233)](G, $), X = G;
      for (let _0 = 0, E0 = $.length; _0 < E0; _0++) {
        const O0 = $[_0];
        G = G[c(3744)](O0);
      }
      function n0(_0, E0, O0) {
        const D0 = c;
        return E0 || console[D0(533)](D0(787)), _0.clone()[D0(1990)](E0, O0);
      }
      const b0 = G.length, Q = V[c(3105)];
      function r0(_0, E0, O0) {
        const D0 = c;
        let N0, B0, X0;
        const fx = _0.x - E0.x, vx = _0.y - E0.y, B = O0.x - _0.x, E = O0.y - _0.y, j = fx * fx + vx * vx, R = fx * E - vx * B;
        if (Math[D0(3373)](R) > Number.EPSILON) {
          const h0 = Math[D0(713)](j), S0 = Math.sqrt(B * B + E * E), R0 = E0.x - vx / h0, Z0 = E0.y + fx / h0, H0 = O0.x - E / S0, u0 = O0.y + B / S0, V0 = ((H0 - R0) * E - (u0 - Z0) * B) / (fx * E - vx * B);
          N0 = R0 + fx * V0 - _0.x, B0 = Z0 + vx * V0 - _0.y;
          const K0 = N0 * N0 + B0 * B0;
          if (K0 <= 2)
            return new d0(N0, B0);
          X0 = Math[D0(713)](K0 / 2);
        } else {
          let h0 = ![];
          fx > Number[D0(633)] ? B > Number[D0(633)] && (h0 = !![]) : fx < -Number.EPSILON ? B < -Number.EPSILON && (h0 = !![]) : Math.sign(vx) === Math[D0(2966)](E) && (h0 = !![]), h0 ? (N0 = -vx, B0 = fx, X0 = Math[D0(713)](j)) : (N0 = fx, B0 = vx, X0 = Math[D0(713)](j / 2));
        }
        return new d0(N0 / X0, B0 / X0);
      }
      const l0 = [];
      for (let _0 = 0, E0 = X.length, O0 = E0 - 1, D0 = _0 + 1; _0 < E0; _0++, O0++, D0++)
        O0 === E0 && (O0 = 0), D0 === E0 && (D0 = 0), l0[_0] = r0(X[_0], X[O0], X[D0]);
      const v0 = [];
      let s0, q = l0[c(3744)]();
      for (let _0 = 0, E0 = $[c(3105)]; _0 < E0; _0++) {
        const O0 = $[_0];
        s0 = [];
        for (let D0 = 0, N0 = O0[c(3105)], B0 = N0 - 1, X0 = D0 + 1; D0 < N0; D0++, B0++, X0++)
          B0 === N0 && (B0 = 0), X0 === N0 && (X0 = 0), s0[D0] = r0(O0[D0], O0[B0], O0[X0]);
        v0[c(3156)](s0), q = q[c(3744)](s0);
      }
      for (let _0 = 0; _0 < v; _0++) {
        const E0 = _0 / v, O0 = p * Math[c(2063)](E0 * Math.PI / 2), D0 = m * Math.sin(E0 * Math.PI / 2) + y;
        for (let N0 = 0, B0 = X[c(3105)]; N0 < B0; N0++) {
          const X0 = n0(X[N0], l0[N0], D0);
          L0(X0.x, X0.y, -O0);
        }
        for (let N0 = 0, B0 = $[c(3105)]; N0 < B0; N0++) {
          const X0 = $[N0];
          s0 = v0[N0];
          for (let fx = 0, vx = X0.length; fx < vx; fx++) {
            const B = n0(X0[fx], s0[fx], D0);
            L0(B.x, B.y, -O0);
          }
        }
      }
      const a0 = m + y;
      for (let _0 = 0; _0 < b0; _0++) {
        const E0 = _ ? n0(G[_0], q[_0], a0) : G[_0];
        A ? (S[c(2875)](L[c(1273)][0])[c(580)](E0.x), P[c(2875)](L.binormals[0])[c(580)](E0.y), I[c(2875)](M[0])[c(3026)](S)[c(3026)](P), L0(I.x, I.y, I.z)) : L0(E0.x, E0.y, 0);
      }
      for (let _0 = 1; _0 <= u; _0++)
        for (let E0 = 0; E0 < b0; E0++) {
          const O0 = _ ? n0(G[E0], q[E0], a0) : G[E0];
          A ? (S[c(2875)](L[c(1273)][_0]).multiplyScalar(O0.x), P[c(2875)](L[c(2353)][_0])[c(580)](O0.y), I[c(2875)](M[_0])[c(3026)](S)[c(3026)](P), L0(I.x, I.y, I.z)) : L0(O0.x, O0.y, l / u * _0);
        }
      for (let _0 = v - 1; _0 >= 0; _0--) {
        const E0 = _0 / v, O0 = p * Math[c(2063)](E0 * Math.PI / 2), D0 = m * Math.sin(E0 * Math.PI / 2) + y;
        for (let N0 = 0, B0 = X.length; N0 < B0; N0++) {
          const X0 = n0(X[N0], l0[N0], D0);
          L0(X0.x, X0.y, l + O0);
        }
        for (let N0 = 0, B0 = $[c(3105)]; N0 < B0; N0++) {
          const X0 = $[N0];
          s0 = v0[N0];
          for (let fx = 0, vx = X0[c(3105)]; fx < vx; fx++) {
            const B = n0(X0[fx], s0[fx], D0);
            A ? L0(B.x, B.y + M[u - 1].y, M[u - 1].x + O0) : L0(B.x, B.y, l + O0);
          }
        }
      }
      e0(), p0();
      function e0() {
        const _0 = c, E0 = n[_0(3105)] / 3;
        if (_) {
          let O0 = 0, D0 = b0 * O0;
          for (let N0 = 0; N0 < Q; N0++) {
            const B0 = V[N0];
            k0(B0[2] + D0, B0[1] + D0, B0[0] + D0);
          }
          O0 = u + v * 2, D0 = b0 * O0;
          for (let N0 = 0; N0 < Q; N0++) {
            const B0 = V[N0];
            k0(B0[0] + D0, B0[1] + D0, B0[2] + D0);
          }
        } else {
          for (let O0 = 0; O0 < Q; O0++) {
            const D0 = V[O0];
            k0(D0[2], D0[1], D0[0]);
          }
          for (let O0 = 0; O0 < Q; O0++) {
            const D0 = V[O0];
            k0(D0[0] + b0 * u, D0[1] + b0 * u, D0[2] + b0 * u);
          }
        }
        i[_0(3597)](E0, n[_0(3105)] / 3 - E0, 0);
      }
      function p0() {
        const _0 = c, E0 = n.length / 3;
        let O0 = 0;
        y0(X, O0), O0 += X[_0(3105)];
        for (let D0 = 0, N0 = $[_0(3105)]; D0 < N0; D0++) {
          const B0 = $[D0];
          y0(B0, O0), O0 += B0[_0(3105)];
        }
        i.addGroup(E0, n[_0(3105)] / 3 - E0, 1);
      }
      function y0(_0, E0) {
        let D0 = _0[c(3105)];
        for (; --D0 >= 0; ) {
          const N0 = D0;
          let B0 = D0 - 1;
          B0 < 0 && (B0 = _0.length - 1);
          for (let X0 = 0, fx = u + v * 2; X0 < fx; X0++) {
            const vx = b0 * X0, B = b0 * (X0 + 1), E = E0 + N0 + vx, j = E0 + B0 + vx, R = E0 + B0 + B, h0 = E0 + N0 + B;
            Q0(E, j, R, h0);
          }
        }
      }
      function L0(_0, E0, O0) {
        const D0 = c;
        h[D0(3156)](_0), h.push(E0), h[D0(3156)](O0);
      }
      function k0(_0, E0, O0) {
        U0(_0), U0(E0), U0(O0);
        const D0 = n.length / 3, N0 = b.generateTopUV(i, n, D0 - 3, D0 - 2, D0 - 1);
        xx(N0[0]), xx(N0[1]), xx(N0[2]);
      }
      function Q0(_0, E0, O0, D0) {
        const N0 = c;
        U0(_0), U0(E0), U0(D0), U0(E0), U0(O0), U0(D0);
        const B0 = n.length / 3, X0 = b[N0(2221)](i, n, B0 - 6, B0 - 3, B0 - 2, B0 - 1);
        xx(X0[0]), xx(X0[1]), xx(X0[3]), xx(X0[1]), xx(X0[2]), xx(X0[3]);
      }
      function U0(_0) {
        n[c(3156)](h[_0 * 3 + 0]), n.push(h[_0 * 3 + 1]), n.push(h[_0 * 3 + 2]);
      }
      function xx(_0) {
        const E0 = c;
        a[E0(3156)](_0.x), a[E0(3156)](_0.y);
      }
    }
  }
  [s(2875)](e) {
    const x = s;
    return super[x(2875)](e), this[x(1063)] = Object[x(1188)]({}, e.parameters), this;
  }
  toJSON() {
    const e = s, x = super[e(3139)](), t = this[e(1063)][e(2002)], i = this[e(1063)].options;
    return Im(t, i, x);
  }
  static fromJSON(e, x) {
    const t = s, i = [];
    for (let a = 0, r = e[t(2002)][t(3105)]; a < r; a++) {
      const o = x[e.shapes[a]];
      i[t(3156)](o);
    }
    const n = e[t(3459)][t(1782)];
    return n !== void 0 && (e[t(3459)][t(1782)] = new X2[n[t(566)]]().fromJSON(n)), new xs(i, e[t(3459)]);
  }
}
const Pm = { generateTopUV: function(d, e, x, t, i) {
  const n = e[x * 3], a = e[x * 3 + 1], r = e[t * 3], o = e[t * 3 + 1], c = e[i * 3], h = e[i * 3 + 1];
  return [new d0(n, a), new d0(r, o), new d0(c, h)];
}, generateSideWallUV: function(d, e, x, t, i, n) {
  const a = s, r = e[x * 3], o = e[x * 3 + 1], c = e[x * 3 + 2], h = e[t * 3], f = e[t * 3 + 1], u = e[t * 3 + 2], l = e[i * 3], _ = e[i * 3 + 1], p = e[i * 3 + 2], m = e[n * 3], y = e[n * 3 + 1], v = e[n * 3 + 2];
  return Math[a(3373)](o - f) < Math.abs(r - h) ? [new d0(r, 1 - c), new d0(h, 1 - u), new d0(l, 1 - p), new d0(m, 1 - v)] : [new d0(o, 1 - c), new d0(f, 1 - u), new d0(_, 1 - p), new d0(y, 1 - v)];
} };
function Im(d, e, x) {
  const t = s;
  if (x.shapes = [], Array.isArray(d))
    for (let i = 0, n = d[t(3105)]; i < n; i++) {
      const a = d[i];
      x.shapes.push(a[t(3104)]);
    }
  else
    x[t(2002)][t(3156)](d.uuid);
  return x.options = Object[t(1188)]({}, e), e[t(1782)] !== void 0 && (x[t(3459)].extrudePath = e[t(1782)][t(3139)]()), x;
}
class es extends rt {
  constructor(e = 1, x = 0) {
    const t = s, i = (1 + Math[t(713)](5)) / 2, n = [-1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, 0, 0, -1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, i, 0, -1, i, 0, 1, -i, 0, -1, -i, 0, 1], a = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
    super(n, a, e, x), this.type = t(474), this[t(1063)] = { radius: e, detail: x };
  }
  static [s(3037)](e) {
    const x = s;
    return new es(e.radius, e[x(3641)]);
  }
}
class en extends rt {
  constructor(e = 1, x = 0) {
    const t = s, i = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], n = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
    super(i, n, e, x), this.type = t(2601), this[t(1063)] = { radius: e, detail: x };
  }
  static [s(3037)](e) {
    const x = s;
    return new en(e[x(1232)], e[x(3641)]);
  }
}
class ts extends ox {
  constructor(e = 0.5, x = 1, t = 32, i = 1, n = 0, a = Math.PI * 2) {
    const r = s;
    super(), this[r(566)] = r(3159), this[r(1063)] = { innerRadius: e, outerRadius: x, thetaSegments: t, phiSegments: i, thetaStart: n, thetaLength: a }, t = Math[r(1803)](3, t), i = Math.max(1, i);
    const o = [], c = [], h = [], f = [];
    let u = e;
    const l = (x - e) / i, _ = new z(), p = new d0();
    for (let m = 0; m <= i; m++) {
      for (let y = 0; y <= t; y++) {
        const v = n + y / t * a;
        _.x = u * Math[r(2063)](v), _.y = u * Math[r(2626)](v), c[r(3156)](_.x, _.y, _.z), h.push(0, 0, 1), p.x = (_.x / x + 1) / 2, p.y = (_.y / x + 1) / 2, f[r(3156)](p.x, p.y);
      }
      u += l;
    }
    for (let m = 0; m < i; m++) {
      const y = m * (t + 1);
      for (let v = 0; v < t; v++) {
        const g = v + y, b = g, M = g + t + 1, A = g + t + 2, L = g + 1;
        o[r(3156)](b, M, L), o.push(M, A, L);
      }
    }
    this[r(2203)](o), this[r(3599)](r(3571), new W0(c, 3)), this.setAttribute(r(2111), new W0(h, 3)), this[r(3599)]("uv", new W0(f, 2));
  }
  [s(2875)](e) {
    const x = s;
    return super[x(2875)](e), this[x(1063)] = Object[x(1188)]({}, e[x(1063)]), this;
  }
  static [s(3037)](e) {
    const x = s;
    return new ts(e[x(503)], e[x(2045)], e.thetaSegments, e[x(3800)], e[x(2466)], e.thetaLength);
  }
}
class is extends ox {
  constructor(e = new ni([new d0(0, 0.5), new d0(-0.5, -0.5), new d0(0.5, -0.5)]), x = 12) {
    const t = s;
    super(), this[t(566)] = t(2763), this.parameters = { shapes: e, curveSegments: x };
    const i = [], n = [], a = [], r = [];
    let o = 0, c = 0;
    if (Array[t(1609)](e) === ![])
      h(e);
    else
      for (let f = 0; f < e[t(3105)]; f++)
        h(e[f]), this[t(3597)](o, c, f), o += c, c = 0;
    this[t(2203)](i), this[t(3599)](t(3571), new W0(n, 3)), this.setAttribute("normal", new W0(a, 3)), this.setAttribute("uv", new W0(r, 2));
    function h(f) {
      const u = t, l = n[u(3105)] / 3, _ = f[u(3071)](x);
      let p = _[u(1287)];
      const m = _[u(2254)];
      je.isClockWise(p) === ![] && (p = p.reverse());
      for (let v = 0, g = m[u(3105)]; v < g; v++) {
        const b = m[v];
        je[u(506)](b) === !![] && (m[v] = b[u(1334)]());
      }
      const y = je[u(2233)](p, m);
      for (let v = 0, g = m[u(3105)]; v < g; v++) {
        const b = m[v];
        p = p[u(3744)](b);
      }
      for (let v = 0, g = p[u(3105)]; v < g; v++) {
        const b = p[v];
        n[u(3156)](b.x, b.y, 0), a[u(3156)](0, 0, 1), r[u(3156)](b.x, b.y);
      }
      for (let v = 0, g = y.length; v < g; v++) {
        const b = y[v], M = b[0] + l, A = b[1] + l, L = b[2] + l;
        i[u(3156)](M, A, L), c += 3;
      }
    }
  }
  [s(2875)](e) {
    const x = s;
    return super.copy(e), this.parameters = Object[x(1188)]({}, e[x(1063)]), this;
  }
  [s(3139)]() {
    const e = s, x = super[e(3139)](), t = this[e(1063)][e(2002)];
    return Dm(t, x);
  }
  static fromJSON(e, x) {
    const t = s, i = [];
    for (let n = 0, a = e.shapes[t(3105)]; n < a; n++) {
      const r = x[e[t(2002)][n]];
      i[t(3156)](r);
    }
    return new is(i, e[t(792)]);
  }
}
function Dm(d, e) {
  const x = s;
  if (e[x(2002)] = [], Array.isArray(d))
    for (let t = 0, i = d[x(3105)]; t < i; t++) {
      const n = d[t];
      e[x(2002)].push(n[x(3104)]);
    }
  else
    e[x(2002)].push(d[x(3104)]);
  return e;
}
class tn extends ox {
  constructor(e = 1, x = 32, t = 16, i = 0, n = Math.PI * 2, a = 0, r = Math.PI) {
    const o = s;
    super(), this[o(566)] = o(2240), this[o(1063)] = { radius: e, widthSegments: x, heightSegments: t, phiStart: i, phiLength: n, thetaStart: a, thetaLength: r }, x = Math[o(1803)](3, Math[o(2697)](x)), t = Math[o(1803)](2, Math[o(2697)](t));
    const c = Math.min(a + r, Math.PI);
    let h = 0;
    const f = [], u = new z(), l = new z(), _ = [], p = [], m = [], y = [];
    for (let v = 0; v <= t; v++) {
      const g = [], b = v / t;
      let M = 0;
      v == 0 && a == 0 ? M = 0.5 / x : v == t && c == Math.PI && (M = -0.5 / x);
      for (let A = 0; A <= x; A++) {
        const L = A / x;
        u.x = -e * Math[o(2063)](i + L * n) * Math[o(2626)](a + b * r), u.y = e * Math[o(2063)](a + b * r), u.z = e * Math[o(2626)](i + L * n) * Math[o(2626)](a + b * r), p[o(3156)](u.x, u.y, u.z), l[o(2875)](u).normalize(), m.push(l.x, l.y, l.z), y.push(L + M, 1 - b), g[o(3156)](h++);
      }
      f[o(3156)](g);
    }
    for (let v = 0; v < t; v++)
      for (let g = 0; g < x; g++) {
        const b = f[v][g + 1], M = f[v][g], A = f[v + 1][g], L = f[v + 1][g + 1];
        (v !== 0 || a > 0) && _[o(3156)](b, M, L), (v !== t - 1 || c < Math.PI) && _[o(3156)](M, A, L);
      }
    this[o(2203)](_), this[o(3599)]("position", new W0(p, 3)), this[o(3599)](o(2111), new W0(m, 3)), this[o(3599)]("uv", new W0(y, 2));
  }
  [s(2875)](e) {
    const x = s;
    return super[x(2875)](e), this.parameters = Object[x(1188)]({}, e[x(1063)]), this;
  }
  static fromJSON(e) {
    const x = s;
    return new tn(e[x(1232)], e[x(1715)], e[x(3563)], e.phiStart, e[x(931)], e[x(2466)], e[x(2769)]);
  }
}
class ns extends rt {
  constructor(e = 1, x = 0) {
    const t = s, i = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], n = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
    super(i, n, e, x), this[t(566)] = t(2959), this[t(1063)] = { radius: e, detail: x };
  }
  static [s(3037)](e) {
    const x = s;
    return new ns(e[x(1232)], e[x(3641)]);
  }
}
class ss extends ox {
  constructor(e = 1, x = 0.4, t = 12, i = 48, n = Math.PI * 2) {
    const a = s;
    super(), this[a(566)] = a(1343), this[a(1063)] = { radius: e, tube: x, radialSegments: t, tubularSegments: i, arc: n }, t = Math[a(2697)](t), i = Math[a(2697)](i);
    const r = [], o = [], c = [], h = [], f = new z(), u = new z(), l = new z();
    for (let _ = 0; _ <= t; _++)
      for (let p = 0; p <= i; p++) {
        const m = p / i * n, y = _ / t * Math.PI * 2;
        u.x = (e + x * Math[a(2063)](y)) * Math.cos(m), u.y = (e + x * Math[a(2063)](y)) * Math[a(2626)](m), u.z = x * Math.sin(y), o[a(3156)](u.x, u.y, u.z), f.x = e * Math[a(2063)](m), f.y = e * Math.sin(m), l.subVectors(u, f)[a(608)](), c.push(l.x, l.y, l.z), h[a(3156)](p / i), h[a(3156)](_ / t);
      }
    for (let _ = 1; _ <= t; _++)
      for (let p = 1; p <= i; p++) {
        const m = (i + 1) * _ + p - 1, y = (i + 1) * (_ - 1) + p - 1, v = (i + 1) * (_ - 1) + p, g = (i + 1) * _ + p;
        r[a(3156)](m, y, g), r.push(y, v, g);
      }
    this[a(2203)](r), this[a(3599)](a(3571), new W0(o, 3)), this[a(3599)]("normal", new W0(c, 3)), this.setAttribute("uv", new W0(h, 2));
  }
  [s(2875)](e) {
    const x = s;
    return super[x(2875)](e), this[x(1063)] = Object[x(1188)]({}, e[x(1063)]), this;
  }
  static [s(3037)](e) {
    const x = s;
    return new ss(e.radius, e[x(1409)], e[x(1224)], e[x(1308)], e[x(2714)]);
  }
}
class as extends ox {
  constructor(e = 1, x = 0.4, t = 64, i = 8, n = 2, a = 3) {
    const r = s;
    super(), this[r(566)] = "TorusKnotGeometry", this[r(1063)] = { radius: e, tube: x, tubularSegments: t, radialSegments: i, p: n, q: a }, t = Math[r(2697)](t), i = Math[r(2697)](i);
    const o = [], c = [], h = [], f = [], u = new z(), l = new z(), _ = new z(), p = new z(), m = new z(), y = new z(), v = new z();
    for (let b = 0; b <= t; ++b) {
      const M = b / t * n * Math.PI * 2;
      g(M, n, a, e, _), g(M + 0.01, n, a, e, p), y[r(1061)](p, _), v[r(1168)](p, _), m[r(956)](y, v), v[r(956)](m, y), m[r(608)](), v[r(608)]();
      for (let A = 0; A <= i; ++A) {
        const L = A / i * Math.PI * 2, P = -x * Math[r(2063)](L), S = x * Math[r(2626)](L);
        u.x = _.x + (P * v.x + S * m.x), u.y = _.y + (P * v.y + S * m.y), u.z = _.z + (P * v.z + S * m.z), c[r(3156)](u.x, u.y, u.z), l[r(1061)](u, _)[r(608)](), h[r(3156)](l.x, l.y, l.z), f[r(3156)](b / t), f[r(3156)](A / i);
      }
    }
    for (let b = 1; b <= t; b++)
      for (let M = 1; M <= i; M++) {
        const A = (i + 1) * (b - 1) + (M - 1), L = (i + 1) * b + (M - 1), P = (i + 1) * b + M, S = (i + 1) * (b - 1) + M;
        o[r(3156)](A, L, S), o[r(3156)](L, P, S);
      }
    this[r(2203)](o), this[r(3599)](r(3571), new W0(c, 3)), this[r(3599)](r(2111), new W0(h, 3)), this[r(3599)]("uv", new W0(f, 2));
    function g(b, M, A, L, P) {
      const S = r, I = Math[S(2063)](b), C = Math[S(2626)](b), G = A / M * b, $ = Math[S(2063)](G);
      P.x = L * (2 + $) * 0.5 * I, P.y = L * (2 + $) * C * 0.5, P.z = L * Math[S(2626)](G) * 0.5;
    }
  }
  copy(e) {
    const x = s;
    return super[x(2875)](e), this[x(1063)] = Object.assign({}, e[x(1063)]), this;
  }
  static [s(3037)](e) {
    const x = s;
    return new as(e.radius, e[x(1409)], e[x(1308)], e[x(1224)], e.p, e.q);
  }
}
class rs extends ox {
  constructor(e = new W2(new z(-1, -1, 0), new z(-1, 1, 0), new z(1, 1, 0)), x = 64, t = 1, i = 8, n = ![]) {
    const a = s;
    super(), this.type = a(2558), this.parameters = { path: e, tubularSegments: x, radius: t, radialSegments: i, closed: n };
    const r = e[a(1230)](x, n);
    this.tangents = r[a(499)], this[a(1273)] = r[a(1273)], this[a(2353)] = r[a(2353)];
    const o = new z(), c = new z(), h = new d0();
    let f = new z();
    const u = [], l = [], _ = [], p = [];
    m(), this[a(2203)](p), this[a(3599)](a(3571), new W0(u, 3)), this.setAttribute(a(2111), new W0(l, 3)), this.setAttribute("uv", new W0(_, 2));
    function m() {
      for (let b = 0; b < x; b++)
        y(b);
      y(n === ![] ? x : 0), g(), v();
    }
    function y(b) {
      const M = a;
      f = e[M(1778)](b / x, f);
      const A = r[M(1273)][b], L = r[M(2353)][b];
      for (let P = 0; P <= i; P++) {
        const S = P / i * Math.PI * 2, I = Math[M(2626)](S), C = -Math[M(2063)](S);
        c.x = C * A.x + I * L.x, c.y = C * A.y + I * L.y, c.z = C * A.z + I * L.z, c[M(608)](), l[M(3156)](c.x, c.y, c.z), o.x = f.x + t * c.x, o.y = f.y + t * c.y, o.z = f.z + t * c.z, u[M(3156)](o.x, o.y, o.z);
      }
    }
    function v() {
      const b = a;
      for (let M = 1; M <= x; M++)
        for (let A = 1; A <= i; A++) {
          const L = (i + 1) * (M - 1) + (A - 1), P = (i + 1) * M + (A - 1), S = (i + 1) * M + A, I = (i + 1) * (M - 1) + A;
          p[b(3156)](L, P, I), p.push(P, S, I);
        }
    }
    function g() {
      for (let b = 0; b <= x; b++)
        for (let M = 0; M <= i; M++)
          h.x = b / x, h.y = M / i, _.push(h.x, h.y);
    }
  }
  [s(2875)](e) {
    const x = s;
    return super.copy(e), this[x(1063)] = Object[x(1188)]({}, e[x(1063)]), this;
  }
  [s(3139)]() {
    const e = s, x = super[e(3139)]();
    return x.path = this[e(1063)][e(597)][e(3139)](), x;
  }
  static [s(3037)](e) {
    const x = s;
    return new rs(new X2[e[x(597)][x(566)]]().fromJSON(e.path), e[x(1308)], e[x(1232)], e[x(1224)], e[x(2089)]);
  }
}
class uh extends ox {
  constructor(e = null) {
    const x = s;
    if (super(), this.type = "WireframeGeometry", this[x(1063)] = { geometry: e }, e !== null) {
      const t = [], i = /* @__PURE__ */ new Set(), n = new z(), a = new z();
      if (e[x(3678)] !== null) {
        const r = e[x(3265)][x(3571)], o = e[x(3678)];
        let c = e.groups;
        c.length === 0 && (c = [{ start: 0, count: o.count, materialIndex: 0 }]);
        for (let h = 0, f = c[x(3105)]; h < f; ++h) {
          const u = c[h], l = u[x(1917)], _ = u.count;
          for (let p = l, m = l + _; p < m; p += 3)
            for (let y = 0; y < 3; y++) {
              const v = o[x(781)](p + y), g = o[x(781)](p + (y + 1) % 3);
              n[x(804)](r, v), a[x(804)](r, g), rc(n, a, i) === !![] && (t[x(3156)](n.x, n.y, n.z), t[x(3156)](a.x, a.y, a.z));
            }
        }
      } else {
        const r = e.attributes[x(3571)];
        for (let o = 0, c = r[x(1267)] / 3; o < c; o++)
          for (let h = 0; h < 3; h++) {
            const f = 3 * o + h, u = 3 * o + (h + 1) % 3;
            n[x(804)](r, f), a[x(804)](r, u), rc(n, a, i) === !![] && (t[x(3156)](n.x, n.y, n.z), t[x(3156)](a.x, a.y, a.z));
          }
      }
      this[x(3599)]("position", new W0(t, 3));
    }
  }
  copy(e) {
    const x = s;
    return super[x(2875)](e), this[x(1063)] = Object[x(1188)]({}, e[x(1063)]), this;
  }
}
function rc(d, e, x) {
  const t = s, i = d.x + "," + d.y + "," + d.z + "-" + e.x + "," + e.y + "," + e.z, n = e.x + "," + e.y + "," + e.z + "-" + d.x + "," + d.y + "," + d.z;
  return x[t(2086)](i) === !![] || x[t(2086)](n) === !![] ? ![] : (x.add(i), x[t(3026)](n), !![]);
}
var oc = Object.freeze({ __proto__: null, BoxGeometry: It, CapsuleGeometry: Kn, CircleGeometry: $n, ConeGeometry: Jn, CylinderGeometry: ci, DodecahedronGeometry: Qn, EdgesGeometry: dh, ExtrudeGeometry: xs, IcosahedronGeometry: es, LatheGeometry: xn, OctahedronGeometry: en, PlaneGeometry: $i, PolyhedronGeometry: rt, RingGeometry: ts, ShapeGeometry: is, SphereGeometry: tn, TetrahedronGeometry: ns, TorusGeometry: ss, TorusKnotGeometry: as, TubeGeometry: rs, WireframeGeometry: uh });
class bh extends jx {
  constructor(e) {
    const x = s;
    super(), this[x(3769)] = !![], this[x(566)] = x(2539), this[x(3282)] = new P0(0), this.transparent = !![], this[x(3438)] = !![], this[x(1104)](e);
  }
  copy(e) {
    const x = s;
    return super.copy(e), this[x(3282)][x(2875)](e[x(3282)]), this[x(3438)] = e[x(3438)], this;
  }
}
class ph extends ee {
  constructor(e) {
    const x = s;
    super(e), this[x(3704)] = !![], this[x(566)] = x(3706);
  }
}
class os extends jx {
  constructor(e) {
    const x = s;
    super(), this[x(2589)] = !![], this[x(2264)] = { STANDARD: "" }, this.type = x(1862), this[x(3282)] = new P0(16777215), this[x(771)] = 1, this.metalness = 0, this[x(3644)] = null, this[x(2399)] = null, this.lightMapIntensity = 1, this[x(2107)] = null, this.aoMapIntensity = 1, this[x(1599)] = new P0(0), this.emissiveIntensity = 1, this[x(2730)] = null, this.bumpMap = null, this[x(470)] = 1, this[x(811)] = null, this.normalMapType = Rt, this[x(2650)] = new d0(1, 1), this[x(629)] = null, this[x(2693)] = 1, this[x(498)] = 0, this[x(3213)] = null, this.metalnessMap = null, this[x(1453)] = null, this.envMap = null, this[x(3176)] = 1, this[x(1124)] = ![], this.wireframeLinewidth = 1, this[x(2700)] = "round", this[x(857)] = "round", this[x(1529)] = ![], this[x(3438)] = !![], this[x(1104)](e);
  }
  [s(2875)](e) {
    const x = s;
    return super[x(2875)](e), this[x(2264)] = { STANDARD: "" }, this.color[x(2875)](e[x(3282)]), this[x(771)] = e.roughness, this[x(1586)] = e[x(1586)], this[x(3644)] = e[x(3644)], this.lightMap = e[x(2399)], this.lightMapIntensity = e[x(623)], this[x(2107)] = e[x(2107)], this[x(2702)] = e[x(2702)], this[x(1599)].copy(e.emissive), this[x(2730)] = e[x(2730)], this.emissiveIntensity = e[x(1148)], this[x(758)] = e[x(758)], this.bumpScale = e.bumpScale, this[x(811)] = e.normalMap, this[x(920)] = e[x(920)], this[x(2650)][x(2875)](e[x(2650)]), this[x(629)] = e[x(629)], this[x(2693)] = e[x(2693)], this.displacementBias = e[x(498)], this.roughnessMap = e.roughnessMap, this[x(989)] = e.metalnessMap, this[x(1453)] = e[x(1453)], this[x(1477)] = e[x(1477)], this[x(3176)] = e[x(3176)], this.wireframe = e[x(1124)], this.wireframeLinewidth = e[x(977)], this[x(2700)] = e[x(2700)], this[x(857)] = e.wireframeLinejoin, this.flatShading = e[x(1529)], this[x(3438)] = e[x(3438)], this;
  }
}
class ot extends os {
  constructor(e) {
    const x = s;
    super(), this[x(2859)] = !![], this[x(2264)] = { STANDARD: "", PHYSICAL: "" }, this[x(566)] = "MeshPhysicalMaterial", this[x(945)] = null, this[x(1163)] = 0, this[x(1660)] = null, this[x(1111)] = new d0(1, 1), this.clearcoatNormalMap = null, this[x(3252)] = 1.5, Object.defineProperty(this, "reflectivity", { get: function() {
      const t = x;
      return Gx(2.5 * (this[t(3252)] - 1) / (this[t(3252)] + 1), 0, 1);
    }, set: function(t) {
      const i = x;
      this[i(3252)] = (1 + 0.4 * t) / (1 - 0.4 * t);
    } }), this[x(2734)] = null, this.iridescenceIOR = 1.3, this[x(2845)] = [100, 400], this.iridescenceThicknessMap = null, this[x(807)] = new P0(0), this[x(2078)] = null, this.sheenRoughness = 1, this[x(3168)] = null, this[x(2325)] = null, this.thickness = 0, this[x(1051)] = null, this[x(532)] = 1 / 0, this[x(2786)] = new P0(1, 1, 1), this[x(1354)] = 1, this[x(1581)] = null, this.specularColor = new P0(1, 1, 1), this[x(3637)] = null, this[x(1547)] = 0, this._clearcoat = 0, this._iridescence = 0, this[x(2041)] = 0, this.setValues(e);
  }
  get sheen() {
    return this[s(1547)];
  }
  set [s(1031)](e) {
    const x = s;
    this[x(1547)] > 0 != e > 0 && this[x(2185)]++, this[x(1547)] = e;
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set [s(2317)](e) {
    const x = s;
    this[x(3626)] > 0 != e > 0 && this.version++, this[x(3626)] = e;
  }
  get iridescence() {
    return this[s(3754)];
  }
  set iridescence(e) {
    const x = s;
    this._iridescence > 0 != e > 0 && this[x(2185)]++, this[x(3754)] = e;
  }
  get [s(2123)]() {
    return this[s(2041)];
  }
  set [s(2123)](e) {
    const x = s;
    this._transmission > 0 != e > 0 && this[x(2185)]++, this[x(2041)] = e;
  }
  copy(e) {
    const x = s;
    return super[x(2875)](e), this.defines = { STANDARD: "", PHYSICAL: "" }, this[x(2317)] = e[x(2317)], this[x(945)] = e[x(945)], this[x(1163)] = e[x(1163)], this[x(1660)] = e[x(1660)], this[x(3674)] = e[x(3674)], this[x(1111)].copy(e[x(1111)]), this.ior = e[x(3252)], this[x(3727)] = e[x(3727)], this[x(2734)] = e.iridescenceMap, this[x(477)] = e[x(477)], this.iridescenceThicknessRange = [...e[x(2845)]], this[x(3360)] = e[x(3360)], this[x(1031)] = e[x(1031)], this[x(807)][x(2875)](e[x(807)]), this[x(2078)] = e.sheenColorMap, this.sheenRoughness = e[x(1915)], this[x(3168)] = e.sheenRoughnessMap, this[x(2123)] = e[x(2123)], this[x(2325)] = e[x(2325)], this[x(2908)] = e[x(2908)], this[x(1051)] = e[x(1051)], this[x(532)] = e[x(532)], this.attenuationColor[x(2875)](e[x(2786)]), this[x(1354)] = e[x(1354)], this[x(1581)] = e.specularIntensityMap, this[x(3367)][x(2875)](e[x(3367)]), this[x(3637)] = e[x(3637)], this;
  }
}
class mh extends jx {
  constructor(e) {
    const x = s;
    super(), this[x(3052)] = !![], this[x(566)] = x(2522), this[x(3282)] = new P0(16777215), this[x(881)] = new P0(1118481), this.shininess = 30, this[x(3644)] = null, this[x(2399)] = null, this[x(623)] = 1, this[x(2107)] = null, this[x(2702)] = 1, this.emissive = new P0(0), this.emissiveIntensity = 1, this[x(2730)] = null, this[x(758)] = null, this[x(470)] = 1, this[x(811)] = null, this.normalMapType = Rt, this[x(2650)] = new d0(1, 1), this[x(629)] = null, this[x(2693)] = 1, this[x(498)] = 0, this[x(3470)] = null, this.alphaMap = null, this.envMap = null, this[x(2997)] = Wn, this[x(2531)] = 1, this[x(3759)] = 0.98, this[x(1124)] = ![], this[x(977)] = 1, this[x(2700)] = x(1981), this.wireframeLinejoin = "round", this.flatShading = ![], this[x(3438)] = !![], this[x(1104)](e);
  }
  copy(e) {
    const x = s;
    return super[x(2875)](e), this[x(3282)][x(2875)](e.color), this[x(881)].copy(e.specular), this[x(1274)] = e[x(1274)], this[x(3644)] = e[x(3644)], this[x(2399)] = e.lightMap, this.lightMapIntensity = e[x(623)], this[x(2107)] = e[x(2107)], this[x(2702)] = e[x(2702)], this[x(1599)][x(2875)](e.emissive), this[x(2730)] = e[x(2730)], this[x(1148)] = e.emissiveIntensity, this[x(758)] = e[x(758)], this[x(470)] = e[x(470)], this[x(811)] = e[x(811)], this[x(920)] = e[x(920)], this.normalScale[x(2875)](e[x(2650)]), this[x(629)] = e[x(629)], this[x(2693)] = e[x(2693)], this[x(498)] = e[x(498)], this.specularMap = e[x(3470)], this[x(1453)] = e.alphaMap, this.envMap = e[x(1477)], this[x(2997)] = e[x(2997)], this.reflectivity = e.reflectivity, this[x(3759)] = e[x(3759)], this[x(1124)] = e[x(1124)], this[x(977)] = e[x(977)], this[x(2700)] = e[x(2700)], this[x(857)] = e.wireframeLinejoin, this.flatShading = e[x(1529)], this.fog = e[x(3438)], this;
  }
}
class gh extends jx {
  constructor(e) {
    const x = s;
    super(), this[x(1560)] = !![], this[x(2264)] = { TOON: "" }, this[x(566)] = x(2281), this[x(3282)] = new P0(16777215), this[x(3644)] = null, this[x(2767)] = null, this[x(2399)] = null, this.lightMapIntensity = 1, this[x(2107)] = null, this[x(2702)] = 1, this.emissive = new P0(0), this[x(1148)] = 1, this[x(2730)] = null, this[x(758)] = null, this.bumpScale = 1, this[x(811)] = null, this[x(920)] = Rt, this.normalScale = new d0(1, 1), this[x(629)] = null, this.displacementScale = 1, this[x(498)] = 0, this[x(1453)] = null, this[x(1124)] = ![], this[x(977)] = 1, this[x(2700)] = x(1981), this[x(857)] = x(1981), this[x(3438)] = !![], this[x(1104)](e);
  }
  [s(2875)](e) {
    const x = s;
    return super[x(2875)](e), this[x(3282)].copy(e[x(3282)]), this[x(3644)] = e[x(3644)], this[x(2767)] = e[x(2767)], this.lightMap = e[x(2399)], this[x(623)] = e.lightMapIntensity, this[x(2107)] = e.aoMap, this[x(2702)] = e.aoMapIntensity, this[x(1599)].copy(e.emissive), this[x(2730)] = e[x(2730)], this[x(1148)] = e[x(1148)], this[x(758)] = e[x(758)], this[x(470)] = e[x(470)], this[x(811)] = e[x(811)], this.normalMapType = e[x(920)], this.normalScale[x(2875)](e[x(2650)]), this[x(629)] = e[x(629)], this[x(2693)] = e[x(2693)], this[x(498)] = e[x(498)], this[x(1453)] = e.alphaMap, this.wireframe = e.wireframe, this[x(977)] = e[x(977)], this[x(2700)] = e[x(2700)], this[x(857)] = e[x(857)], this[x(3438)] = e[x(3438)], this;
  }
}
class _h extends jx {
  constructor(e) {
    const x = s;
    super(), this[x(3371)] = !![], this[x(566)] = x(3155), this[x(758)] = null, this[x(470)] = 1, this.normalMap = null, this[x(920)] = Rt, this.normalScale = new d0(1, 1), this.displacementMap = null, this[x(2693)] = 1, this[x(498)] = 0, this[x(1124)] = ![], this[x(977)] = 1, this[x(1529)] = ![], this[x(1104)](e);
  }
  [s(2875)](e) {
    const x = s;
    return super[x(2875)](e), this.bumpMap = e[x(758)], this[x(470)] = e.bumpScale, this[x(811)] = e[x(811)], this[x(920)] = e[x(920)], this[x(2650)][x(2875)](e.normalScale), this[x(629)] = e[x(629)], this[x(2693)] = e[x(2693)], this[x(498)] = e[x(498)], this[x(1124)] = e[x(1124)], this[x(977)] = e.wireframeLinewidth, this[x(1529)] = e.flatShading, this;
  }
}
class vh extends jx {
  constructor(e) {
    const x = s;
    super(), this[x(2251)] = !![], this.type = x(3331), this.color = new P0(16777215), this[x(3644)] = null, this[x(2399)] = null, this[x(623)] = 1, this.aoMap = null, this[x(2702)] = 1, this.emissive = new P0(0), this[x(1148)] = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this[x(811)] = null, this[x(920)] = Rt, this[x(2650)] = new d0(1, 1), this[x(629)] = null, this[x(2693)] = 1, this.displacementBias = 0, this[x(3470)] = null, this.alphaMap = null, this[x(1477)] = null, this[x(2997)] = Wn, this[x(2531)] = 1, this[x(3759)] = 0.98, this[x(1124)] = ![], this[x(977)] = 1, this.wireframeLinecap = "round", this[x(857)] = x(1981), this[x(1529)] = ![], this[x(3438)] = !![], this[x(1104)](e);
  }
  [s(2875)](e) {
    const x = s;
    return super[x(2875)](e), this[x(3282)].copy(e[x(3282)]), this[x(3644)] = e.map, this[x(2399)] = e[x(2399)], this[x(623)] = e[x(623)], this[x(2107)] = e.aoMap, this[x(2702)] = e[x(2702)], this.emissive[x(2875)](e.emissive), this[x(2730)] = e[x(2730)], this.emissiveIntensity = e[x(1148)], this.bumpMap = e.bumpMap, this[x(470)] = e[x(470)], this[x(811)] = e.normalMap, this[x(920)] = e[x(920)], this[x(2650)].copy(e[x(2650)]), this.displacementMap = e[x(629)], this[x(2693)] = e[x(2693)], this[x(498)] = e[x(498)], this[x(3470)] = e.specularMap, this[x(1453)] = e[x(1453)], this[x(1477)] = e.envMap, this[x(2997)] = e[x(2997)], this[x(2531)] = e.reflectivity, this[x(3759)] = e[x(3759)], this[x(1124)] = e.wireframe, this[x(977)] = e[x(977)], this[x(2700)] = e[x(2700)], this[x(857)] = e[x(857)], this.flatShading = e[x(1529)], this.fog = e[x(3438)], this;
  }
}
class yh extends jx {
  constructor(e) {
    const x = s;
    super(), this[x(1966)] = !![], this[x(2264)] = { MATCAP: "" }, this[x(566)] = x(1486), this.color = new P0(16777215), this.matcap = null, this[x(3644)] = null, this[x(758)] = null, this[x(470)] = 1, this.normalMap = null, this[x(920)] = Rt, this[x(2650)] = new d0(1, 1), this[x(629)] = null, this[x(2693)] = 1, this[x(498)] = 0, this.alphaMap = null, this[x(1529)] = ![], this[x(3438)] = !![], this[x(1104)](e);
  }
  copy(e) {
    const x = s;
    return super[x(2875)](e), this.defines = { MATCAP: "" }, this[x(3282)][x(2875)](e[x(3282)]), this.matcap = e[x(1247)], this.map = e[x(3644)], this[x(758)] = e[x(758)], this.bumpScale = e[x(470)], this[x(811)] = e[x(811)], this[x(920)] = e[x(920)], this.normalScale[x(2875)](e.normalScale), this[x(629)] = e[x(629)], this[x(2693)] = e[x(2693)], this[x(498)] = e[x(498)], this[x(1453)] = e[x(1453)], this.flatShading = e[x(1529)], this.fog = e[x(3438)], this;
  }
}
class wh extends te {
  constructor(e) {
    const x = s;
    super(), this[x(1770)] = !![], this[x(566)] = "LineDashedMaterial", this[x(2204)] = 1, this[x(1831)] = 3, this[x(2514)] = 1, this[x(1104)](e);
  }
  [s(2875)](e) {
    const x = s;
    return super.copy(e), this[x(2204)] = e.scale, this[x(1831)] = e[x(1831)], this.gapSize = e[x(2514)], this;
  }
}
function Te(d, e, x) {
  const t = s;
  return q2(d) ? new d.constructor(d[t(1049)](e, x !== void 0 ? x : d[t(3105)])) : d.slice(e, x);
}
function Jt(d, e, x) {
  const t = s;
  return !d || !x && d[t(2787)] === e ? d : typeof e[t(2823)] === t(1407) ? new e(d) : Array[t(2028)][t(3482)].call(d);
}
function q2(d) {
  return ArrayBuffer[s(1842)](d) && !(d instanceof DataView);
}
function Mh(d) {
  const e = s;
  function x(n, a) {
    return d[n] - d[a];
  }
  const t = d[e(3105)], i = new Array(t);
  for (let n = 0; n !== t; ++n)
    i[n] = n;
  return i[e(614)](x), i;
}
function c2(d, e, x) {
  const t = s, i = d[t(3105)], n = new d.constructor(i);
  for (let a = 0, r = 0; r !== i; ++a) {
    const o = x[a] * e;
    for (let c = 0; c !== e; ++c)
      n[r++] = d[o + c];
  }
  return n;
}
function Y2(d, e, x, t) {
  const i = s;
  let n = 1, a = d[0];
  for (; a !== void 0 && a[t] === void 0; )
    a = d[n++];
  if (a === void 0)
    return;
  let r = a[t];
  if (r !== void 0)
    if (Array[i(1609)](r))
      do
        r = a[t], r !== void 0 && (e[i(3156)](a.time), x[i(3156)].apply(x, r)), a = d[n++];
      while (a !== void 0);
    else if (r[i(1496)] !== void 0)
      do
        r = a[t], r !== void 0 && (e[i(3156)](a.time), r.toArray(x, x[i(3105)])), a = d[n++];
      while (a !== void 0);
    else
      do
        r = a[t], r !== void 0 && (e.push(a[i(3082)]), x[i(3156)](r)), a = d[n++];
      while (a !== void 0);
}
function Om(d, e, x, t, i = 30) {
  const n = s, a = d.clone();
  a[n(3710)] = e;
  const r = [];
  for (let c = 0; c < a[n(1823)].length; ++c) {
    const h = a[n(1823)][c], f = h[n(913)](), u = [], l = [];
    for (let _ = 0; _ < h[n(2621)][n(3105)]; ++_) {
      const p = h[n(2621)][_] * i;
      if (!(p < x || p >= t)) {
        u[n(3156)](h[n(2621)][_]);
        for (let m = 0; m < f; ++m)
          l[n(3156)](h[n(910)][_ * f + m]);
      }
    }
    u.length !== 0 && (h.times = Jt(u, h.times[n(2787)]), h[n(910)] = Jt(l, h.values[n(2787)]), r.push(h));
  }
  a[n(1823)] = r;
  let o = 1 / 0;
  for (let c = 0; c < a[n(1823)][n(3105)]; ++c)
    o > a[n(1823)][c].times[0] && (o = a[n(1823)][c][n(2621)][0]);
  for (let c = 0; c < a[n(1823)].length; ++c)
    a.tracks[c][n(1184)](-1 * o);
  return a[n(694)](), a;
}
function Nm(d, e = 0, x = d, t = 30) {
  const i = s;
  t <= 0 && (t = 30);
  const n = x[i(1823)][i(3105)], a = e / t;
  for (let r = 0; r < n; ++r) {
    const o = x.tracks[r], c = o[i(3327)];
    if (c === i(1318) || c === "string")
      continue;
    const h = d[i(1823)][i(1602)](function(v) {
      const g = i;
      return v.name === o[g(3710)] && v[g(3327)] === c;
    });
    if (h === void 0)
      continue;
    let f = 0;
    const u = o[i(913)]();
    o[i(1300)][i(3718)] && (f = u / 3);
    let l = 0;
    const _ = h.getValueSize();
    h[i(1300)].isInterpolantFactoryMethodGLTFCubicSpline && (l = _ / 3);
    const p = o.times[i(3105)] - 1;
    let m;
    if (a <= o[i(2621)][0]) {
      const v = f, g = u - f;
      m = Te(o[i(910)], v, g);
    } else if (a >= o.times[p]) {
      const v = p * u + f, g = v + u - f;
      m = Te(o.values, v, g);
    } else {
      const v = o.createInterpolant(), g = f, b = u - f;
      v.evaluate(a), m = Te(v.resultBuffer, g, b);
    }
    c === i(3055) && new $x()[i(666)](m)[i(608)]()[i(2500)]()[i(1496)](m);
    const y = h[i(2621)][i(3105)];
    for (let v = 0; v < y; ++v) {
      const g = v * _ + l;
      if (c === i(3055))
        $x[i(2903)](h[i(910)], g, m, 0, h[i(910)], g);
      else {
        const b = _ - l * 2;
        for (let M = 0; M < b; ++M)
          h[i(910)][g + M] -= m[M];
      }
    }
  }
  return d.blendMode = M2, d;
}
const Um = { arraySlice: Te, convertArray: Jt, isTypedArray: q2, getKeyframeOrder: Mh, sortedArray: c2, flattenJSON: Y2, subclip: Om, makeClipAdditive: Nm };
class nn {
  constructor(e, x, t, i) {
    const n = s;
    this[n(1996)] = e, this[n(1596)] = 0, this[n(902)] = i !== void 0 ? i : new x.constructor(t), this[n(3089)] = x, this[n(814)] = t, this.settings = null, this.DefaultSettings_ = {};
  }
  evaluate(e) {
    const x = s, t = this[x(1996)];
    let i = this[x(1596)], n = t[i], a = t[i - 1];
    x: {
      e: {
        let r;
        t: {
          i:
            if (!(e < n)) {
              for (let o = i + 2; ; ) {
                if (n === void 0) {
                  if (e < a)
                    break i;
                  return i = t[x(3105)], this[x(1596)] = i, this[x(1841)](i - 1);
                }
                if (i === o)
                  break;
                if (a = n, n = t[++i], e < n)
                  break e;
              }
              r = t[x(3105)];
              break t;
            }
          if (!(e >= a)) {
            const o = t[1];
            e < o && (i = 2, a = o);
            for (let c = i - 2; ; ) {
              if (a === void 0)
                return this[x(1596)] = 0, this[x(1841)](0);
              if (i === c)
                break;
              if (n = a, a = t[--i - 1], e >= a)
                break e;
            }
            r = i, i = 0;
            break t;
          }
          break x;
        }
        for (; i < r; ) {
          const o = i + r >>> 1;
          e < t[o] ? r = o : i = o + 1;
        }
        if (n = t[i], a = t[i - 1], a === void 0)
          return this._cachedIndex = 0, this[x(1841)](0);
        if (n === void 0)
          return i = t[x(3105)], this._cachedIndex = i, this[x(1841)](i - 1);
      }
      this[x(1596)] = i, this[x(1851)](i, a, n);
    }
    return this[x(2513)](i, a, e, n);
  }
  getSettings_() {
    const e = s;
    return this[e(3223)] || this[e(2583)];
  }
  [s(1841)](e) {
    const x = s, t = this[x(902)], i = this[x(3089)], n = this[x(814)], a = e * n;
    for (let r = 0; r !== n; ++r)
      t[r] = i[a + r];
    return t;
  }
  interpolate_() {
    const e = s;
    throw new Error(e(1857));
  }
  intervalChanged_() {
  }
}
class Sh extends nn {
  constructor(e, x, t, i) {
    const n = s;
    super(e, x, t, i), this[n(2962)] = -0, this[n(1566)] = -0, this[n(3110)] = -0, this._offsetNext = -0, this[n(2583)] = { endingStart: Zt, endingEnd: Zt };
  }
  [s(1851)](e, x, t) {
    const i = s, n = this[i(1996)];
    let a = e - 2, r = e + 1, o = n[a], c = n[r];
    if (o === void 0)
      switch (this[i(1327)]()[i(573)]) {
        case Kt:
          a = e, o = 2 * x - t;
          break;
        case Dn:
          a = n[i(3105)] - 2, o = x + n[a] - n[a + 1];
          break;
        default:
          a = e, o = t;
      }
    if (c === void 0)
      switch (this.getSettings_().endingEnd) {
        case Kt:
          r = e, c = 2 * t - x;
          break;
        case Dn:
          r = 1, c = t + n[1] - n[0];
          break;
        default:
          r = e - 1, c = x;
      }
    const h = (t - x) * 0.5, f = this[i(814)];
    this[i(2962)] = h / (x - o), this[i(3110)] = h / (c - t), this[i(1566)] = a * f, this._offsetNext = r * f;
  }
  [s(2513)](e, x, t, i) {
    const n = s, a = this.resultBuffer, r = this[n(3089)], o = this[n(814)], c = e * o, h = c - o, f = this[n(1566)], u = this._offsetNext, l = this._weightPrev, _ = this[n(3110)], p = (t - x) / (i - x), m = p * p, y = m * p, v = -l * y + 2 * l * m - l * p, g = (1 + l) * y + (-1.5 - 2 * l) * m + (-0.5 + l) * p + 1, b = (-1 - _) * y + (1.5 + _) * m + 0.5 * p, M = _ * y - _ * m;
    for (let A = 0; A !== o; ++A)
      a[A] = v * r[f + A] + g * r[h + A] + b * r[c + A] + M * r[u + A];
    return a;
  }
}
class Z2 extends nn {
  constructor(e, x, t, i) {
    super(e, x, t, i);
  }
  interpolate_(e, x, t, i) {
    const n = s, a = this.resultBuffer, r = this[n(3089)], o = this.valueSize, c = e * o, h = c - o, f = (t - x) / (i - x), u = 1 - f;
    for (let l = 0; l !== o; ++l)
      a[l] = r[h + l] * u + r[c + l] * f;
    return a;
  }
}
class Th extends nn {
  constructor(e, x, t, i) {
    super(e, x, t, i);
  }
  [s(2513)](e) {
    return this[s(1841)](e - 1);
  }
}
class Oe {
  constructor(e, x, t, i) {
    const n = s;
    if (e === void 0)
      throw new Error(n(1010));
    if (x === void 0 || x[n(3105)] === 0)
      throw new Error(n(3656) + e);
    this[n(3710)] = e, this.times = Jt(x, this[n(3554)]), this[n(910)] = Jt(t, this.ValueBufferType), this[n(850)](i || this.DefaultInterpolation);
  }
  static [s(3139)](e) {
    const x = s, t = e.constructor;
    let i;
    if (t[x(3139)] !== this[x(3139)])
      i = t.toJSON(e);
    else {
      i = { name: e.name, times: Jt(e[x(2621)], Array), values: Jt(e[x(910)], Array) };
      const n = e.getInterpolation();
      n !== e.DefaultInterpolation && (i[x(3062)] = n);
    }
    return i[x(566)] = e.ValueTypeName, i;
  }
  InterpolantFactoryMethodDiscrete(e) {
    const x = s;
    return new Th(this[x(2621)], this[x(910)], this[x(913)](), e);
  }
  [s(1468)](e) {
    const x = s;
    return new Z2(this[x(2621)], this[x(910)], this[x(913)](), e);
  }
  [s(1508)](e) {
    const x = s;
    return new Sh(this.times, this.values, this[x(913)](), e);
  }
  [s(850)](e) {
    const x = s;
    let t;
    switch (e) {
      case ki:
        t = this[x(1665)];
        break;
      case ai:
        t = this[x(1468)];
        break;
      case oa:
        t = this[x(1508)];
        break;
    }
    if (t === void 0) {
      const i = x(2339) + this[x(3327)] + x(1210) + this[x(3710)];
      if (this[x(1300)] === void 0)
        if (e !== this.DefaultInterpolation)
          this[x(850)](this[x(925)]);
        else
          throw new Error(i);
      return console[x(3629)](x(2834), i), this;
    }
    return this[x(1300)] = t, this;
  }
  [s(3730)]() {
    const e = s;
    switch (this.createInterpolant) {
      case this[e(1665)]:
        return ki;
      case this.InterpolantFactoryMethodLinear:
        return ai;
      case this.InterpolantFactoryMethodSmooth:
        return oa;
    }
  }
  getValueSize() {
    const e = s;
    return this[e(910)][e(3105)] / this[e(2621)][e(3105)];
  }
  [s(1184)](e) {
    const x = s;
    if (e !== 0) {
      const t = this[x(2621)];
      for (let i = 0, n = t.length; i !== n; ++i)
        t[i] += e;
    }
    return this;
  }
  [s(2204)](e) {
    if (e !== 1) {
      const x = this.times;
      for (let t = 0, i = x.length; t !== i; ++t)
        x[t] *= e;
    }
    return this;
  }
  [s(549)](e, x) {
    const t = s, i = this[t(2621)], n = i[t(3105)];
    let a = 0, r = n - 1;
    for (; a !== n && i[a] < e; )
      ++a;
    for (; r !== -1 && i[r] > x; )
      --r;
    if (++r, a !== 0 || r !== n) {
      a >= r && (r = Math[t(1803)](r, 1), a = r - 1);
      const o = this.getValueSize();
      this.times = Te(i, a, r), this[t(910)] = Te(this[t(910)], a * o, r * o);
    }
    return this;
  }
  [s(1262)]() {
    const e = s;
    let x = !![];
    const t = this[e(913)]();
    t - Math[e(2697)](t) !== 0 && (console[e(533)]("THREE.KeyframeTrack: Invalid value size in track.", this), x = ![]);
    const i = this[e(2621)], n = this[e(910)], a = i[e(3105)];
    a === 0 && (console[e(533)](e(1559), this), x = ![]);
    let r = null;
    for (let o = 0; o !== a; o++) {
      const c = i[o];
      if (typeof c === e(1407) && isNaN(c)) {
        console.error(e(3703), this, o, c), x = ![];
        break;
      }
      if (r !== null && r > c) {
        console.error(e(1177), this, o, c, r), x = ![];
        break;
      }
      r = c;
    }
    if (n !== void 0 && q2(n))
      for (let o = 0, c = n[e(3105)]; o !== c; ++o) {
        const h = n[o];
        if (isNaN(h)) {
          console[e(533)]("THREE.KeyframeTrack: Value is not a valid number.", this, o, h), x = ![];
          break;
        }
      }
    return x;
  }
  [s(2996)]() {
    const e = s, x = Te(this.times), t = Te(this.values), i = this[e(913)](), n = this[e(3730)]() === oa, a = x.length - 1;
    let r = 1;
    for (let o = 1; o < a; ++o) {
      let c = ![];
      const h = x[o], f = x[o + 1];
      if (h !== f && (o !== 1 || h !== x[0]))
        if (n)
          c = !![];
        else {
          const u = o * i, l = u - i, _ = u + i;
          for (let p = 0; p !== i; ++p) {
            const m = t[u + p];
            if (m !== t[l + p] || m !== t[_ + p]) {
              c = !![];
              break;
            }
          }
        }
      if (c) {
        if (o !== r) {
          x[r] = x[o];
          const u = o * i, l = r * i;
          for (let _ = 0; _ !== i; ++_)
            t[l + _] = t[u + _];
        }
        ++r;
      }
    }
    if (a > 0) {
      x[r] = x[a];
      for (let o = a * i, c = r * i, h = 0; h !== i; ++h)
        t[c + h] = t[o + h];
      ++r;
    }
    return r !== x[e(3105)] ? (this[e(2621)] = Te(x, 0, r), this[e(910)] = Te(t, 0, r * i)) : (this[e(2621)] = x, this[e(910)] = t), this;
  }
  clone() {
    const e = s, x = Te(this.times, 0), t = Te(this[e(910)], 0), i = this[e(2787)], n = new i(this.name, x, t);
    return n[e(1300)] = this.createInterpolant, n;
  }
}
Oe[s(2028)].TimeBufferType = Float32Array, Oe[s(2028)][s(3426)] = Float32Array, Oe[s(2028)].DefaultInterpolation = ai;
class qt extends Oe {
}
qt[s(2028)][s(3327)] = s(1318), qt[s(2028)].ValueBufferType = Array, qt[s(2028)][s(925)] = ki, qt[s(2028)][s(1468)] = void 0, qt[s(2028)][s(1508)] = void 0;
class K2 extends Oe {
}
K2[s(2028)][s(3327)] = s(3282);
class ji extends Oe {
}
ji[s(2028)].ValueTypeName = "number";
class Eh extends nn {
  constructor(e, x, t, i) {
    super(e, x, t, i);
  }
  [s(2513)](e, x, t, i) {
    const n = s, a = this[n(902)], r = this.sampleValues, o = this.valueSize, c = (t - x) / (i - x);
    let h = e * o;
    for (let f = h + o; h !== f; h += 4)
      $x[n(3555)](a, 0, r, h - o, r, h, c);
    return a;
  }
}
class Mt extends Oe {
  InterpolantFactoryMethodLinear(e) {
    return new Eh(this.times, this.values, this.getValueSize(), e);
  }
}
Mt[s(2028)][s(3327)] = s(3055), Mt[s(2028)][s(925)] = ai, Mt[s(2028)][s(1508)] = void 0;
class Yt extends Oe {
}
Yt[s(2028)][s(3327)] = s(3335), Yt[s(2028)][s(3426)] = Array, Yt[s(2028)][s(925)] = ki, Yt.prototype[s(1468)] = void 0, Yt[s(2028)][s(1508)] = void 0;
class Xi extends Oe {
}
Xi.prototype[s(3327)] = "vector";
class qi {
  constructor(e, x = -1, t, i = _a) {
    const n = s;
    this[n(3710)] = e, this[n(1823)] = t, this[n(3403)] = x, this[n(3620)] = i, this[n(3104)] = ve(), this.duration < 0 && this[n(694)]();
  }
  static [s(1359)](e) {
    const x = s, t = [], i = e[x(1823)], n = 1 / (e[x(3178)] || 1);
    for (let r = 0, o = i[x(3105)]; r !== o; ++r)
      t[x(3156)](Bm(i[r])[x(2204)](n));
    const a = new this(e[x(3710)], e[x(3403)], t, e[x(3620)]);
    return a[x(3104)] = e[x(3104)], a;
  }
  static toJSON(e) {
    const x = s, t = [], i = e[x(1823)], n = { name: e[x(3710)], duration: e[x(3403)], tracks: t, uuid: e[x(3104)], blendMode: e.blendMode };
    for (let a = 0, r = i[x(3105)]; a !== r; ++a)
      t.push(Oe[x(3139)](i[a]));
    return n;
  }
  static CreateFromMorphTargetSequence(e, x, t, i) {
    const n = s, a = x[n(3105)], r = [];
    for (let o = 0; o < a; o++) {
      let c = [], h = [];
      c[n(3156)]((o + a - 1) % a, o, (o + 1) % a), h.push(0, 1, 0);
      const f = Mh(c);
      c = c2(c, 1, f), h = c2(h, 1, f), !i && c[0] === 0 && (c[n(3156)](a), h[n(3156)](h[0])), r[n(3156)](new ji(n(1645) + x[o].name + "]", c, h)[n(2204)](1 / t));
    }
    return new this(e, -1, r);
  }
  static findByName(e, x) {
    const t = s;
    let i = e;
    if (!Array[t(1609)](e)) {
      const n = e;
      i = n.geometry && n[t(1353)][t(1280)] || n.animations;
    }
    for (let n = 0; n < i[t(3105)]; n++)
      if (i[n].name === x)
        return i[n];
    return null;
  }
  static [s(996)](e, x, t) {
    const i = s, n = {}, a = /^([\w-]*?)([\d]+)$/;
    for (let o = 0, c = e[i(3105)]; o < c; o++) {
      const h = e[o], f = h.name.match(a);
      if (f && f[i(3105)] > 1) {
        const u = f[1];
        let l = n[u];
        !l && (n[u] = l = []), l[i(3156)](h);
      }
    }
    const r = [];
    for (const o in n)
      r[i(3156)](this[i(3798)](o, n[o], x, t));
    return r;
  }
  static parseAnimation(e, x) {
    const t = s;
    if (!e)
      return console[t(533)](t(2289)), null;
    const i = function(u, l, _, p, m) {
      const y = t;
      if (_[y(3105)] !== 0) {
        const v = [], g = [];
        Y2(_, v, g, p), v[y(3105)] !== 0 && m[y(3156)](new u(l, v, g));
      }
    }, n = [], a = e[t(3710)] || t(2238), r = e[t(3178)] || 30, o = e[t(3620)];
    let c = e.length || -1;
    const h = e[t(1015)] || [];
    for (let u = 0; u < h[t(3105)]; u++) {
      const l = h[u][t(2070)];
      if (!(!l || l[t(3105)] === 0))
        if (l[0][t(2461)]) {
          const _ = {};
          let p;
          for (p = 0; p < l.length; p++)
            if (l[p].morphTargets)
              for (let m = 0; m < l[p][t(2461)][t(3105)]; m++)
                _[l[p][t(2461)][m]] = -1;
          for (const m in _) {
            const y = [], v = [];
            for (let g = 0; g !== l[p].morphTargets[t(3105)]; ++g) {
              const b = l[p];
              y[t(3156)](b[t(3082)]), v[t(3156)](b[t(1519)] === m ? 1 : 0);
            }
            n[t(3156)](new ji(t(809) + m + "]", y, v));
          }
          c = _.length * r;
        } else {
          const _ = t(3358) + x[u][t(3710)] + "]";
          i(Xi, _ + t(2888), l, t(1365), n), i(Mt, _ + ".quaternion", l, t(3682), n), i(Xi, _ + ".scale", l, t(2689), n);
        }
    }
    return n[t(3105)] === 0 ? null : new this(a, c, n, o);
  }
  resetDuration() {
    const e = s, x = this[e(1823)];
    let t = 0;
    for (let i = 0, n = x.length; i !== n; ++i) {
      const a = this.tracks[i];
      t = Math.max(t, a[e(2621)][a[e(2621)][e(3105)] - 1]);
    }
    return this[e(3403)] = t, this;
  }
  [s(549)]() {
    const e = s;
    for (let x = 0; x < this[e(1823)][e(3105)]; x++)
      this[e(1823)][x].trim(0, this[e(3403)]);
    return this;
  }
  validate() {
    const e = s;
    let x = !![];
    for (let t = 0; t < this[e(1823)][e(3105)]; t++)
      x = x && this[e(1823)][t][e(1262)]();
    return x;
  }
  [s(2996)]() {
    const e = s;
    for (let x = 0; x < this.tracks[e(3105)]; x++)
      this.tracks[x][e(2996)]();
    return this;
  }
  clone() {
    const e = s, x = [];
    for (let t = 0; t < this[e(1823)][e(3105)]; t++)
      x[e(3156)](this[e(1823)][t][e(2272)]());
    return new this[e(2787)](this[e(3710)], this[e(3403)], x, this.blendMode);
  }
  [s(3139)]() {
    return this[s(2787)].toJSON(this);
  }
}
function zm(d) {
  const e = s;
  switch (d.toLowerCase()) {
    case e(1923):
    case e(2507):
    case e(2535):
    case "number":
    case e(1998):
      return ji;
    case e(1484):
    case e(1538):
    case e(2077):
    case e(2884):
      return Xi;
    case e(3282):
      return K2;
    case e(3055):
      return Mt;
    case e(1318):
    case e(1443):
      return qt;
    case e(3335):
      return Yt;
  }
  throw new Error(e(545) + d);
}
function Bm(d) {
  const e = s;
  if (d.type === void 0)
    throw new Error(e(3805));
  const x = zm(d.type);
  if (d.times === void 0) {
    const t = [], i = [];
    Y2(d[e(2070)], t, i, e(1811)), d[e(2621)] = t, d[e(910)] = i;
  }
  return x[e(1359)] !== void 0 ? x[e(1359)](d) : new x(d[e(3710)], d[e(2621)], d.values, d.interpolation);
}
const Lt = { enabled: ![], files: {}, add: function(d, e) {
  this[s(2679)] !== ![] && (this.files[d] = e);
}, get: function(d) {
  const e = s;
  if (this.enabled !== ![])
    return this[e(1070)][d];
}, remove: function(d) {
  const e = s;
  delete this[e(1070)][d];
}, clear: function() {
  const d = s;
  this[d(1070)] = {};
} };
class $2 {
  constructor(e, x, t) {
    const i = s, n = this;
    let a = ![], r = 0, o = 0, c;
    const h = [];
    this[i(2602)] = void 0, this[i(1299)] = e, this[i(1026)] = x, this.onError = t, this.itemStart = function(f) {
      o++, a === ![] && n.onStart !== void 0 && n.onStart(f, r, o), a = !![];
    }, this[i(3239)] = function(f) {
      const u = i;
      r++, n[u(1026)] !== void 0 && n[u(1026)](f, r, o), r === o && (a = ![], n[u(1299)] !== void 0 && n[u(1299)]());
    }, this[i(829)] = function(f) {
      n[i(628)] !== void 0 && n.onError(f);
    }, this[i(765)] = function(f) {
      return c ? c(f) : f;
    }, this[i(3723)] = function(f) {
      return c = f, this;
    }, this[i(972)] = function(f, u) {
      return h.push(f, u), this;
    }, this.removeHandler = function(f) {
      const u = i, l = h[u(882)](f);
      return l !== -1 && h[u(1733)](l, 2), this;
    }, this[i(2129)] = function(f) {
      const u = i;
      for (let l = 0, _ = h[u(3105)]; l < _; l += 2) {
        const p = h[l], m = h[l + 1];
        if (p.global && (p.lastIndex = 0), p[u(1081)](f))
          return m;
      }
      return null;
    };
  }
}
const Ah = new $2();
class ce {
  constructor(e) {
    const x = s;
    this[x(3235)] = e !== void 0 ? e : Ah, this[x(2825)] = "anonymous", this[x(1062)] = ![], this[x(597)] = "", this[x(1421)] = "", this[x(1283)] = {};
  }
  [s(3442)]() {
  }
  [s(2909)](e, x) {
    const t = this;
    return new Promise(function(i, n) {
      t[c0(3442)](e, i, x, n);
    });
  }
  [s(1359)]() {
  }
  [s(1086)](e) {
    const x = s;
    return this[x(2825)] = e, this;
  }
  [s(2958)](e) {
    const x = s;
    return this[x(1062)] = e, this;
  }
  [s(3121)](e) {
    const x = s;
    return this[x(597)] = e, this;
  }
  setResourcePath(e) {
    const x = s;
    return this[x(1421)] = e, this;
  }
  setRequestHeader(e) {
    const x = s;
    return this[x(1283)] = e, this;
  }
}
const et = {};
class Fm extends Error {
  constructor(e, x) {
    const t = s;
    super(e), this[t(2943)] = x;
  }
}
class ye extends ce {
  constructor(e) {
    super(e);
  }
  [s(3442)](e, x, t, i) {
    const n = s;
    e === void 0 && (e = ""), this[n(597)] !== void 0 && (e = this[n(597)] + e), e = this.manager.resolveURL(e);
    const a = Lt.get(e);
    if (a !== void 0)
      return this[n(3235)].itemStart(e), setTimeout(() => {
        const h = n;
        x && x(a), this[h(3235)][h(3239)](e);
      }, 0), a;
    if (et[e] !== void 0) {
      et[e][n(3156)]({ onLoad: x, onProgress: t, onError: i });
      return;
    }
    et[e] = [], et[e][n(3156)]({ onLoad: x, onProgress: t, onError: i });
    const r = new Request(e, { headers: new Headers(this[n(1283)]), credentials: this[n(1062)] ? n(1639) : n(1861) }), o = this.mimeType, c = this[n(1116)];
    fetch(r)[n(1941)]((h) => {
      const f = n;
      if (h.status === 200 || h[f(1512)] === 0) {
        if (h[f(1512)] === 0 && console[f(3629)](f(2382)), typeof ReadableStream > "u" || h[f(1698)] === void 0 || h[f(1698)][f(509)] === void 0)
          return h;
        const u = et[e], l = h[f(1698)][f(509)](), _ = h[f(2056)][f(3016)](f(1136)) || h[f(2056)][f(3016)]("X-File-Size"), p = _ ? parseInt(_) : 0, m = p !== 0;
        let y = 0;
        const v = new ReadableStream({ start(g) {
          b();
          function b() {
            const M = c0;
            l[M(1276)]()[M(1941)](({ done: A, value: L }) => {
              const P = M;
              if (A)
                g.close();
              else {
                y += L[P(3247)];
                const S = new ProgressEvent(P(2987), { lengthComputable: m, loaded: y, total: p });
                for (let I = 0, C = u.length; I < C; I++) {
                  const G = u[I];
                  G[P(1026)] && G.onProgress(S);
                }
                g[P(1947)](L), b();
              }
            });
          }
        } });
        return new Response(v);
      } else
        throw new Fm(f(1946) + h[f(3385)] + '" responded with ' + h.status + ": " + h[f(2304)], h);
    })[n(1941)]((h) => {
      const f = n;
      switch (c) {
        case "arraybuffer":
          return h[f(2777)]();
        case f(1457):
          return h.blob();
        case "document":
          return h[f(3536)]().then((u) => {
            const l = f;
            return new DOMParser()[l(3296)](u, o);
          });
        case "json":
          return h.json();
        default:
          if (o === void 0)
            return h[f(3536)]();
          {
            const u = /charset="?([^;"\s]*)"?/i, l = u[f(625)](o), _ = l && l[1] ? l[1][f(2050)]() : void 0, p = new TextDecoder(_);
            return h[f(2777)]()[f(1941)]((m) => p[f(528)](m));
          }
      }
    })[n(1941)]((h) => {
      const f = n;
      Lt[f(3026)](e, h);
      const u = et[e];
      delete et[e];
      for (let l = 0, _ = u[f(3105)]; l < _; l++) {
        const p = u[l];
        p[f(1299)] && p[f(1299)](h);
      }
    }).catch((h) => {
      const f = n, u = et[e];
      if (u === void 0)
        throw this[f(3235)].itemError(e), h;
      delete et[e];
      for (let l = 0, _ = u[f(3105)]; l < _; l++) {
        const p = u[l];
        p[f(628)] && p[f(628)](h);
      }
      this.manager[f(829)](e);
    }).finally(() => {
      const h = n;
      this.manager[h(3239)](e);
    }), this[n(3235)][n(2663)](e);
  }
  [s(2624)](e) {
    const x = s;
    return this[x(1116)] = e, this;
  }
  [s(1369)](e) {
    const x = s;
    return this[x(3608)] = e, this;
  }
}
class Gm extends ce {
  constructor(e) {
    super(e);
  }
  [s(3442)](e, x, t, i) {
    const n = s, a = this, r = new ye(this.manager);
    r[n(3121)](this.path), r.setRequestHeader(this[n(1283)]), r[n(2958)](this[n(1062)]), r[n(3442)](e, function(o) {
      const c = n;
      try {
        x(a[c(1359)](JSON[c(1359)](o)));
      } catch (h) {
        i ? i(h) : console.error(h), a.manager.itemError(e);
      }
    }, t, i);
  }
  [s(1359)](e) {
    const x = s, t = [];
    for (let i = 0; i < e[x(3105)]; i++) {
      const n = qi[x(1359)](e[i]);
      t[x(3156)](n);
    }
    return t;
  }
}
class Hm extends ce {
  constructor(e) {
    super(e);
  }
  load(e, x, t, i) {
    const n = s, a = this, r = [], o = new G2(), c = new ye(this[n(3235)]);
    c[n(3121)](this[n(597)]), c[n(2624)](n(1756)), c[n(590)](this[n(1283)]), c[n(2958)](a[n(1062)]);
    let h = 0;
    function f(u) {
      const l = n;
      c[l(3442)](e[u], function(_) {
        const p = l, m = a[p(1359)](_, !![]);
        r[u] = { width: m[p(1631)], height: m.height, format: m[p(448)], mipmaps: m.mipmaps }, h += 1, h === 6 && (m[p(1792)] === 1 && (o[p(991)] = Cx), o[p(450)] = r, o[p(448)] = m[p(448)], o.needsUpdate = !![], x && x(o));
      }, t, i);
    }
    if (Array[n(1609)](e))
      for (let u = 0, l = e[n(3105)]; u < l; ++u)
        f(u);
    else
      c[n(3442)](e, function(u) {
        const l = n, _ = a[l(1359)](u, !![]);
        if (_[l(487)]) {
          const p = _[l(2004)][l(3105)] / _[l(1792)];
          for (let m = 0; m < p; m++) {
            r[m] = { mipmaps: [] };
            for (let y = 0; y < _.mipmapCount; y++)
              r[m].mipmaps.push(_[l(2004)][m * _[l(1792)] + y]), r[m][l(448)] = _.format, r[m][l(1631)] = _[l(1631)], r[m][l(1674)] = _[l(1674)];
          }
          o.image = r;
        } else
          o.image[l(1631)] = _[l(1631)], o[l(450)][l(1674)] = _[l(1674)], o[l(2004)] = _[l(2004)];
        _[l(1792)] === 1 && (o[l(991)] = Cx), o[l(448)] = _[l(448)], o[l(3035)] = !![], x && x(o);
      }, t, i);
    return o;
  }
}
class Vn extends ce {
  constructor(e) {
    super(e);
  }
  [s(3442)](e, x, t, i) {
    const n = s;
    this[n(597)] !== void 0 && (e = this.path + e), e = this[n(3235)][n(765)](e);
    const a = this, r = Lt[n(3016)](e);
    if (r !== void 0)
      return a[n(3235)].itemStart(e), setTimeout(function() {
        const u = n;
        x && x(r), a.manager[u(3239)](e);
      }, 0), r;
    const o = Un(n(3315));
    function c() {
      const u = n;
      f(), Lt.add(e, this), x && x(this), a[u(3235)][u(3239)](e);
    }
    function h(u) {
      const l = n;
      f(), i && i(u), a[l(3235)].itemError(e), a[l(3235)].itemEnd(e);
    }
    function f() {
      const u = n;
      o.removeEventListener(u(3442), c, ![]), o[u(1079)](u(533), h, ![]);
    }
    return o[n(818)]("load", c, ![]), o[n(818)](n(533), h, ![]), e[n(3482)](0, 5) !== n(2199) && this[n(2825)] !== void 0 && (o[n(2825)] = this[n(2825)]), a[n(3235)][n(2663)](e), o[n(3095)] = e, o;
  }
}
class km extends ce {
  constructor(e) {
    super(e);
  }
  [s(3442)](e, x, t, i) {
    const n = s, a = new qn(), r = new Vn(this[n(3235)]);
    r[n(1086)](this[n(2825)]), r[n(3121)](this[n(597)]);
    let o = 0;
    function c(h) {
      r.load(e[h], function(f) {
        const u = c0;
        a.images[h] = f, o++, o === 6 && (a[u(3035)] = !![], x && x(a));
      }, void 0, i);
    }
    for (let h = 0; h < e[n(3105)]; ++h)
      c(h);
    return a;
  }
}
class J2 extends ce {
  constructor(e) {
    super(e);
  }
  load(e, x, t, i) {
    const n = s, a = this, r = new Bi(), o = new ye(this[n(3235)]);
    return o[n(2624)]("arraybuffer"), o[n(590)](this[n(1283)]), o[n(3121)](this[n(597)]), o[n(2958)](a.withCredentials), o[n(3442)](e, function(c) {
      const h = n, f = a.parse(c);
      f && (f[h(450)] !== void 0 ? r[h(450)] = f[h(450)] : f[h(2416)] !== void 0 && (r[h(450)][h(1631)] = f[h(1631)], r[h(450)].height = f[h(1674)], r.image[h(2416)] = f[h(2416)]), r[h(578)] = f.wrapS !== void 0 ? f[h(578)] : Zx, r[h(3221)] = f[h(3221)] !== void 0 ? f[h(3221)] : Zx, r[h(999)] = f[h(999)] !== void 0 ? f[h(999)] : Cx, r[h(991)] = f[h(991)] !== void 0 ? f[h(991)] : Cx, r[h(2447)] = f[h(2447)] !== void 0 ? f[h(2447)] : 1, f[h(523)] !== void 0 && (r[h(523)] = f[h(523)]), f.flipY !== void 0 && (r[h(1739)] = f[h(1739)]), f[h(448)] !== void 0 && (r[h(448)] = f[h(448)]), f[h(566)] !== void 0 && (r[h(566)] = f[h(566)]), f[h(2004)] !== void 0 && (r[h(2004)] = f[h(2004)], r.minFilter = qe), f[h(1792)] === 1 && (r[h(991)] = Cx), f[h(3632)] !== void 0 && (r.generateMipmaps = f[h(3632)]), r[h(3035)] = !![], x && x(r, f));
    }, t, i), r;
  }
}
class Ch extends ce {
  constructor(e) {
    super(e);
  }
  load(e, x, t, i) {
    const n = s, a = new Ux(), r = new Vn(this[n(3235)]);
    return r[n(1086)](this.crossOrigin), r[n(3121)](this[n(597)]), r[n(3442)](e, function(o) {
      const c = n;
      a[c(450)] = o, a.needsUpdate = !![], x !== void 0 && x(a);
    }, t, i), a;
  }
}
class Dt extends px {
  constructor(e, x = 1) {
    const t = s;
    super(), this.isLight = !![], this[t(566)] = t(2508), this[t(3282)] = new P0(e), this[t(1798)] = x;
  }
  [s(3387)]() {
  }
  [s(2875)](e, x) {
    const t = s;
    return super[t(2875)](e, x), this[t(3282)][t(2875)](e[t(3282)]), this[t(1798)] = e[t(1798)], this;
  }
  [s(3139)](e) {
    const x = s, t = super[x(3139)](e);
    return t[x(1413)][x(3282)] = this.color[x(2862)](), t[x(1413)].intensity = this[x(1798)], this[x(2035)] !== void 0 && (t[x(1413)][x(2035)] = this.groundColor.getHex()), this[x(1183)] !== void 0 && (t[x(1413)][x(1183)] = this[x(1183)]), this[x(2202)] !== void 0 && (t[x(1413)][x(2202)] = this[x(2202)]), this.decay !== void 0 && (t.object[x(3411)] = this[x(3411)]), this[x(2276)] !== void 0 && (t.object[x(2276)] = this[x(2276)]), this[x(2145)] !== void 0 && (t[x(1413)][x(2145)] = this[x(2145)].toJSON()), t;
  }
}
class Lh extends Dt {
  constructor(e, x, t) {
    const i = s;
    super(e, t), this[i(1332)] = !![], this[i(566)] = i(659), this[i(3571)][i(2875)](px[i(2560)]), this[i(1290)](), this.groundColor = new P0(x);
  }
  copy(e, x) {
    const t = s;
    return super[t(2875)](e, x), this[t(2035)].copy(e[t(2035)]), this;
  }
}
const ur = new ix(), cc = new z(), dc = new z();
class Q2 {
  constructor(e) {
    const x = s;
    this[x(2189)] = e, this[x(638)] = 0, this[x(3094)] = 0, this.radius = 1, this[x(1174)] = 8, this[x(1969)] = new d0(512, 512), this.map = null, this.mapPass = null, this[x(1067)] = new ix(), this[x(1012)] = !![], this[x(3035)] = ![], this._frustum = new Ma(), this._frameExtents = new d0(1, 1), this[x(3591)] = 1, this[x(954)] = [new Mx(0, 0, 1, 1)];
  }
  getViewportCount() {
    return this[s(3591)];
  }
  getFrustum() {
    return this[s(1416)];
  }
  updateMatrices(e) {
    const x = s, t = this[x(2189)], i = this.matrix;
    cc[x(683)](e[x(490)]), t[x(3571)][x(2875)](cc), dc[x(683)](e[x(671)][x(490)]), t[x(2577)](dc), t[x(3640)](), ur[x(3117)](t[x(1057)], t[x(1874)]), this[x(1416)][x(894)](ur), i.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), i[x(2246)](ur);
  }
  getViewport(e) {
    return this[s(954)][e];
  }
  getFrameExtents() {
    return this[s(2666)];
  }
  dispose() {
    const e = s;
    this.map && this[e(3644)][e(3387)](), this.mapPass && this.mapPass[e(3387)]();
  }
  [s(2875)](e) {
    const x = s;
    return this[x(2189)] = e[x(2189)][x(2272)](), this[x(638)] = e[x(638)], this[x(1232)] = e[x(1232)], this[x(1969)][x(2875)](e[x(1969)]), this;
  }
  [s(2272)]() {
    const e = s;
    return new this[e(2787)]().copy(this);
  }
  toJSON() {
    const e = s, x = {};
    return this.bias !== 0 && (x[e(638)] = this[e(638)]), this[e(3094)] !== 0 && (x.normalBias = this[e(3094)]), this[e(1232)] !== 1 && (x[e(1232)] = this[e(1232)]), (this[e(1969)].x !== 512 || this[e(1969)].y !== 512) && (x[e(1969)] = this.mapSize[e(1496)]()), x.camera = this.camera[e(3139)](![])[e(1413)], delete x.camera[e(1067)], x;
  }
}
class Vm extends Q2 {
  constructor() {
    const e = s;
    super(new Vx(50, 1, 0.5, 500)), this[e(896)] = !![], this.focus = 1;
  }
  [s(1110)](e) {
    const x = s, t = this.camera, i = Nn * 2 * e[x(2202)] * this[x(3594)], n = this[x(1969)].width / this[x(1969)].height, a = e.distance || t[x(3691)];
    (i !== t[x(3557)] || n !== t[x(2308)] || a !== t.far) && (t[x(3557)] = i, t[x(2308)] = n, t[x(3691)] = a, t[x(1701)]()), super[x(1110)](e);
  }
  [s(2875)](e) {
    const x = s;
    return super[x(2875)](e), this[x(3594)] = e[x(3594)], this;
  }
}
class xo extends Dt {
  constructor(e, x, t = 0, i = Math.PI / 3, n = 0, a = 2) {
    const r = s;
    super(e, x), this[r(2183)] = !![], this[r(566)] = "SpotLight", this.position[r(2875)](px[r(2560)]), this[r(1290)](), this[r(671)] = new px(), this[r(1183)] = t, this[r(2202)] = i, this.penumbra = n, this[r(3411)] = a, this.map = null, this.shadow = new Vm();
  }
  get [s(2973)]() {
    return this[s(1798)] * Math.PI;
  }
  set [s(2973)](e) {
    const x = s;
    this[x(1798)] = e / Math.PI;
  }
  [s(3387)]() {
    const e = s;
    this[e(2145)][e(3387)]();
  }
  [s(2875)](e, x) {
    const t = s;
    return super.copy(e, x), this[t(1183)] = e[t(1183)], this.angle = e.angle, this[t(2276)] = e.penumbra, this.decay = e[t(3411)], this[t(671)] = e[t(671)][t(2272)](), this[t(2145)] = e.shadow[t(2272)](), this;
  }
}
const hc = new ix(), gn = new z(), br = new z();
class Wm extends Q2 {
  constructor() {
    const e = s;
    super(new Vx(90, 1, 0.5, 500)), this[e(2955)] = !![], this[e(2666)] = new d0(4, 2), this[e(3591)] = 6, this[e(954)] = [new Mx(2, 1, 1, 1), new Mx(0, 1, 1, 1), new Mx(3, 1, 1, 1), new Mx(1, 1, 1, 1), new Mx(3, 0, 1, 1), new Mx(1, 0, 1, 1)], this[e(3302)] = [new z(1, 0, 0), new z(-1, 0, 0), new z(0, 0, 1), new z(0, 0, -1), new z(0, 1, 0), new z(0, -1, 0)], this[e(3458)] = [new z(0, 1, 0), new z(0, 1, 0), new z(0, 1, 0), new z(0, 1, 0), new z(0, 0, 1), new z(0, 0, -1)];
  }
  [s(1110)](e, x = 0) {
    const t = s, i = this[t(2189)], n = this[t(1067)], a = e.distance || i.far;
    a !== i.far && (i[t(3691)] = a, i[t(1701)]()), gn[t(683)](e[t(490)]), i.position[t(2875)](gn), br[t(2875)](i[t(3571)]), br[t(3026)](this[t(3302)][x]), i.up[t(2875)](this[t(3458)][x]), i[t(2577)](br), i[t(3640)](), n.makeTranslation(-gn.x, -gn.y, -gn.z), hc[t(3117)](i[t(1057)], i[t(1874)]), this._frustum[t(894)](hc);
  }
}
class Da extends Dt {
  constructor(e, x, t = 0, i = 2) {
    const n = s;
    super(e, x), this.isPointLight = !![], this[n(566)] = "PointLight", this[n(1183)] = t, this.decay = i, this[n(2145)] = new Wm();
  }
  get [s(2973)]() {
    return this[s(1798)] * 4 * Math.PI;
  }
  set [s(2973)](e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this[s(2145)].dispose();
  }
  [s(2875)](e, x) {
    const t = s;
    return super[t(2875)](e, x), this[t(1183)] = e.distance, this[t(3411)] = e[t(3411)], this[t(2145)] = e[t(2145)][t(2272)](), this;
  }
}
class jm extends Q2 {
  constructor() {
    const e = s;
    super(new Ji(-5, 5, 5, -5, 0.5, 500)), this[e(832)] = !![];
  }
}
class Oa extends Dt {
  constructor(e, x) {
    const t = s;
    super(e, x), this.isDirectionalLight = !![], this[t(566)] = t(1119), this.position[t(2875)](px[t(2560)]), this[t(1290)](), this[t(671)] = new px(), this[t(2145)] = new jm();
  }
  dispose() {
    const e = s;
    this[e(2145)][e(3387)]();
  }
  copy(e) {
    const x = s;
    return super[x(2875)](e), this[x(671)] = e[x(671)].clone(), this[x(2145)] = e[x(2145)][x(2272)](), this;
  }
}
class eo extends Dt {
  constructor(e, x) {
    const t = s;
    super(e, x), this[t(468)] = !![], this[t(566)] = t(3018);
  }
}
class Rh extends Dt {
  constructor(e, x, t = 10, i = 10) {
    const n = s;
    super(e, x), this[n(1027)] = !![], this[n(566)] = n(2472), this.width = t, this[n(1674)] = i;
  }
  get [s(2973)]() {
    const e = s;
    return this[e(1798)] * this[e(1631)] * this.height * Math.PI;
  }
  set power(e) {
    const x = s;
    this[x(1798)] = e / (this[x(1631)] * this.height * Math.PI);
  }
  [s(2875)](e) {
    const x = s;
    return super[x(2875)](e), this.width = e[x(1631)], this[x(1674)] = e[x(1674)], this;
  }
  toJSON(e) {
    const x = s, t = super.toJSON(e);
    return t.object.width = this[x(1631)], t[x(1413)][x(1674)] = this.height, t;
  }
}
class Ph {
  constructor() {
    const e = s;
    this[e(1380)] = !![], this.coefficients = [];
    for (let x = 0; x < 9; x++)
      this[e(2567)][e(3156)](new z());
  }
  [s(1260)](e) {
    const x = s;
    for (let t = 0; t < 9; t++)
      this[x(2567)][t].copy(e[t]);
    return this;
  }
  zero() {
    const e = s;
    for (let x = 0; x < 9; x++)
      this[e(2567)][x][e(1260)](0, 0, 0);
    return this;
  }
  [s(2405)](e, x) {
    const t = s, i = e.x, n = e.y, a = e.z, r = this[t(2567)];
    return x[t(2875)](r[0])[t(580)](0.282095), x.addScaledVector(r[1], 0.488603 * n), x.addScaledVector(r[2], 0.488603 * a), x.addScaledVector(r[3], 0.488603 * i), x[t(1990)](r[4], 1.092548 * (i * n)), x[t(1990)](r[5], 1.092548 * (n * a)), x.addScaledVector(r[6], 0.315392 * (3 * a * a - 1)), x[t(1990)](r[7], 1.092548 * (i * a)), x.addScaledVector(r[8], 0.546274 * (i * i - n * n)), x;
  }
  [s(2087)](e, x) {
    const t = s, i = e.x, n = e.y, a = e.z, r = this[t(2567)];
    return x[t(2875)](r[0])[t(580)](0.886227), x.addScaledVector(r[1], 2 * 0.511664 * n), x[t(1990)](r[2], 2 * 0.511664 * a), x[t(1990)](r[3], 2 * 0.511664 * i), x[t(1990)](r[4], 2 * 0.429043 * i * n), x[t(1990)](r[5], 2 * 0.429043 * n * a), x[t(1990)](r[6], 0.743125 * a * a - 0.247708), x[t(1990)](r[7], 2 * 0.429043 * i * a), x.addScaledVector(r[8], 0.429043 * (i * i - n * n)), x;
  }
  [s(3026)](e) {
    const x = s;
    for (let t = 0; t < 9; t++)
      this[x(2567)][t].add(e.coefficients[t]);
    return this;
  }
  [s(445)](e, x) {
    const t = s;
    for (let i = 0; i < 9; i++)
      this.coefficients[i][t(1990)](e[t(2567)][i], x);
    return this;
  }
  [s(2204)](e) {
    const x = s;
    for (let t = 0; t < 9; t++)
      this[x(2567)][t].multiplyScalar(e);
    return this;
  }
  lerp(e, x) {
    const t = s;
    for (let i = 0; i < 9; i++)
      this.coefficients[i][t(2841)](e.coefficients[i], x);
    return this;
  }
  [s(2828)](e) {
    const x = s;
    for (let t = 0; t < 9; t++)
      if (!this[x(2567)][t][x(2828)](e[x(2567)][t]))
        return ![];
    return !![];
  }
  [s(2875)](e) {
    const x = s;
    return this.set(e[x(2567)]);
  }
  [s(2272)]() {
    const e = s;
    return new this[e(2787)]()[e(2875)](this);
  }
  fromArray(e, x = 0) {
    const t = s, i = this[t(2567)];
    for (let n = 0; n < 9; n++)
      i[n][t(666)](e, x + n * 3);
    return this;
  }
  [s(1496)](e = [], x = 0) {
    const t = s, i = this[t(2567)];
    for (let n = 0; n < 9; n++)
      i[n].toArray(e, x + n * 3);
    return e;
  }
  static [s(1650)](e, x) {
    const t = e.x, i = e.y, n = e.z;
    x[0] = 0.282095, x[1] = 0.488603 * i, x[2] = 0.488603 * n, x[3] = 0.488603 * t, x[4] = 1.092548 * t * i, x[5] = 1.092548 * i * n, x[6] = 0.315392 * (3 * n * n - 1), x[7] = 1.092548 * t * n, x[8] = 0.546274 * (t * t - i * i);
  }
}
class Na extends Dt {
  constructor(e = new Ph(), x = 1) {
    super(void 0, x), this.isLightProbe = !![], this.sh = e;
  }
  [s(2875)](e) {
    const x = s;
    return super[x(2875)](e), this.sh[x(2875)](e.sh), this;
  }
  [s(3037)](e) {
    const x = s;
    return this[x(1798)] = e[x(1798)], this.sh[x(666)](e.sh), this;
  }
  toJSON(e) {
    const x = s, t = super[x(3139)](e);
    return t[x(1413)].sh = this.sh[x(1496)](), t;
  }
}
class Ua extends ce {
  constructor(e) {
    const x = s;
    super(e), this[x(1822)] = {};
  }
  load(e, x, t, i) {
    const n = s, a = this, r = new ye(a[n(3235)]);
    r[n(3121)](a[n(597)]), r[n(590)](a[n(1283)]), r[n(2958)](a[n(1062)]), r[n(3442)](e, function(o) {
      const c = n;
      try {
        x(a.parse(JSON[c(1359)](o)));
      } catch (h) {
        i ? i(h) : console[c(533)](h), a[c(3235)][c(829)](e);
      }
    }, t, i);
  }
  [s(1359)](e) {
    const x = s, t = this[x(1822)];
    function i(a) {
      const r = x;
      return t[a] === void 0 && console[r(3629)](r(773), a), t[a];
    }
    const n = Ua[x(642)](e[x(566)]);
    if (e[x(3104)] !== void 0 && (n[x(3104)] = e.uuid), e[x(3710)] !== void 0 && (n.name = e[x(3710)]), e.color !== void 0 && n.color !== void 0 && n.color[x(2548)](e.color), e.roughness !== void 0 && (n[x(771)] = e[x(771)]), e[x(1586)] !== void 0 && (n[x(1586)] = e[x(1586)]), e[x(1031)] !== void 0 && (n[x(1031)] = e.sheen), e[x(807)] !== void 0 && (n.sheenColor = new P0()[x(2548)](e[x(807)])), e[x(1915)] !== void 0 && (n[x(1915)] = e.sheenRoughness), e[x(1599)] !== void 0 && n[x(1599)] !== void 0 && n[x(1599)].setHex(e.emissive), e[x(881)] !== void 0 && n[x(881)] !== void 0 && n[x(881)][x(2548)](e.specular), e[x(1354)] !== void 0 && (n[x(1354)] = e[x(1354)]), e.specularColor !== void 0 && n.specularColor !== void 0 && n[x(3367)].setHex(e[x(3367)]), e[x(1274)] !== void 0 && (n[x(1274)] = e.shininess), e.clearcoat !== void 0 && (n[x(2317)] = e[x(2317)]), e[x(1163)] !== void 0 && (n.clearcoatRoughness = e[x(1163)]), e.iridescence !== void 0 && (n[x(3727)] = e[x(3727)]), e[x(477)] !== void 0 && (n[x(477)] = e[x(477)]), e[x(2845)] !== void 0 && (n[x(2845)] = e[x(2845)]), e.transmission !== void 0 && (n[x(2123)] = e[x(2123)]), e.thickness !== void 0 && (n[x(2908)] = e.thickness), e.attenuationDistance !== void 0 && (n[x(532)] = e.attenuationDistance), e[x(2786)] !== void 0 && n[x(2786)] !== void 0 && n[x(2786)][x(2548)](e[x(2786)]), e[x(3438)] !== void 0 && (n[x(3438)] = e[x(3438)]), e.flatShading !== void 0 && (n[x(1529)] = e[x(1529)]), e[x(3019)] !== void 0 && (n[x(3019)] = e[x(3019)]), e[x(2997)] !== void 0 && (n[x(2997)] = e[x(2997)]), e[x(679)] !== void 0 && (n[x(679)] = e[x(679)]), e[x(988)] !== void 0 && (n[x(988)] = e[x(988)]), e.opacity !== void 0 && (n[x(3746)] = e.opacity), e[x(1885)] !== void 0 && (n.transparent = e[x(1885)]), e.alphaTest !== void 0 && (n[x(3303)] = e[x(3303)]), e.depthTest !== void 0 && (n[x(770)] = e[x(770)]), e[x(3307)] !== void 0 && (n.depthWrite = e[x(3307)]), e[x(860)] !== void 0 && (n[x(860)] = e[x(860)]), e[x(2975)] !== void 0 && (n[x(2975)] = e[x(2975)]), e[x(2314)] !== void 0 && (n[x(2314)] = e[x(2314)]), e.stencilFunc !== void 0 && (n[x(650)] = e.stencilFunc), e[x(1532)] !== void 0 && (n.stencilRef = e[x(1532)]), e[x(2143)] !== void 0 && (n.stencilFuncMask = e[x(2143)]), e.stencilFail !== void 0 && (n[x(1832)] = e[x(1832)]), e.stencilZFail !== void 0 && (n.stencilZFail = e.stencilZFail), e[x(1850)] !== void 0 && (n[x(1850)] = e[x(1850)]), e[x(1124)] !== void 0 && (n[x(1124)] = e[x(1124)]), e[x(977)] !== void 0 && (n[x(977)] = e[x(977)]), e.wireframeLinecap !== void 0 && (n[x(2700)] = e[x(2700)]), e.wireframeLinejoin !== void 0 && (n.wireframeLinejoin = e[x(857)]), e[x(591)] !== void 0 && (n[x(591)] = e[x(591)]), e[x(2968)] !== 1 && (n.linewidth = e[x(2968)]), e.dashSize !== void 0 && (n[x(1831)] = e[x(1831)]), e[x(2514)] !== void 0 && (n[x(2514)] = e[x(2514)]), e[x(2204)] !== void 0 && (n[x(2204)] = e[x(2204)]), e[x(2455)] !== void 0 && (n[x(2455)] = e[x(2455)]), e[x(2914)] !== void 0 && (n[x(2914)] = e[x(2914)]), e[x(911)] !== void 0 && (n[x(911)] = e[x(911)]), e[x(2995)] !== void 0 && (n[x(2995)] = e[x(2995)]), e.alphaToCoverage !== void 0 && (n[x(447)] = e.alphaToCoverage), e[x(624)] !== void 0 && (n[x(624)] = e[x(624)]), e[x(2611)] !== void 0 && (n[x(2611)] = e[x(2611)]), e[x(2456)] !== void 0 && (n[x(2456)] = e[x(2456)]), e[x(626)] !== void 0 && (n[x(626)] = e[x(626)]), e[x(2066)] !== void 0 && (n[x(2066)] = e[x(2066)]), e[x(3530)] !== void 0 && (typeof e[x(3530)] === x(1407) ? n[x(3530)] = e[x(3530)] > 0 ? !![] : ![] : n[x(3530)] = e[x(3530)]), e[x(2833)] !== void 0)
      for (const a in e[x(2833)]) {
        const r = e[x(2833)][a];
        switch (n[x(2833)][a] = {}, r[x(566)]) {
          case "t":
            n.uniforms[a][x(1811)] = i(r[x(1811)]);
            break;
          case "c":
            n[x(2833)][a].value = new P0()[x(2548)](r[x(1811)]);
            break;
          case "v2":
            n.uniforms[a][x(1811)] = new d0()[x(666)](r[x(1811)]);
            break;
          case "v3":
            n[x(2833)][a][x(1811)] = new z()[x(666)](r[x(1811)]);
            break;
          case "v4":
            n[x(2833)][a][x(1811)] = new Mx().fromArray(r[x(1811)]);
            break;
          case "m3":
            n[x(2833)][a].value = new Kx()[x(666)](r[x(1811)]);
            break;
          case "m4":
            n[x(2833)][a][x(1811)] = new ix()[x(666)](r[x(1811)]);
            break;
          default:
            n.uniforms[a][x(1811)] = r[x(1811)];
        }
      }
    if (e[x(2264)] !== void 0 && (n.defines = e.defines), e[x(2377)] !== void 0 && (n[x(2377)] = e.vertexShader), e.fragmentShader !== void 0 && (n.fragmentShader = e[x(2489)]), e.glslVersion !== void 0 && (n[x(3770)] = e[x(3770)]), e[x(3323)] !== void 0)
      for (const a in e[x(3323)])
        n.extensions[a] = e[x(3323)][a];
    if (e.size !== void 0 && (n[x(3073)] = e.size), e[x(2907)] !== void 0 && (n[x(2907)] = e[x(2907)]), e[x(3644)] !== void 0 && (n[x(3644)] = i(e[x(3644)])), e[x(1247)] !== void 0 && (n[x(1247)] = i(e[x(1247)])), e[x(1453)] !== void 0 && (n[x(1453)] = i(e[x(1453)])), e[x(758)] !== void 0 && (n[x(758)] = i(e.bumpMap)), e[x(470)] !== void 0 && (n[x(470)] = e[x(470)]), e[x(811)] !== void 0 && (n[x(811)] = i(e[x(811)])), e.normalMapType !== void 0 && (n[x(920)] = e[x(920)]), e[x(2650)] !== void 0) {
      let a = e[x(2650)];
      Array[x(1609)](a) === ![] && (a = [a, a]), n[x(2650)] = new d0()[x(666)](a);
    }
    return e[x(629)] !== void 0 && (n[x(629)] = i(e[x(629)])), e[x(2693)] !== void 0 && (n[x(2693)] = e[x(2693)]), e[x(498)] !== void 0 && (n.displacementBias = e[x(498)]), e[x(3213)] !== void 0 && (n.roughnessMap = i(e.roughnessMap)), e[x(989)] !== void 0 && (n[x(989)] = i(e[x(989)])), e[x(2730)] !== void 0 && (n[x(2730)] = i(e[x(2730)])), e[x(1148)] !== void 0 && (n[x(1148)] = e[x(1148)]), e[x(3470)] !== void 0 && (n[x(3470)] = i(e[x(3470)])), e.specularIntensityMap !== void 0 && (n[x(1581)] = i(e.specularIntensityMap)), e[x(3637)] !== void 0 && (n[x(3637)] = i(e.specularColorMap)), e.envMap !== void 0 && (n[x(1477)] = i(e[x(1477)])), e[x(3176)] !== void 0 && (n[x(3176)] = e[x(3176)]), e[x(2531)] !== void 0 && (n.reflectivity = e.reflectivity), e[x(3759)] !== void 0 && (n.refractionRatio = e[x(3759)]), e[x(2399)] !== void 0 && (n.lightMap = i(e.lightMap)), e[x(623)] !== void 0 && (n.lightMapIntensity = e[x(623)]), e[x(2107)] !== void 0 && (n.aoMap = i(e[x(2107)])), e[x(2702)] !== void 0 && (n[x(2702)] = e[x(2702)]), e.gradientMap !== void 0 && (n[x(2767)] = i(e[x(2767)])), e[x(945)] !== void 0 && (n.clearcoatMap = i(e[x(945)])), e.clearcoatRoughnessMap !== void 0 && (n[x(1660)] = i(e[x(1660)])), e[x(3674)] !== void 0 && (n[x(3674)] = i(e[x(3674)])), e[x(1111)] !== void 0 && (n[x(1111)] = new d0()[x(666)](e[x(1111)])), e[x(2734)] !== void 0 && (n[x(2734)] = i(e[x(2734)])), e[x(3360)] !== void 0 && (n[x(3360)] = i(e[x(3360)])), e[x(2325)] !== void 0 && (n[x(2325)] = i(e[x(2325)])), e.thicknessMap !== void 0 && (n[x(1051)] = i(e.thicknessMap)), e.sheenColorMap !== void 0 && (n[x(2078)] = i(e[x(2078)])), e[x(3168)] !== void 0 && (n.sheenRoughnessMap = i(e[x(3168)])), n;
  }
  setTextures(e) {
    const x = s;
    return this[x(1822)] = e, this;
  }
  static createMaterialFromType(e) {
    const x = { ShadowMaterial: bh, SpriteMaterial: N2, RawShaderMaterial: ph, ShaderMaterial: ee, PointsMaterial: La, MeshPhysicalMaterial: ot, MeshStandardMaterial: os, MeshPhongMaterial: mh, MeshToonMaterial: gh, MeshNormalMaterial: _h, MeshLambertMaterial: vh, MeshDepthMaterial: I2, MeshDistanceMaterial: D2, MeshBasicMaterial: be, MeshMatcapMaterial: yh, LineDashedMaterial: wh, LineBasicMaterial: te, Material: jx };
    return new x[e]();
  }
}
class Yi {
  static [s(3042)](e) {
    const x = s;
    if (typeof TextDecoder < "u")
      return new TextDecoder().decode(e);
    let t = "";
    for (let i = 0, n = e[x(3105)]; i < n; i++)
      t += String[x(1919)](e[i]);
    try {
      return decodeURIComponent(escape(t));
    } catch {
      return t;
    }
  }
  static [s(3380)](e) {
    const x = e.lastIndexOf("/");
    return x === -1 ? "./" : e.slice(0, x + 1);
  }
  static [s(765)](e, x) {
    const t = s;
    return typeof e !== t(3335) || e === "" ? "" : (/^https?:\/\//i[t(1081)](x) && /^\//.test(e) && (x = x[t(1786)](/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i[t(1081)](e) || /^data:.*,.*$/i[t(1081)](e) || /^blob:.*$/i[t(1081)](e) ? e : x + e);
  }
}
class Ih extends ox {
  constructor() {
    const e = s;
    super(), this[e(548)] = !![], this[e(566)] = e(768), this[e(1758)] = 1 / 0;
  }
  [s(2875)](e) {
    const x = s;
    return super[x(2875)](e), this[x(1758)] = e[x(1758)], this;
  }
  toJSON() {
    const e = s, x = super.toJSON();
    return x[e(1758)] = this[e(1758)], x[e(548)] = !![], x;
  }
}
class Dh extends ce {
  constructor(e) {
    super(e);
  }
  [s(3442)](e, x, t, i) {
    const n = s, a = this, r = new ye(a[n(3235)]);
    r[n(3121)](a[n(597)]), r[n(590)](a.requestHeader), r.setWithCredentials(a[n(1062)]), r[n(3442)](e, function(o) {
      const c = n;
      try {
        x(a.parse(JSON[c(1359)](o)));
      } catch (h) {
        i ? i(h) : console.error(h), a[c(3235)][c(829)](e);
      }
    }, t, i);
  }
  parse(e) {
    const x = s, t = {}, i = {};
    function n(_, p) {
      const m = c0;
      if (t[p] !== void 0)
        return t[p];
      const y = _.interleavedBuffers, v = y[p], g = a(_, v[m(2770)]), b = Di(v[m(566)], g), M = new Yn(b, v[m(2479)]);
      return M[m(3104)] = v.uuid, t[p] = M, M;
    }
    function a(_, p) {
      const m = c0;
      if (i[p] !== void 0)
        return i[p];
      const y = _[m(2482)], v = y[p], g = new Uint32Array(v)[m(2770)];
      return i[p] = g, g;
    }
    const r = e.isInstancedBufferGeometry ? new Ih() : new ox(), o = e[x(2416)][x(3678)];
    if (o !== void 0) {
      const _ = Di(o[x(566)], o.array);
      r.setIndex(new gx(_, 1));
    }
    const c = e[x(2416)][x(3265)];
    for (const _ in c) {
      const p = c[_];
      let m;
      if (p[x(3154)]) {
        const y = n(e[x(2416)], p[x(2416)]);
        m = new Ct(y, p[x(3290)], p.offset, p.normalized);
      } else {
        const y = Di(p[x(566)], p.array), v = p[x(1242)] ? Wi : gx;
        m = new v(y, p[x(3290)], p[x(3320)]);
      }
      p[x(3710)] !== void 0 && (m[x(3710)] = p[x(3710)]), p[x(3067)] !== void 0 && m[x(3542)](p[x(3067)]), p[x(2270)] !== void 0 && (m[x(2270)][x(592)] = p[x(2270)][x(592)], m[x(2270)][x(1267)] = p[x(2270)].count), r[x(3599)](_, m);
    }
    const h = e[x(2416)][x(1034)];
    if (h)
      for (const _ in h) {
        const p = h[_], m = [];
        for (let y = 0, v = p[x(3105)]; y < v; y++) {
          const g = p[y];
          let b;
          if (g.isInterleavedBufferAttribute) {
            const M = n(e[x(2416)], g[x(2416)]);
            b = new Ct(M, g.itemSize, g[x(592)], g.normalized);
          } else {
            const M = Di(g[x(566)], g.array);
            b = new gx(M, g[x(3290)], g[x(3320)]);
          }
          g[x(3710)] !== void 0 && (b[x(3710)] = g[x(3710)]), m[x(3156)](b);
        }
        r[x(1034)][_] = m;
      }
    e.data.morphTargetsRelative && (r[x(3150)] = !![]);
    const u = e.data.groups || e[x(2416)][x(3040)] || e[x(2416)][x(649)];
    if (u !== void 0)
      for (let _ = 0, p = u[x(3105)]; _ !== p; ++_) {
        const m = u[_];
        r[x(3597)](m[x(1917)], m[x(1267)], m[x(2163)]);
      }
    const l = e.data.boundingSphere;
    if (l !== void 0) {
      const _ = new z();
      l[x(551)] !== void 0 && _[x(666)](l[x(551)]), r[x(3689)] = new Pt(_, l.radius);
    }
    return e[x(3710)] && (r.name = e[x(3710)]), e.userData && (r.userData = e[x(2066)]), r;
  }
}
class Xm extends ce {
  constructor(e) {
    super(e);
  }
  [s(3442)](e, x, t, i) {
    const n = s, a = this, r = this[n(597)] === "" ? Yi[n(3380)](e) : this[n(597)];
    this[n(1421)] = this[n(1421)] || r;
    const o = new ye(this[n(3235)]);
    o[n(3121)](this[n(597)]), o[n(590)](this[n(1283)]), o.setWithCredentials(this.withCredentials), o.load(e, function(c) {
      const h = n;
      let f = null;
      try {
        f = JSON[h(1359)](c);
      } catch (l) {
        i !== void 0 && i(l), console.error(h(3533) + e + ".", l[h(2622)]);
        return;
      }
      const u = f[h(2005)];
      if (u === void 0 || u[h(566)] === void 0 || u[h(566)][h(2050)]() === h(1353)) {
        i !== void 0 && i(new Error(h(2432) + e)), console[h(533)](h(2432) + e);
        return;
      }
      a.parse(f, x);
    }, t, i);
  }
  async loadAsync(e, x) {
    const t = s, i = this, n = this[t(597)] === "" ? Yi[t(3380)](e) : this[t(597)];
    this[t(1421)] = this.resourcePath || n;
    const a = new ye(this[t(3235)]);
    a[t(3121)](this[t(597)]), a[t(590)](this.requestHeader), a.setWithCredentials(this.withCredentials);
    const r = await a[t(2909)](e, x), o = JSON[t(1359)](r), c = o.metadata;
    if (c === void 0 || c.type === void 0 || c.type[t(2050)]() === "geometry")
      throw new Error("THREE.ObjectLoader: Can't load " + e);
    return await i[t(2384)](o);
  }
  [s(1359)](e, x) {
    const t = s, i = this.parseAnimations(e[t(1280)]), n = this.parseShapes(e[t(2002)]), a = this[t(993)](e.geometries, n), r = this[t(2378)](e[t(1090)], function() {
      x !== void 0 && x(h);
    }), o = this[t(2981)](e[t(1822)], r), c = this.parseMaterials(e[t(1876)], o), h = this.parseObject(e[t(1413)], a, c, o, i), f = this[t(1582)](e[t(741)], h);
    if (this[t(3397)](h, f), x !== void 0) {
      let u = ![];
      for (const l in r)
        if (r[l][t(2416)] instanceof HTMLImageElement) {
          u = !![];
          break;
        }
      u === ![] && x(h);
    }
    return h;
  }
  async parseAsync(e) {
    const x = s, t = this[x(1755)](e[x(1280)]), i = this[x(2297)](e[x(2002)]), n = this.parseGeometries(e[x(1986)], i), a = await this.parseImagesAsync(e.images), r = this[x(2981)](e[x(1822)], a), o = this[x(676)](e.materials, r), c = this[x(615)](e[x(1413)], n, o, r, t), h = this[x(1582)](e[x(741)], c);
    return this.bindSkeletons(c, h), c;
  }
  [s(2297)](e) {
    const x = s, t = {};
    if (e !== void 0)
      for (let i = 0, n = e[x(3105)]; i < n; i++) {
        const a = new ni()[x(3037)](e[i]);
        t[a[x(3104)]] = a;
      }
    return t;
  }
  [s(1582)](e, x) {
    const t = s, i = {}, n = {};
    if (x.traverse(function(a) {
      const r = c0;
      a.isBone && (n[a[r(3104)]] = a);
    }), e !== void 0)
      for (let a = 0, r = e[t(3105)]; a < r; a++) {
        const o = new Zn()[t(3037)](e[a], n);
        i[o[t(3104)]] = o;
      }
    return i;
  }
  [s(993)](e, x) {
    const t = s, i = {};
    if (e !== void 0) {
      const n = new Dh();
      for (let a = 0, r = e[t(3105)]; a < r; a++) {
        let o;
        const c = e[a];
        switch (c[t(566)]) {
          case t(2219):
          case t(768):
            o = n[t(1359)](c);
            break;
          default:
            c[t(566)] in oc ? o = oc[c[t(566)]][t(3037)](c, x) : console[t(3629)](t(2727) + c[t(566)] + '"');
        }
        o[t(3104)] = c[t(3104)], c[t(3710)] !== void 0 && (o[t(3710)] = c.name), c[t(2066)] !== void 0 && (o[t(2066)] = c[t(2066)]), i[c[t(3104)]] = o;
      }
    }
    return i;
  }
  parseMaterials(e, x) {
    const t = s, i = {}, n = {};
    if (e !== void 0) {
      const a = new Ua();
      a.setTextures(x);
      for (let r = 0, o = e.length; r < o; r++) {
        const c = e[r];
        i[c[t(3104)]] === void 0 && (i[c[t(3104)]] = a[t(1359)](c)), n[c[t(3104)]] = i[c[t(3104)]];
      }
    }
    return n;
  }
  parseAnimations(e) {
    const x = s, t = {};
    if (e !== void 0)
      for (let i = 0; i < e.length; i++) {
        const n = e[i], a = qi[x(1359)](n);
        t[a[x(3104)]] = a;
      }
    return t;
  }
  [s(2378)](e, x) {
    const t = s, i = this, n = {};
    let a;
    function r(c) {
      const h = c0;
      return i[h(3235)][h(2663)](c), a[h(3442)](c, function() {
        const f = h;
        i[f(3235)][f(3239)](c);
      }, void 0, function() {
        const f = h;
        i.manager[f(829)](c), i[f(3235)].itemEnd(c);
      });
    }
    function o(c) {
      const h = c0;
      if (typeof c === h(3335)) {
        const f = c, u = /^(\/\/)|([a-z]+:(\/\/)?)/i[h(1081)](f) ? f : i[h(1421)] + f;
        return r(u);
      } else
        return c[h(2416)] ? { data: Di(c[h(566)], c[h(2416)]), width: c[h(1631)], height: c[h(1674)] } : null;
    }
    if (e !== void 0 && e.length > 0) {
      const c = new $2(x);
      a = new Vn(c), a[t(1086)](this.crossOrigin);
      for (let h = 0, f = e[t(3105)]; h < f; h++) {
        const u = e[h], l = u[t(3385)];
        if (Array.isArray(l)) {
          const _ = [];
          for (let p = 0, m = l[t(3105)]; p < m; p++) {
            const y = l[p], v = o(y);
            v !== null && (v instanceof HTMLImageElement ? _[t(3156)](v) : _.push(new Bi(v[t(2416)], v[t(1631)], v.height)));
          }
          n[u.uuid] = new $t(_);
        } else {
          const _ = o(u.url);
          n[u[t(3104)]] = new $t(_);
        }
      }
    }
    return n;
  }
  async parseImagesAsync(e) {
    const x = s, t = this, i = {};
    let n;
    async function a(r) {
      const o = c0;
      if (typeof r === o(3335)) {
        const c = r, h = /^(\/\/)|([a-z]+:(\/\/)?)/i[o(1081)](c) ? c : t[o(1421)] + c;
        return await n[o(2909)](h);
      } else
        return r.data ? { data: Di(r.type, r[o(2416)]), width: r[o(1631)], height: r.height } : null;
    }
    if (e !== void 0 && e.length > 0) {
      n = new Vn(this[x(3235)]), n[x(1086)](this[x(2825)]);
      for (let r = 0, o = e[x(3105)]; r < o; r++) {
        const c = e[r], h = c[x(3385)];
        if (Array[x(1609)](h)) {
          const f = [];
          for (let u = 0, l = h[x(3105)]; u < l; u++) {
            const _ = h[u], p = await a(_);
            p !== null && (p instanceof HTMLImageElement ? f[x(3156)](p) : f[x(3156)](new Bi(p[x(2416)], p[x(1631)], p[x(1674)])));
          }
          i[c[x(3104)]] = new $t(f);
        } else {
          const f = await a(c[x(3385)]);
          i[c[x(3104)]] = new $t(f);
        }
      }
    }
    return i;
  }
  parseTextures(e, x) {
    const t = s;
    function i(a, r) {
      const o = c0;
      return typeof a === o(1407) ? a : (console.warn(o(2428), a), r[a]);
    }
    const n = {};
    if (e !== void 0)
      for (let a = 0, r = e[t(3105)]; a < r; a++) {
        const o = e[a];
        o[t(450)] === void 0 && console[t(3629)](t(1518), o[t(3104)]), x[o[t(450)]] === void 0 && console[t(3629)]("THREE.ObjectLoader: Undefined image", o[t(450)]);
        const c = x[o.image], h = c[t(2416)];
        let f;
        Array.isArray(h) ? (f = new qn(), h[t(3105)] === 6 && (f[t(3035)] = !![])) : (h && h.data ? f = new Bi() : f = new Ux(), h && (f[t(3035)] = !![])), f[t(796)] = c, f[t(3104)] = o[t(3104)], o[t(3710)] !== void 0 && (f.name = o[t(3710)]), o[t(667)] !== void 0 && (f[t(667)] = i(o[t(667)], qm)), o[t(592)] !== void 0 && f[t(592)].fromArray(o[t(592)]), o[t(2806)] !== void 0 && f[t(2806)][t(666)](o[t(2806)]), o.center !== void 0 && f[t(551)][t(666)](o[t(551)]), o[t(591)] !== void 0 && (f[t(591)] = o[t(591)]), o[t(3462)] !== void 0 && (f[t(578)] = i(o.wrap[0], fc), f[t(3221)] = i(o.wrap[1], fc)), o[t(448)] !== void 0 && (f[t(448)] = o[t(448)]), o.internalFormat !== void 0 && (f[t(2060)] = o[t(2060)]), o.type !== void 0 && (f.type = o.type), o.encoding !== void 0 && (f[t(523)] = o[t(523)]), o[t(991)] !== void 0 && (f.minFilter = i(o[t(991)], lc)), o[t(999)] !== void 0 && (f[t(999)] = i(o[t(999)], lc)), o[t(2447)] !== void 0 && (f[t(2447)] = o.anisotropy), o.flipY !== void 0 && (f[t(1739)] = o[t(1739)]), o.generateMipmaps !== void 0 && (f[t(3632)] = o[t(3632)]), o.premultiplyAlpha !== void 0 && (f[t(3003)] = o[t(3003)]), o[t(2275)] !== void 0 && (f[t(2275)] = o.unpackAlignment), o[t(2066)] !== void 0 && (f[t(2066)] = o[t(2066)]), n[o[t(3104)]] = f;
      }
    return n;
  }
  [s(615)](e, x, t, i, n) {
    const a = s;
    let r;
    function o(l) {
      const _ = c0;
      return x[l] === void 0 && console.warn(_(780), l), x[l];
    }
    function c(l) {
      const _ = c0;
      if (l !== void 0) {
        if (Array[_(1609)](l)) {
          const p = [];
          for (let m = 0, y = l[_(3105)]; m < y; m++) {
            const v = l[m];
            t[v] === void 0 && console[_(3629)]("THREE.ObjectLoader: Undefined material", v), p[_(3156)](t[v]);
          }
          return p;
        }
        return t[l] === void 0 && console[_(3629)]("THREE.ObjectLoader: Undefined material", l), t[l];
      }
    }
    function h(l) {
      const _ = c0;
      return i[l] === void 0 && console[_(3629)](_(2469), l), i[l];
    }
    let f, u;
    switch (e.type) {
      case a(3524):
        r = new O2(), e[a(2525)] !== void 0 && (Number[a(2274)](e[a(2525)]) ? r.background = new P0(e[a(2525)]) : r[a(2525)] = h(e.background)), e[a(3169)] !== void 0 && (r[a(3169)] = h(e[a(3169)])), e[a(3438)] !== void 0 && (e[a(3438)][a(566)] === a(2703) ? r[a(3438)] = new Aa(e[a(3438)].color, e[a(3438)][a(1448)], e[a(3438)][a(3691)]) : e[a(3438)].type === a(3233) && (r[a(3438)] = new Ea(e.fog.color, e.fog[a(2294)]))), e.backgroundBlurriness !== void 0 && (r[a(2812)] = e.backgroundBlurriness), e.backgroundIntensity !== void 0 && (r[a(2217)] = e.backgroundIntensity);
        break;
      case a(2012):
        r = new Vx(e[a(3557)], e.aspect, e[a(1448)], e.far), e[a(3594)] !== void 0 && (r[a(3594)] = e.focus), e[a(2477)] !== void 0 && (r[a(2477)] = e[a(2477)]), e.filmGauge !== void 0 && (r[a(2417)] = e.filmGauge), e[a(1690)] !== void 0 && (r[a(1690)] = e.filmOffset), e.view !== void 0 && (r[a(1206)] = Object[a(1188)]({}, e[a(1206)]));
        break;
      case "OrthographicCamera":
        r = new Ji(e[a(1640)], e[a(3383)], e[a(1376)], e[a(574)], e[a(1448)], e.far), e[a(2477)] !== void 0 && (r[a(2477)] = e[a(2477)]), e[a(1206)] !== void 0 && (r[a(1206)] = Object[a(1188)]({}, e.view));
        break;
      case "AmbientLight":
        r = new eo(e[a(3282)], e.intensity);
        break;
      case "DirectionalLight":
        r = new Oa(e[a(3282)], e[a(1798)]);
        break;
      case a(3496):
        r = new Da(e.color, e[a(1798)], e[a(1183)], e[a(3411)]);
        break;
      case "RectAreaLight":
        r = new Rh(e.color, e[a(1798)], e[a(1631)], e[a(1674)]);
        break;
      case a(2811):
        r = new xo(e.color, e[a(1798)], e[a(1183)], e.angle, e.penumbra, e[a(3411)]);
        break;
      case a(659):
        r = new Lh(e[a(3282)], e.groundColor, e[a(1798)]);
        break;
      case a(2910):
        r = new Na()[a(3037)](e);
        break;
      case a(647):
        f = o(e[a(1353)]), u = c(e[a(1870)]), r = new U2(f, u), e.bindMode !== void 0 && (r[a(1886)] = e[a(1886)]), e.bindMatrix !== void 0 && r[a(3363)][a(666)](e[a(3363)]), e[a(962)] !== void 0 && (r[a(962)] = e[a(962)]);
        break;
      case a(3191):
        f = o(e[a(1353)]), u = c(e[a(1870)]), r = new Wx(f, u);
        break;
      case a(2705):
        f = o(e[a(1353)]), u = c(e.material);
        const l = e[a(1267)], _ = e[a(1312)], p = e.instanceColor;
        r = new z2(f, u, l), r[a(1312)] = new Wi(new Float32Array(_[a(2712)]), 16), p !== void 0 && (r[a(752)] = new Wi(new Float32Array(p[a(2712)]), p[a(3290)]));
        break;
      case a(1122):
        r = new nh();
        break;
      case a(2250):
        r = new st(o(e[a(1353)]), c(e[a(1870)]));
        break;
      case a(3132):
        r = new B2(o(e.geometry), c(e[a(1870)]));
        break;
      case a(2083):
        r = new Ue(o(e.geometry), c(e.material));
        break;
      case a(1138):
      case a(2972):
        r = new F2(o(e[a(1353)]), c(e[a(1870)]));
        break;
      case a(1626):
        r = new ih(c(e.material));
        break;
      case a(3676):
        r = new nt();
        break;
      case a(2421):
        r = new Ca();
        break;
      default:
        r = new px();
    }
    if (r[a(3104)] = e[a(3104)], e[a(3710)] !== void 0 && (r[a(3710)] = e[a(3710)]), e[a(1067)] !== void 0 ? (r[a(1067)][a(666)](e.matrix), e[a(1126)] !== void 0 && (r[a(1126)] = e[a(1126)]), r.matrixAutoUpdate && r[a(1067)][a(3653)](r[a(3571)], r[a(3055)], r[a(2204)])) : (e[a(3571)] !== void 0 && r[a(3571)][a(666)](e.position), e[a(591)] !== void 0 && r[a(591)][a(666)](e[a(591)]), e.quaternion !== void 0 && r[a(3055)][a(666)](e[a(3055)]), e[a(2204)] !== void 0 && r[a(2204)][a(666)](e[a(2204)])), e[a(2721)] !== void 0 && (r[a(2721)] = e[a(2721)]), e[a(1719)] !== void 0 && (r.receiveShadow = e[a(1719)]), e.shadow && (e[a(2145)][a(638)] !== void 0 && (r[a(2145)].bias = e[a(2145)][a(638)]), e[a(2145)][a(3094)] !== void 0 && (r[a(2145)][a(3094)] = e.shadow.normalBias), e.shadow[a(1232)] !== void 0 && (r.shadow[a(1232)] = e[a(2145)][a(1232)]), e[a(2145)][a(1969)] !== void 0 && r[a(2145)][a(1969)][a(666)](e.shadow[a(1969)]), e[a(2145)][a(2189)] !== void 0 && (r[a(2145)][a(2189)] = this[a(615)](e[a(2145)][a(2189)]))), e[a(2456)] !== void 0 && (r.visible = e.visible), e.frustumCulled !== void 0 && (r[a(3431)] = e[a(3431)]), e.renderOrder !== void 0 && (r[a(704)] = e[a(704)]), e.userData !== void 0 && (r[a(2066)] = e[a(2066)]), e[a(479)] !== void 0 && (r.layers.mask = e.layers), e[a(3049)] !== void 0) {
      const l = e[a(3049)];
      for (let _ = 0; _ < l[a(3105)]; _++)
        r[a(3026)](this.parseObject(l[_], x, t, i, n));
    }
    if (e[a(1280)] !== void 0) {
      const l = e.animations;
      for (let _ = 0; _ < l[a(3105)]; _++) {
        const p = l[_];
        r[a(1280)][a(3156)](n[p]);
      }
    }
    if (e[a(566)] === "LOD") {
      e.autoUpdate !== void 0 && (r[a(1012)] = e[a(1012)]);
      const l = e[a(3494)];
      for (let _ = 0; _ < l[a(3105)]; _++) {
        const p = l[_], m = r[a(3621)](a(3104), p.object);
        m !== void 0 && r[a(1335)](m, p[a(1183)], p[a(2977)]);
      }
    }
    return r;
  }
  [s(3397)](e, x) {
    const t = s;
    Object[t(2070)](x)[t(3105)] !== 0 && e[t(2413)](function(i) {
      const n = t;
      if (i[n(1918)] === !![] && i.skeleton !== void 0) {
        const a = x[i[n(962)]];
        a === void 0 ? console.warn(n(3305), i[n(962)]) : i[n(3529)](a, i[n(3363)]);
      }
    });
  }
}
const qm = { UVMapping: ma, CubeReflectionMapping: St, CubeRefractionMapping: Tt, EquirectangularReflectionMapping: Gi, EquirectangularRefractionMapping: Pn, CubeUVReflectionMapping: Ki }, fc = { RepeatWrapping: Et, ClampToEdgeWrapping: Zx, MirroredRepeatWrapping: Hi }, lc = { NearestFilter: Bx, NearestMipmapNearestFilter: In, NearestMipmapLinearFilter: Ui, LinearFilter: Cx, LinearMipmapNearestFilter: ga, LinearMipmapLinearFilter: qe };
class Oh extends ce {
  constructor(e) {
    const x = s;
    super(e), this[x(2578)] = !![], typeof createImageBitmap === x(2011) && console[x(3629)](x(2625)), typeof fetch === x(2011) && console[x(3629)](x(2439)), this[x(3459)] = { premultiplyAlpha: "none" };
  }
  [s(640)](e) {
    const x = s;
    return this[x(3459)] = e, this;
  }
  [s(3442)](e, x, t, i) {
    const n = s;
    e === void 0 && (e = ""), this[n(597)] !== void 0 && (e = this[n(597)] + e), e = this[n(3235)].resolveURL(e);
    const a = this, r = Lt[n(3016)](e);
    if (r !== void 0)
      return a[n(3235)][n(2663)](e), setTimeout(function() {
        const c = n;
        x && x(r), a.manager[c(3239)](e);
      }, 0), r;
    const o = {};
    o[n(1678)] = this.crossOrigin === n(1598) ? n(1861) : n(1639), o[n(2056)] = this.requestHeader, fetch(e, o).then(function(c) {
      return c[n(1457)]();
    }).then(function(c) {
      const h = n;
      return createImageBitmap(c, Object.assign(a.options, { colorSpaceConversion: h(1227) }));
    })[n(1941)](function(c) {
      const h = n;
      Lt[h(3026)](e, c), x && x(c), a[h(3235)][h(3239)](e);
    })[n(747)](function(c) {
      const h = n;
      i && i(c), a[h(3235)][h(829)](e), a[h(3235)][h(3239)](e);
    }), a.manager[n(2663)](e);
  }
}
let Ws;
class to {
  static [s(3271)]() {
    const e = s;
    return Ws === void 0 && (Ws = new (window[e(1610)] || window[e(772)])()), Ws;
  }
  static [s(1993)](e) {
    Ws = e;
  }
}
class Ym extends ce {
  constructor(e) {
    super(e);
  }
  [s(3442)](e, x, t, i) {
    const n = s, a = this, r = new ye(this[n(3235)]);
    r[n(2624)](n(1756)), r[n(3121)](this.path), r[n(590)](this[n(1283)]), r[n(2958)](this[n(1062)]), r[n(3442)](e, function(o) {
      const c = n;
      try {
        const h = o[c(3482)](0);
        to[c(3271)]()[c(481)](h, function(u) {
          x(u);
        });
      } catch (h) {
        i ? i(h) : console[c(533)](h), a.manager[c(829)](e);
      }
    }, t, i);
  }
}
class Zm extends Na {
  constructor(e, x, t = 1) {
    const i = s;
    super(void 0, t), this[i(3719)] = !![];
    const n = new P0()[i(1260)](e), a = new P0()[i(1260)](x), r = new z(n.r, n.g, n.b), o = new z(a.r, a.g, a.b), c = Math[i(713)](Math.PI), h = c * Math[i(713)](0.75);
    this.sh[i(2567)][0][i(2875)](r)[i(3026)](o).multiplyScalar(c), this.sh[i(2567)][1][i(2875)](r)[i(1943)](o)[i(580)](h);
  }
}
class Km extends Na {
  constructor(e, x = 1) {
    const t = s;
    super(void 0, x), this[t(3468)] = !![];
    const i = new P0()[t(1260)](e);
    this.sh[t(2567)][0][t(1260)](i.r, i.g, i.b).multiplyScalar(2 * Math[t(713)](Math.PI));
  }
}
const uc = new ix(), bc = new ix(), zt = new ix();
class $m {
  constructor() {
    const e = s;
    this[e(566)] = e(3683), this[e(2308)] = 1, this[e(2694)] = 0.064, this[e(3007)] = new Vx(), this.cameraL[e(479)][e(3167)](1), this[e(3007)].matrixAutoUpdate = ![], this.cameraR = new Vx(), this.cameraR.layers[e(3167)](2), this.cameraR.matrixAutoUpdate = ![], this[e(1819)] = { focus: null, fov: null, aspect: null, near: null, far: null, zoom: null, eyeSep: null };
  }
  [s(3452)](e) {
    const x = s, t = this[x(1819)];
    if (t[x(3594)] !== e.focus || t[x(3557)] !== e[x(3557)] || t[x(2308)] !== e[x(2308)] * this.aspect || t[x(1448)] !== e[x(1448)] || t[x(3691)] !== e[x(3691)] || t[x(2477)] !== e[x(2477)] || t[x(2694)] !== this[x(2694)]) {
      t[x(3594)] = e[x(3594)], t.fov = e[x(3557)], t.aspect = e[x(2308)] * this.aspect, t[x(1448)] = e[x(1448)], t.far = e[x(3691)], t[x(2477)] = e.zoom, t[x(2694)] = this[x(2694)], zt.copy(e[x(1057)]);
      const n = t.eyeSep / 2, a = n * t[x(1448)] / t[x(3594)], r = t[x(1448)] * Math[x(745)](ii * t.fov * 0.5) / t[x(2477)];
      let o, c;
      bc[x(717)][12] = -n, uc[x(717)][12] = n, o = -r * t[x(2308)] + a, c = r * t[x(2308)] + a, zt[x(717)][0] = 2 * t[x(1448)] / (c - o), zt[x(717)][8] = (c + o) / (c - o), this[x(3007)][x(1057)][x(2875)](zt), o = -r * t[x(2308)] - a, c = r * t[x(2308)] - a, zt.elements[0] = 2 * t[x(1448)] / (c - o), zt[x(717)][8] = (c + o) / (c - o), this[x(2521)][x(1057)].copy(zt);
    }
    this[x(3007)][x(490)].copy(e[x(490)])[x(2246)](bc), this.cameraR[x(490)].copy(e[x(490)])[x(2246)](uc);
  }
}
class za {
  constructor(e = !![]) {
    const x = s;
    this[x(3412)] = e, this[x(1504)] = 0, this[x(3226)] = 0, this[x(1748)] = 0, this[x(1541)] = ![];
  }
  [s(1917)]() {
    const e = s;
    this[e(1504)] = pc(), this[e(3226)] = this[e(1504)], this.elapsedTime = 0, this.running = !![];
  }
  stop() {
    const e = s;
    this[e(916)](), this.running = ![], this[e(3412)] = ![];
  }
  [s(916)]() {
    const e = s;
    return this[e(2781)](), this[e(1748)];
  }
  [s(2781)]() {
    const e = s;
    let x = 0;
    if (this[e(3412)] && !this.running)
      return this[e(1917)](), 0;
    if (this.running) {
      const t = pc();
      x = (t - this.oldTime) / 1e3, this.oldTime = t, this[e(1748)] += x;
    }
    return x;
  }
}
function pc() {
  return (typeof performance > "u" ? Date : performance)[s(2599)]();
}
const Bt = new z(), mc = new $x(), Jm = new z(), Ft = new z();
class Qm extends px {
  constructor() {
    const e = s;
    super(), this.type = e(3238), this[e(1607)] = to[e(3271)](), this.gain = this[e(1607)][e(2538)](), this[e(3253)][e(2797)](this[e(1607)][e(616)]), this[e(3587)] = null, this[e(3708)] = 0, this._clock = new za();
  }
  [s(2154)]() {
    return this[s(3253)];
  }
  [s(827)]() {
    const e = s;
    return this[e(3587)] !== null && (this.gain[e(2496)](this[e(3587)]), this[e(3587)][e(2496)](this.context[e(616)]), this.gain[e(2797)](this.context[e(616)]), this[e(3587)] = null), this;
  }
  [s(3604)]() {
    return this[s(3587)];
  }
  [s(1793)](e) {
    const x = s;
    return this[x(3587)] !== null ? (this[x(3253)][x(2496)](this[x(3587)]), this[x(3587)][x(2496)](this[x(1607)][x(616)])) : this[x(3253)].disconnect(this[x(1607)][x(616)]), this.filter = e, this.gain[x(2797)](this[x(3587)]), this[x(3587)][x(2797)](this.context[x(616)]), this;
  }
  [s(3376)]() {
    const e = s;
    return this[e(3253)][e(3253)].value;
  }
  setMasterVolume(e) {
    const x = s;
    return this[x(3253)][x(3253)].setTargetAtTime(e, this[x(1607)][x(706)], 0.01), this;
  }
  [s(3640)](e) {
    const x = s;
    super[x(3640)](e);
    const t = this[x(1607)][x(939)], i = this.up;
    if (this[x(3708)] = this[x(627)][x(2781)](), this[x(490)][x(3653)](Bt, mc, Jm), Ft[x(1260)](0, 0, -1).applyQuaternion(mc), t.positionX) {
      const n = this.context[x(706)] + this[x(3708)];
      t.positionX[x(663)](Bt.x, n), t.positionY[x(663)](Bt.y, n), t[x(2864)][x(663)](Bt.z, n), t.forwardX[x(663)](Ft.x, n), t.forwardY[x(663)](Ft.y, n), t[x(2906)][x(663)](Ft.z, n), t.upX[x(663)](i.x, n), t[x(2398)][x(663)](i.y, n), t.upZ[x(663)](i.z, n);
    } else
      t[x(1350)](Bt.x, Bt.y, Bt.z), t[x(2032)](Ft.x, Ft.y, Ft.z, i.x, i.y, i.z);
  }
}
class Nh extends px {
  constructor(e) {
    const x = s;
    super(), this.type = "Audio", this[x(939)] = e, this[x(1607)] = e.context, this[x(3253)] = this[x(1607)][x(2538)](), this[x(3253)].connect(e[x(2154)]()), this[x(1536)] = ![], this.buffer = null, this.detune = 0, this[x(1106)] = ![], this[x(542)] = 0, this[x(3444)] = 0, this[x(592)] = 0, this[x(3403)] = void 0, this[x(3416)] = 1, this[x(2080)] = ![], this[x(3025)] = !![], this[x(796)] = null, this[x(2541)] = x(2295), this[x(1465)] = 0, this._progress = 0, this[x(2646)] = ![], this.filters = [];
  }
  [s(2073)]() {
    return this[s(3253)];
  }
  setNodeSource(e) {
    const x = s;
    return this.hasPlaybackControl = ![], this[x(2541)] = "audioNode", this[x(796)] = e, this[x(2797)](), this;
  }
  [s(3368)](e) {
    const x = s;
    return this.hasPlaybackControl = ![], this[x(2541)] = "mediaNode", this[x(796)] = this[x(1607)][x(1521)](e), this.connect(), this;
  }
  [s(3435)](e) {
    const x = s;
    return this[x(3025)] = ![], this.sourceType = "mediaStreamNode", this[x(796)] = this[x(1607)].createMediaStreamSource(e), this[x(2797)](), this;
  }
  [s(763)](e) {
    const x = s;
    return this[x(2770)] = e, this[x(2541)] = x(2770), this[x(1536)] && this.play(), this;
  }
  play(e = 0) {
    const x = s;
    if (this[x(2080)] === !![]) {
      console[x(3629)]("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this[x(3025)] === ![]) {
      console[x(3629)]("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this[x(1607)].currentTime + e;
    const t = this[x(1607)][x(1721)]();
    return t[x(2770)] = this.buffer, t.loop = this.loop, t[x(542)] = this.loopStart, t.loopEnd = this[x(3444)], t[x(1704)] = this.onEnded[x(3529)](this), t[x(1917)](this[x(1465)], this[x(2345)] + this[x(592)], this[x(3403)]), this[x(2080)] = !![], this[x(796)] = t, this.setDetune(this.detune), this[x(2498)](this[x(3416)]), this[x(2797)]();
  }
  [s(2842)]() {
    const e = s;
    if (this.hasPlaybackControl === ![]) {
      console[e(3629)]("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this[e(2080)] === !![] && (this._progress += Math[e(1803)](this[e(1607)][e(706)] - this[e(1465)], 0) * this[e(3416)], this[e(1106)] === !![] && (this[e(2345)] = this[e(2345)] % (this[e(3403)] || this.buffer[e(3403)])), this.source[e(914)](), this[e(796)][e(1704)] = null, this.isPlaying = ![]), this;
  }
  [s(914)]() {
    const e = s;
    if (this.hasPlaybackControl === ![]) {
      console.warn(e(2252));
      return;
    }
    return this[e(2345)] = 0, this[e(796)] !== null && (this[e(796)][e(914)](), this[e(796)][e(1704)] = null), this[e(2080)] = ![], this;
  }
  connect() {
    const e = s;
    if (this[e(3384)][e(3105)] > 0) {
      this[e(796)][e(2797)](this[e(3384)][0]);
      for (let x = 1, t = this[e(3384)][e(3105)]; x < t; x++)
        this[e(3384)][x - 1][e(2797)](this[e(3384)][x]);
      this[e(3384)][this.filters[e(3105)] - 1][e(2797)](this[e(2073)]());
    } else
      this[e(796)][e(2797)](this.getOutput());
    return this[e(2646)] = !![], this;
  }
  [s(2496)]() {
    const e = s;
    if (this[e(3384)][e(3105)] > 0) {
      this[e(796)][e(2496)](this.filters[0]);
      for (let x = 1, t = this[e(3384)].length; x < t; x++)
        this[e(3384)][x - 1][e(2496)](this.filters[x]);
      this.filters[this.filters[e(3105)] - 1].disconnect(this[e(2073)]());
    } else
      this[e(796)].disconnect(this[e(2073)]());
    return this[e(2646)] = ![], this;
  }
  getFilters() {
    return this[s(3384)];
  }
  [s(2332)](e) {
    const x = s;
    return e || (e = []), this[x(2646)] === !![] ? (this.disconnect(), this[x(3384)] = e[x(3482)](), this[x(2797)]()) : this.filters = e[x(3482)](), this;
  }
  [s(1908)](e) {
    const x = s;
    if (this[x(2894)] = e, this[x(796)][x(2894)] !== void 0)
      return this[x(2080)] === !![] && this[x(796)][x(2894)].setTargetAtTime(this.detune, this[x(1607)][x(706)], 0.01), this;
  }
  [s(1523)]() {
    return this[s(2894)];
  }
  getFilter() {
    return this[s(3733)]()[0];
  }
  [s(1793)](e) {
    return this[s(2332)](e ? [e] : []);
  }
  [s(2498)](e) {
    const x = s;
    if (this[x(3025)] === ![]) {
      console[x(3629)](x(2252));
      return;
    }
    return this.playbackRate = e, this[x(2080)] === !![] && this[x(796)].playbackRate[x(3616)](this[x(3416)], this.context[x(706)], 0.01), this;
  }
  [s(1121)]() {
    return this.playbackRate;
  }
  [s(1634)]() {
    const e = s;
    this[e(2080)] = ![];
  }
  getLoop() {
    const e = s;
    return this[e(3025)] === ![] ? (console[e(3629)](e(2252)), ![]) : this[e(1106)];
  }
  setLoop(e) {
    const x = s;
    if (this[x(3025)] === ![]) {
      console.warn(x(2252));
      return;
    }
    return this[x(1106)] = e, this[x(2080)] === !![] && (this[x(796)].loop = this.loop), this;
  }
  setLoopStart(e) {
    const x = s;
    return this[x(542)] = e, this;
  }
  [s(678)](e) {
    return this.loopEnd = e, this;
  }
  [s(1141)]() {
    const e = s;
    return this[e(3253)][e(3253)][e(1811)];
  }
  [s(2544)](e) {
    const x = s;
    return this[x(3253)].gain[x(3616)](e, this[x(1607)][x(706)], 0.01), this;
  }
}
const Gt = new z(), gc = new $x(), x1 = new z(), Ht = new z();
class e1 extends Nh {
  constructor(e) {
    const x = s;
    super(e), this.panner = this.context[x(1783)](), this[x(3070)].panningModel = x(1594), this[x(3070)][x(2797)](this[x(3253)]);
  }
  [s(2496)]() {
    const e = s;
    super[e(2496)](), this[e(3070)][e(2496)](this.gain);
  }
  getOutput() {
    return this[s(3070)];
  }
  [s(585)]() {
    const e = s;
    return this[e(3070)][e(2880)];
  }
  setRefDistance(e) {
    const x = s;
    return this[x(3070)][x(2880)] = e, this;
  }
  getRolloffFactor() {
    const e = s;
    return this[e(3070)][e(2279)];
  }
  setRolloffFactor(e) {
    const x = s;
    return this[x(3070)][x(2279)] = e, this;
  }
  [s(867)]() {
    return this.panner.distanceModel;
  }
  setDistanceModel(e) {
    const x = s;
    return this[x(3070)].distanceModel = e, this;
  }
  getMaxDistance() {
    const e = s;
    return this[e(3070)][e(2691)];
  }
  [s(1955)](e) {
    const x = s;
    return this[x(3070)].maxDistance = e, this;
  }
  [s(2326)](e, x, t) {
    const i = s;
    return this[i(3070)][i(582)] = e, this[i(3070)][i(1399)] = x, this[i(3070)][i(3803)] = t, this;
  }
  updateMatrixWorld(e) {
    const x = s;
    if (super[x(3640)](e), this.hasPlaybackControl === !![] && this.isPlaying === ![])
      return;
    this[x(490)][x(3653)](Gt, gc, x1), Ht[x(1260)](0, 0, 1)[x(718)](gc);
    const t = this[x(3070)];
    if (t[x(1672)]) {
      const i = this[x(1607)].currentTime + this[x(939)][x(3708)];
      t[x(1672)][x(663)](Gt.x, i), t.positionY[x(663)](Gt.y, i), t[x(2864)][x(663)](Gt.z, i), t[x(1263)][x(663)](Ht.x, i), t[x(1498)][x(663)](Ht.y, i), t[x(658)].linearRampToValueAtTime(Ht.z, i);
    } else
      t[x(1350)](Gt.x, Gt.y, Gt.z), t[x(2032)](Ht.x, Ht.y, Ht.z);
  }
}
class t1 {
  constructor(e, x = 2048) {
    const t = s;
    this[t(3586)] = e[t(1607)][t(2565)](), this.analyser[t(3306)] = x, this[t(2416)] = new Uint8Array(this[t(3586)][t(2607)]), e[t(2073)]().connect(this[t(3586)]);
  }
  [s(3245)]() {
    const e = s;
    return this[e(3586)][e(3195)](this[e(2416)]), this[e(2416)];
  }
  getAverageFrequency() {
    const e = s;
    let x = 0;
    const t = this.getFrequencyData();
    for (let i = 0; i < t[e(3105)]; i++)
      x += t[i];
    return x / t[e(3105)];
  }
}
class Uh {
  constructor(e, x, t) {
    const i = s;
    this[i(1558)] = e, this[i(814)] = t;
    let n, a, r;
    switch (x) {
      case i(3055):
        n = this[i(1860)], a = this._slerpAdditive, r = this[i(1098)], this[i(2770)] = new Float64Array(t * 6), this._workIndex = 5;
        break;
      case i(3335):
      case i(1318):
        n = this._select, a = this[i(1760)], r = this[i(2040)], this.buffer = new Array(t * 5);
        break;
      default:
        n = this[i(1775)], a = this[i(1531)], r = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(t * 5);
    }
    this[i(1720)] = n, this._mixBufferRegionAdditive = a, this[i(3748)] = r, this[i(1734)] = 3, this[i(2756)] = 4, this[i(2925)] = 0, this.cumulativeWeightAdditive = 0, this[i(3564)] = 0, this[i(3737)] = 0;
  }
  [s(1154)](e, x) {
    const t = s, i = this[t(2770)], n = this[t(814)], a = e * n + n;
    let r = this[t(2925)];
    if (r === 0) {
      for (let o = 0; o !== n; ++o)
        i[a + o] = i[o];
      r = x;
    } else {
      r += x;
      const o = x / r;
      this._mixBufferRegion(i, a, 0, o, n);
    }
    this.cumulativeWeight = r;
  }
  accumulateAdditive(e) {
    const x = s, t = this[x(2770)], i = this[x(814)], n = i * this[x(2756)];
    this[x(3582)] === 0 && this[x(3748)](), this[x(1257)](t, n, 0, e, i), this.cumulativeWeightAdditive += e;
  }
  apply(e) {
    const x = s, t = this.valueSize, i = this[x(2770)], n = e * t + t, a = this[x(2925)], r = this[x(3582)], o = this.binding;
    if (this.cumulativeWeight = 0, this[x(3582)] = 0, a < 1) {
      const c = t * this[x(1734)];
      this[x(1720)](i, n, c, 1 - a, t);
    }
    r > 0 && this[x(1257)](i, n, this._addIndex * t, 1, t);
    for (let c = t, h = t + t; c !== h; ++c)
      if (i[c] !== i[c + t]) {
        o[x(2249)](i, n);
        break;
      }
  }
  [s(1847)]() {
    const e = s, x = this.binding, t = this[e(2770)], i = this[e(814)], n = i * this[e(1734)];
    x[e(2015)](t, n);
    for (let a = i, r = n; a !== r; ++a)
      t[a] = t[n + a % i];
    this[e(3748)](), this[e(2925)] = 0, this.cumulativeWeightAdditive = 0;
  }
  [s(3190)]() {
    const e = s, x = this.valueSize * 3;
    this[e(1558)][e(2249)](this.buffer, x);
  }
  _setAdditiveIdentityNumeric() {
    const e = s, x = this[e(2756)] * this[e(814)], t = x + this.valueSize;
    for (let i = x; i < t; i++)
      this[e(2770)][i] = 0;
  }
  [s(1098)]() {
    const e = s;
    this[e(3729)](), this.buffer[this[e(2756)] * this.valueSize + 3] = 1;
  }
  [s(2040)]() {
    const e = s, x = this._origIndex * this[e(814)], t = this[e(2756)] * this[e(814)];
    for (let i = 0; i < this[e(814)]; i++)
      this[e(2770)][t + i] = this.buffer[x + i];
  }
  [s(1760)](e, x, t, i, n) {
    if (i >= 0.5)
      for (let a = 0; a !== n; ++a)
        e[x + a] = e[t + a];
  }
  [s(1860)](e, x, t, i) {
    $x[s(3555)](e, x, e, x, e, t, i);
  }
  [s(2388)](e, x, t, i, n) {
    const a = s, r = this[a(622)] * n;
    $x[a(2903)](e, r, e, x, e, t), $x[a(3555)](e, x, e, x, e, r, i);
  }
  [s(1775)](e, x, t, i, n) {
    const a = 1 - i;
    for (let r = 0; r !== n; ++r) {
      const o = x + r;
      e[o] = e[o] * a + e[t + r] * i;
    }
  }
  [s(1531)](e, x, t, i, n) {
    for (let a = 0; a !== n; ++a) {
      const r = x + a;
      e[r] = e[r] + e[t + a] * i;
    }
  }
}
const io = s(2753), i1 = new RegExp("[" + io + "]", "g"), no = "[^" + io + "]", n1 = "[^" + io[s(1786)]("\\.", "") + "]", s1 = /((?:WC+[\/:])*)/[s(796)].replace("WC", no), a1 = /(WCOD+)?/.source[s(1786)]("WCOD", n1), r1 = /(?:\.(WC+)(?:\[(.+)\])?)?/[s(796)][s(1786)]("WC", no), o1 = /\.(WC+)(?:\[(.+)\])?/[s(796)][s(1786)]("WC", no), c1 = new RegExp("^" + s1 + a1 + r1 + o1 + "$"), d1 = ["material", s(1876), s(3694), s(3644)];
class h1 {
  constructor(e, x, t) {
    const i = s, n = t || ux[i(1025)](x);
    this._targetGroup = e, this[i(3702)] = e[i(805)](x, n);
  }
  [s(2015)](e, x) {
    const t = s;
    this[t(3529)]();
    const i = this._targetGroup[t(1019)], n = this._bindings[i];
    n !== void 0 && n[t(2015)](e, x);
  }
  [s(2249)](e, x) {
    const t = s, i = this._bindings;
    for (let n = this[t(1439)][t(1019)], a = i[t(3105)]; n !== a; ++n)
      i[n][t(2249)](e, x);
  }
  [s(3529)]() {
    const e = s, x = this[e(3702)];
    for (let t = this[e(1439)].nCachedObjects_, i = x[e(3105)]; t !== i; ++t)
      x[t][e(3529)]();
  }
  [s(871)]() {
    const e = s, x = this[e(3702)];
    for (let t = this._targetGroup[e(1019)], i = x[e(3105)]; t !== i; ++t)
      x[t][e(871)]();
  }
}
class ux {
  constructor(e, x, t) {
    const i = s;
    this[i(597)] = x, this.parsedPath = t || ux[i(1025)](x), this.node = ux[i(3487)](e, this[i(2305)][i(1575)]), this[i(1814)] = e, this[i(2015)] = this[i(1326)], this[i(2249)] = this._setValue_unbound;
  }
  static create(e, x, t) {
    return e && e[s(3056)] ? new ux.Composite(e, x, t) : new ux(e, x, t);
  }
  static [s(3377)](e) {
    return e.replace(/\s/g, "_").replace(i1, "");
  }
  static [s(1025)](e) {
    const x = s, t = c1.exec(e);
    if (t === null)
      throw new Error(x(2944) + e);
    const i = { nodeName: t[2], objectName: t[3], objectIndex: t[4], propertyName: t[5], propertyIndex: t[6] }, n = i.nodeName && i.nodeName[x(2516)](".");
    if (n !== void 0 && n !== -1) {
      const a = i.nodeName[x(2597)](n + 1);
      d1[x(882)](a) !== -1 && (i[x(1575)] = i.nodeName[x(2597)](0, n), i[x(1872)] = a);
    }
    if (i.propertyName === null || i[x(963)].length === 0)
      throw new Error(x(3118) + e);
    return i;
  }
  static findNode(e, x) {
    const t = s;
    if (x === void 0 || x === "" || x === "." || x === -1 || x === e[t(3710)] || x === e[t(3104)])
      return e;
    if (e[t(962)]) {
      const i = e[t(962)][t(504)](x);
      if (i !== void 0)
        return i;
    }
    if (e.children) {
      const i = function(a) {
        const r = t;
        for (let o = 0; o < a[r(3105)]; o++) {
          const c = a[o];
          if (c[r(3710)] === x || c.uuid === x)
            return c;
          const h = i(c[r(3049)]);
          if (h)
            return h;
        }
        return null;
      }, n = i(e[t(3049)]);
      if (n)
        return n;
    }
    return null;
  }
  [s(2695)]() {
  }
  [s(3734)]() {
  }
  [s(2807)](e, x) {
    const t = s;
    e[x] = this[t(1526)][this[t(963)]];
  }
  [s(2922)](e, x) {
    const t = s, i = this.resolvedProperty;
    for (let n = 0, a = i[t(3105)]; n !== a; ++n)
      e[x++] = i[n];
  }
  [s(3650)](e, x) {
    const t = s;
    e[x] = this[t(674)][this[t(2951)]];
  }
  [s(3401)](e, x) {
    const t = s;
    this[t(674)][t(1496)](e, x);
  }
  [s(540)](e, x) {
    const t = s;
    this[t(1526)][this[t(963)]] = e[x];
  }
  [s(856)](e, x) {
    const t = s;
    this[t(1526)][this[t(963)]] = e[x], this[t(1526)][t(3035)] = !![];
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, x) {
    const t = s;
    this[t(1526)][this[t(963)]] = e[x], this.targetObject[t(1677)] = !![];
  }
  [s(456)](e, x) {
    const t = s, i = this[t(674)];
    for (let n = 0, a = i[t(3105)]; n !== a; ++n)
      i[n] = e[x++];
  }
  _setValue_array_setNeedsUpdate(e, x) {
    const t = s, i = this[t(674)];
    for (let n = 0, a = i[t(3105)]; n !== a; ++n)
      i[n] = e[x++];
    this[t(1526)][t(3035)] = !![];
  }
  [s(3436)](e, x) {
    const t = s, i = this[t(674)];
    for (let n = 0, a = i[t(3105)]; n !== a; ++n)
      i[n] = e[x++];
    this[t(1526)][t(1677)] = !![];
  }
  [s(3208)](e, x) {
    const t = s;
    this[t(674)][this[t(2951)]] = e[x];
  }
  [s(3034)](e, x) {
    const t = s;
    this.resolvedProperty[this[t(2951)]] = e[x], this[t(1526)][t(3035)] = !![];
  }
  [s(2957)](e, x) {
    const t = s;
    this[t(674)][this[t(2951)]] = e[x], this[t(1526)][t(1677)] = !![];
  }
  [s(3712)](e, x) {
    const t = s;
    this[t(674)][t(666)](e, x);
  }
  [s(2344)](e, x) {
    const t = s;
    this[t(674)][t(666)](e, x), this[t(1526)].needsUpdate = !![];
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, x) {
    const t = s;
    this.resolvedProperty[t(666)](e, x), this[t(1526)].matrixWorldNeedsUpdate = !![];
  }
  [s(1326)](e, x) {
    const t = s;
    this[t(3529)](), this[t(2015)](e, x);
  }
  _setValue_unbound(e, x) {
    const t = s;
    this[t(3529)](), this[t(2249)](e, x);
  }
  [s(3529)]() {
    const e = s;
    let x = this.node;
    const t = this.parsedPath, i = t[e(1872)], n = t[e(963)];
    let a = t[e(2951)];
    if (!x && (x = ux[e(3487)](this[e(1814)], t[e(1575)]), this[e(3792)] = x), this[e(2015)] = this._getValue_unavailable, this[e(2249)] = this[e(3734)], !x) {
      console[e(533)](e(610) + this[e(597)] + e(2871));
      return;
    }
    if (i) {
      let h = t.objectIndex;
      switch (i) {
        case e(1876):
          if (!x.material) {
            console[e(533)](e(1830), this);
            return;
          }
          if (!x.material[e(1876)]) {
            console[e(533)](e(2627), this);
            return;
          }
          x = x.material.materials;
          break;
        case e(3694):
          if (!x[e(962)]) {
            console.error(e(1533), this);
            return;
          }
          x = x[e(962)][e(3694)];
          for (let f = 0; f < x.length; f++)
            if (x[f].name === h) {
              h = f;
              break;
            }
          break;
        case e(3644):
          if ("map" in x) {
            x = x[e(3644)];
            break;
          }
          if (!x[e(1870)]) {
            console[e(533)](e(1830), this);
            return;
          }
          if (!x[e(1870)].map) {
            console[e(533)](e(3147), this);
            return;
          }
          x = x[e(1870)][e(3644)];
          break;
        default:
          if (x[i] === void 0) {
            console[e(533)]("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          x = x[i];
      }
      if (h !== void 0) {
        if (x[h] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, x);
          return;
        }
        x = x[h];
      }
    }
    const r = x[n];
    if (r === void 0) {
      const h = t.nodeName;
      console[e(533)]("THREE.PropertyBinding: Trying to update property for track: " + h + "." + n + e(2871), x);
      return;
    }
    let o = this[e(3501)][e(2824)];
    this[e(1526)] = x, x[e(3035)] !== void 0 ? o = this.Versioning[e(2927)] : x[e(1677)] !== void 0 && (o = this[e(3501)][e(1790)]);
    let c = this.BindingType.Direct;
    if (a !== void 0) {
      if (n === e(2072)) {
        if (!x[e(1353)]) {
          console.error(e(727), this);
          return;
        }
        if (!x.geometry[e(1034)]) {
          console[e(533)]("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
          return;
        }
        x[e(3398)][a] !== void 0 && (a = x.morphTargetDictionary[a]);
      }
      c = this[e(751)][e(2600)], this[e(674)] = r, this.propertyIndex = a;
    } else
      r[e(666)] !== void 0 && r[e(1496)] !== void 0 ? (c = this.BindingType[e(3283)], this[e(674)] = r) : Array.isArray(r) ? (c = this[e(751)][e(1140)], this.resolvedProperty = r) : this.propertyName = n;
    this[e(2015)] = this[e(2446)][c], this[e(2249)] = this[e(1103)][c][o];
  }
  [s(871)]() {
    const e = s;
    this[e(3792)] = null, this[e(2015)] = this[e(1326)], this.setValue = this[e(1939)];
  }
}
ux[s(2920)] = h1, ux[s(2028)].BindingType = { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, ux[s(2028)][s(3501)] = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, ux[s(2028)][s(2446)] = [ux[s(2028)][s(2807)], ux[s(2028)]._getValue_array, ux[s(2028)][s(3650)], ux[s(2028)][s(3401)]], ux[s(2028)][s(1103)] = [[ux[s(2028)][s(540)], ux[s(2028)]._setValue_direct_setNeedsUpdate, ux.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [ux.prototype[s(456)], ux.prototype._setValue_array_setNeedsUpdate, ux[s(2028)][s(3436)]], [ux[s(2028)][s(3208)], ux[s(2028)][s(3034)], ux.prototype[s(2957)]], [ux.prototype[s(3712)], ux[s(2028)][s(2344)], ux[s(2028)][s(2048)]]];
class f1 {
  constructor() {
    const e = s;
    this[e(3056)] = !![], this[e(3104)] = ve(), this[e(1635)] = Array.prototype[e(3482)][e(1656)](arguments), this[e(1019)] = 0;
    const x = {};
    this._indicesByUUID = x;
    for (let i = 0, n = arguments.length; i !== n; ++i)
      x[arguments[i].uuid] = i;
    this[e(463)] = [], this[e(1630)] = [], this._bindings = [], this._bindingsIndicesByPath = {};
    const t = this;
    this.stats = { objects: { get total() {
      const i = e;
      return t[i(1635)][i(3105)];
    }, get inUse() {
      const i = e;
      return this[i(1377)] - t[i(1019)];
    } }, get bindingsPerObject() {
      const i = e;
      return t[i(3702)][i(3105)];
    } };
  }
  [s(3026)]() {
    const e = s, x = this[e(1635)], t = this[e(3460)], i = this[e(463)], n = this._parsedPaths, a = this._bindings, r = a[e(3105)];
    let o, c = x.length, h = this.nCachedObjects_;
    for (let f = 0, u = arguments[e(3105)]; f !== u; ++f) {
      const l = arguments[f], _ = l[e(3104)];
      let p = t[_];
      if (p === void 0) {
        p = c++, t[_] = p, x[e(3156)](l);
        for (let m = 0, y = r; m !== y; ++m)
          a[m][e(3156)](new ux(l, i[m], n[m]));
      } else if (p < h) {
        o = x[p];
        const m = --h, y = x[m];
        t[y.uuid] = p, x[p] = y, t[_] = m, x[m] = l;
        for (let v = 0, g = r; v !== g; ++v) {
          const b = a[v], M = b[m];
          let A = b[p];
          b[p] = M, A === void 0 && (A = new ux(l, i[v], n[v])), b[m] = A;
        }
      } else
        x[p] !== o && console[e(533)](e(1269) + e(1239));
    }
    this[e(1019)] = h;
  }
  remove() {
    const e = s, x = this[e(1635)], t = this[e(3460)], i = this[e(3702)], n = i.length;
    let a = this[e(1019)];
    for (let r = 0, o = arguments.length; r !== o; ++r) {
      const c = arguments[r], h = c[e(3104)], f = t[h];
      if (f !== void 0 && f >= a) {
        const u = a++, l = x[u];
        t[l.uuid] = f, x[f] = l, t[h] = u, x[u] = c;
        for (let _ = 0, p = n; _ !== p; ++_) {
          const m = i[_], y = m[u], v = m[f];
          m[f] = y, m[u] = v;
        }
      }
    }
    this[e(1019)] = a;
  }
  [s(2843)]() {
    const e = s, x = this._objects, t = this[e(3460)], i = this._bindings, n = i[e(3105)];
    let a = this.nCachedObjects_, r = x[e(3105)];
    for (let o = 0, c = arguments[e(3105)]; o !== c; ++o) {
      const h = arguments[o], f = h[e(3104)], u = t[f];
      if (u !== void 0)
        if (delete t[f], u < a) {
          const l = --a, _ = x[l], p = --r, m = x[p];
          t[_.uuid] = u, x[u] = _, t[m.uuid] = l, x[l] = m, x[e(465)]();
          for (let y = 0, v = n; y !== v; ++y) {
            const g = i[y], b = g[l], M = g[p];
            g[u] = b, g[l] = M, g[e(465)]();
          }
        } else {
          const l = --r, _ = x[l];
          l > 0 && (t[_.uuid] = u), x[u] = _, x[e(465)]();
          for (let p = 0, m = n; p !== m; ++p) {
            const y = i[p];
            y[u] = y[l], y[e(465)]();
          }
        }
    }
    this[e(1019)] = a;
  }
  [s(805)](e, x) {
    const t = s, i = this[t(2810)];
    let n = i[e];
    const a = this[t(3702)];
    if (n !== void 0)
      return a[n];
    const r = this[t(463)], o = this[t(1630)], c = this[t(1635)], h = c[t(3105)], f = this[t(1019)], u = new Array(h);
    n = a[t(3105)], i[e] = n, r[t(3156)](e), o[t(3156)](x), a.push(u);
    for (let l = f, _ = c[t(3105)]; l !== _; ++l) {
      const p = c[l];
      u[l] = new ux(p, e, x);
    }
    return u;
  }
  unsubscribe_(e) {
    const x = s, t = this[x(2810)], i = t[e];
    if (i !== void 0) {
      const n = this[x(463)], a = this[x(1630)], r = this[x(3702)], o = r[x(3105)] - 1, c = r[o], h = e[o];
      t[h] = i, r[i] = c, r[x(465)](), a[i] = a[o], a.pop(), n[i] = n[o], n[x(465)]();
    }
  }
}
class l1 {
  constructor(e, x, t = null, i = x.blendMode) {
    const n = s;
    this[n(3294)] = e, this[n(1171)] = x, this[n(687)] = t, this.blendMode = i;
    const a = x[n(1823)], r = a[n(3105)], o = new Array(r), c = { endingStart: Zt, endingEnd: Zt };
    for (let h = 0; h !== r; ++h) {
      const f = a[h].createInterpolant(null);
      o[h] = f, f[n(3223)] = c;
    }
    this._interpolantSettings = c, this[n(1881)] = o, this[n(1298)] = new Array(r), this._cacheIndex = null, this._byClipCacheIndex = null, this[n(1217)] = null, this._weightInterpolant = null, this[n(1106)] = Id, this._loopCount = -1, this[n(2553)] = null, this[n(3082)] = 0, this[n(1663)] = 1, this[n(1799)] = 1, this[n(3492)] = 1, this._effectiveWeight = 1, this[n(3528)] = 1 / 0, this[n(3721)] = ![], this[n(2679)] = !![], this.clampWhenFinished = ![], this[n(2638)] = !![], this[n(2104)] = !![];
  }
  [s(1653)]() {
    const e = s;
    return this._mixer[e(2003)](this), this;
  }
  [s(914)]() {
    const e = s;
    return this[e(3294)][e(2643)](this), this[e(2007)]();
  }
  [s(2007)]() {
    const e = s;
    return this[e(3721)] = ![], this[e(2679)] = !![], this[e(3082)] = 0, this._loopCount = -1, this[e(2553)] = null, this.stopFading()[e(3421)]();
  }
  [s(3133)]() {
    const e = s;
    return this.enabled && !this[e(3721)] && this[e(1663)] !== 0 && this._startTime === null && this._mixer[e(652)](this);
  }
  [s(2387)]() {
    return this[s(3294)]._isActiveAction(this);
  }
  [s(2919)](e) {
    const x = s;
    return this[x(2553)] = e, this;
  }
  [s(2614)](e, x) {
    const t = s;
    return this[t(1106)] = e, this[t(3528)] = x, this;
  }
  [s(2882)](e) {
    const x = s;
    return this.weight = e, this[x(2688)] = this[x(2679)] ? e : 0, this[x(2891)]();
  }
  [s(1389)]() {
    return this._effectiveWeight;
  }
  fadeIn(e) {
    return this[s(919)](e, 0, 1);
  }
  fadeOut(e) {
    return this[s(919)](e, 1, 0);
  }
  [s(3030)](e, x, t) {
    const i = s;
    if (e[i(3595)](x), this[i(3342)](x), t) {
      const n = this._clip[i(3403)], a = e[i(1171)][i(3403)], r = a / n, o = n / a;
      e[i(1968)](1, r, x), this[i(1968)](o, 1, x);
    }
    return this;
  }
  [s(515)](e, x, t) {
    return e[s(3030)](this, x, t);
  }
  [s(2891)]() {
    const e = s, x = this[e(3311)];
    return x !== null && (this._weightInterpolant = null, this._mixer[e(439)](x)), this;
  }
  setEffectiveTimeScale(e) {
    const x = s;
    return this[x(1663)] = e, this[x(1799)] = this[x(3721)] ? 0 : e, this[x(3421)]();
  }
  [s(1460)]() {
    return this[s(1799)];
  }
  [s(1515)](e) {
    const x = s;
    return this.timeScale = this[x(1171)][x(3403)] / e, this[x(3421)]();
  }
  [s(557)](e) {
    const x = s;
    return this.time = e[x(3082)], this[x(1663)] = e[x(1663)], this[x(3421)]();
  }
  [s(3430)](e) {
    const x = s;
    return this[x(1968)](this[x(1799)], 0, e);
  }
  [s(1968)](e, x, t) {
    const i = s, n = this[i(3294)], a = n[i(3082)], r = this.timeScale;
    let o = this[i(1217)];
    o === null && (o = n[i(1291)](), this[i(1217)] = o);
    const c = o[i(1996)], h = o[i(3089)];
    return c[0] = a, c[1] = a + t, h[0] = e / r, h[1] = x / r, this;
  }
  [s(3421)]() {
    const e = s, x = this[e(1217)];
    return x !== null && (this[e(1217)] = null, this[e(3294)][e(439)](x)), this;
  }
  [s(3783)]() {
    return this[s(3294)];
  }
  [s(1127)]() {
    return this._clip;
  }
  getRoot() {
    const e = s;
    return this[e(687)] || this._mixer[e(1909)];
  }
  [s(2821)](e, x, t, i) {
    const n = s;
    if (!this[n(2679)]) {
      this[n(3355)](e);
      return;
    }
    const a = this[n(2553)];
    if (a !== null) {
      const c = (e - a) * t;
      c < 0 || t === 0 ? x = 0 : (this[n(2553)] = null, x = t * c);
    }
    x *= this[n(2433)](e);
    const r = this._updateTime(x), o = this[n(3355)](e);
    if (o > 0) {
      const c = this[n(1881)], h = this[n(1298)];
      switch (this[n(3620)]) {
        case M2:
          for (let f = 0, u = c[n(3105)]; f !== u; ++f)
            c[f][n(3752)](r), h[f][n(3115)](o);
          break;
        case _a:
        default:
          for (let f = 0, u = c[n(3105)]; f !== u; ++f)
            c[f].evaluate(r), h[f][n(1154)](i, o);
      }
    }
  }
  [s(3355)](e) {
    const x = s;
    let t = 0;
    if (this[x(2679)]) {
      t = this[x(3492)];
      const i = this._weightInterpolant;
      if (i !== null) {
        const n = i[x(3752)](e)[0];
        t *= n, e > i.parameterPositions[1] && (this[x(2891)](), n === 0 && (this[x(2679)] = ![]));
      }
    }
    return this[x(2688)] = t, t;
  }
  _updateTimeScale(e) {
    const x = s;
    let t = 0;
    if (!this.paused) {
      t = this.timeScale;
      const i = this[x(1217)];
      if (i !== null) {
        const n = i[x(3752)](e)[0];
        t *= n, e > i[x(1996)][1] && (this[x(3421)](), t === 0 ? this[x(3721)] = !![] : this[x(1663)] = t);
      }
    }
    return this[x(1799)] = t, t;
  }
  [s(1731)](e) {
    const x = s, t = this[x(1171)][x(3403)], i = this[x(1106)];
    let n = this.time + e, a = this._loopCount;
    const r = i === Dd;
    if (e === 0)
      return a === -1 ? n : r && (a & 1) === 1 ? t - n : n;
    if (i === w2) {
      a === -1 && (this[x(2879)] = 0, this[x(3749)](!![], !![], ![]));
      x: {
        if (n >= t)
          n = t;
        else if (n < 0)
          n = 0;
        else {
          this[x(3082)] = n;
          break x;
        }
        this[x(1765)] ? this.paused = !![] : this[x(2679)] = ![], this.time = n, this[x(3294)].dispatchEvent({ type: x(3457), action: this, direction: e < 0 ? -1 : 1 });
      }
    } else {
      if (a === -1 && (e >= 0 ? (a = 0, this[x(3749)](!![], this[x(3528)] === 0, r)) : this[x(3749)](this.repetitions === 0, !![], r)), n >= t || n < 0) {
        const o = Math[x(2697)](n / t);
        n -= t * o, a += Math[x(3373)](o);
        const c = this[x(3528)] - a;
        if (c <= 0)
          this[x(1765)] ? this.paused = !![] : this[x(2679)] = ![], n = e > 0 ? t : 0, this.time = n, this[x(3294)][x(3157)]({ type: "finished", action: this, direction: e > 0 ? 1 : -1 });
        else {
          if (c === 1) {
            const h = e < 0;
            this[x(3749)](h, !h, r);
          } else
            this[x(3749)](![], ![], r);
          this[x(2879)] = a, this[x(3082)] = n, this[x(3294)][x(3157)]({ type: x(1106), action: this, loopDelta: o });
        }
      } else
        this[x(3082)] = n;
      if (r && (a & 1) === 1)
        return t - n;
    }
    return n;
  }
  [s(3749)](e, x, t) {
    const i = s, n = this._interpolantSettings;
    t ? (n[i(573)] = Kt, n[i(2989)] = Kt) : (e ? n[i(573)] = this.zeroSlopeAtStart ? Kt : Zt : n[i(573)] = Dn, x ? n[i(2989)] = this.zeroSlopeAtEnd ? Kt : Zt : n[i(2989)] = Dn);
  }
  [s(919)](e, x, t) {
    const i = s, n = this[i(3294)], a = n[i(3082)];
    let r = this[i(3311)];
    r === null && (r = n[i(1291)](), this[i(3311)] = r);
    const o = r[i(1996)], c = r.sampleValues;
    return o[0] = a, c[0] = x, o[1] = a + e, c[1] = t, this;
  }
}
const u1 = new Float32Array(1);
class zh extends Ye {
  constructor(e) {
    const x = s;
    super(), this._root = e, this._initMemoryManager(), this[x(1446)] = 0, this[x(3082)] = 0, this[x(1663)] = 1;
  }
  [s(729)](e, x) {
    const t = s, i = e[t(687)] || this[t(1909)], n = e[t(1171)][t(1823)], a = n[t(3105)], r = e._propertyBindings, o = e._interpolants, c = i.uuid, h = this._bindingsByRootAndName;
    let f = h[c];
    f === void 0 && (f = {}, h[c] = f);
    for (let u = 0; u !== a; ++u) {
      const l = n[u], _ = l[t(3710)];
      let p = f[_];
      if (p !== void 0)
        ++p[t(3737)], r[u] = p;
      else {
        if (p = r[u], p !== void 0) {
          p._cacheIndex === null && (++p[t(3737)], this[t(631)](p, c, _));
          continue;
        }
        const m = x && x._propertyBindings[u].binding[t(2305)];
        p = new Uh(ux.create(i, _, m), l.ValueTypeName, l.getValueSize()), ++p.referenceCount, this._addInactiveBinding(p, c, _), r[u] = p;
      }
      o[u][t(902)] = p[t(2770)];
    }
  }
  [s(2003)](e) {
    const x = s;
    if (!this._isActiveAction(e)) {
      if (e[x(3008)] === null) {
        const i = (e._localRoot || this[x(1909)])[x(3104)], n = e._clip[x(3104)], a = this._actionsByClip[n];
        this[x(729)](e, a && a[x(1891)][0]), this[x(789)](e, n, i);
      }
      const t = e[x(1298)];
      for (let i = 0, n = t[x(3105)]; i !== n; ++i) {
        const a = t[i];
        a[x(3564)]++ === 0 && (this[x(3065)](a), a[x(1847)]());
      }
      this[x(3584)](e);
    }
  }
  _deactivateAction(e) {
    const x = s;
    if (this[x(652)](e)) {
      const t = e[x(1298)];
      for (let i = 0, n = t.length; i !== n; ++i) {
        const a = t[i];
        --a[x(3564)] === 0 && (a[x(3190)](), this[x(2215)](a));
      }
      this[x(2774)](e);
    }
  }
  [s(3429)]() {
    const e = s;
    this._actions = [], this._nActiveActions = 0, this[e(1539)] = {}, this[e(3702)] = [], this[e(2242)] = 0, this[e(3197)] = {}, this._controlInterpolants = [], this[e(918)] = 0;
    const x = this;
    this[e(1754)] = { actions: { get total() {
      const t = e;
      return x[t(3010)][t(3105)];
    }, get inUse() {
      return x[e(1805)];
    } }, bindings: { get total() {
      return x[e(3702)].length;
    }, get inUse() {
      return x[e(2242)];
    } }, controlInterpolants: { get total() {
      const t = e;
      return x._controlInterpolants[t(3105)];
    }, get inUse() {
      return x[e(918)];
    } } };
  }
  _isActiveAction(e) {
    const x = s, t = e[x(3008)];
    return t !== null && t < this[x(1805)];
  }
  [s(789)](e, x, t) {
    const i = s, n = this[i(3010)], a = this[i(1539)];
    let r = a[x];
    if (r === void 0)
      r = { knownActions: [e], actionByRoot: {} }, e[i(1964)] = 0, a[x] = r;
    else {
      const o = r[i(1891)];
      e[i(1964)] = o.length, o[i(3156)](e);
    }
    e[i(3008)] = n[i(3105)], n[i(3156)](e), r[i(1612)][t] = e;
  }
  [s(1403)](e) {
    const x = s, t = this[x(3010)], i = t[t[x(3105)] - 1], n = e[x(3008)];
    i._cacheIndex = n, t[n] = i, t[x(465)](), e[x(3008)] = null;
    const a = e[x(1171)].uuid, r = this[x(1539)], o = r[a], c = o[x(1891)], h = c[c[x(3105)] - 1], f = e[x(1964)];
    h._byClipCacheIndex = f, c[f] = h, c[x(465)](), e._byClipCacheIndex = null;
    const u = o.actionByRoot, l = (e[x(687)] || this[x(1909)])[x(3104)];
    delete u[l], c[x(3105)] === 0 && delete r[a], this[x(2950)](e);
  }
  [s(2950)](e) {
    const x = s, t = e._propertyBindings;
    for (let i = 0, n = t.length; i !== n; ++i) {
      const a = t[i];
      --a[x(3737)] === 0 && this._removeInactiveBinding(a);
    }
  }
  _lendAction(e) {
    const x = s, t = this._actions, i = e[x(3008)], n = this[x(1805)]++, a = t[n];
    e._cacheIndex = n, t[n] = e, a[x(3008)] = i, t[i] = a;
  }
  _takeBackAction(e) {
    const x = s, t = this[x(3010)], i = e[x(3008)], n = --this[x(1805)], a = t[n];
    e._cacheIndex = n, t[n] = e, a[x(3008)] = i, t[i] = a;
  }
  _addInactiveBinding(e, x, t) {
    const i = s, n = this._bindingsByRootAndName, a = this._bindings;
    let r = n[x];
    r === void 0 && (r = {}, n[x] = r), r[t] = e, e._cacheIndex = a[i(3105)], a[i(3156)](e);
  }
  _removeInactiveBinding(e) {
    const x = s, t = this[x(3702)], i = e[x(1558)], n = i[x(1814)].uuid, a = i[x(597)], r = this[x(3197)], o = r[n], c = t[t[x(3105)] - 1], h = e[x(3008)];
    c[x(3008)] = h, t[h] = c, t[x(465)](), delete o[a], Object.keys(o)[x(3105)] === 0 && delete r[n];
  }
  [s(3065)](e) {
    const x = s, t = this[x(3702)], i = e[x(3008)], n = this[x(2242)]++, a = t[n];
    e._cacheIndex = n, t[n] = e, a[x(3008)] = i, t[i] = a;
  }
  [s(2215)](e) {
    const x = s, t = this[x(3702)], i = e[x(3008)], n = --this._nActiveBindings, a = t[n];
    e[x(3008)] = n, t[n] = e, a[x(3008)] = i, t[i] = a;
  }
  [s(1291)]() {
    const e = s, x = this._controlInterpolants, t = this[e(918)]++;
    let i = x[t];
    return i === void 0 && (i = new Z2(new Float32Array(2), new Float32Array(2), 1, u1), i[e(1146)] = t, x[t] = i), i;
  }
  [s(439)](e) {
    const x = s, t = this[x(3547)], i = e[x(1146)], n = --this[x(918)], a = t[n];
    e[x(1146)] = n, t[n] = e, a[x(1146)] = i, t[i] = a;
  }
  [s(2321)](e, x, t) {
    const i = s, n = x || this[i(1909)], a = n[i(3104)];
    let r = typeof e === i(3335) ? qi.findByName(n, e) : e;
    const o = r !== null ? r.uuid : e, c = this[i(1539)][o];
    let h = null;
    if (t === void 0 && (r !== null ? t = r.blendMode : t = _a), c !== void 0) {
      const u = c[i(1612)][a];
      if (u !== void 0 && u[i(3620)] === t)
        return u;
      h = c[i(1891)][0], r === null && (r = h[i(1171)]);
    }
    if (r === null)
      return null;
    const f = new l1(this, r, x, t);
    return this._bindAction(f, h), this[i(789)](f, o, a), f;
  }
  [s(2390)](e, x) {
    const t = s, i = x || this[t(1909)], n = i[t(3104)], a = typeof e === t(3335) ? qi[t(3292)](i, e) : e, r = a ? a.uuid : e, o = this[t(1539)][r];
    return o !== void 0 && o[t(1612)][n] || null;
  }
  stopAllAction() {
    const e = s, x = this[e(3010)], t = this[e(1805)];
    for (let i = t - 1; i >= 0; --i)
      x[i].stop();
    return this;
  }
  update(e) {
    const x = s;
    e *= this[x(1663)];
    const t = this._actions, i = this[x(1805)], n = this.time += e, a = Math[x(2966)](e), r = this[x(1446)] ^= 1;
    for (let h = 0; h !== i; ++h)
      t[h][x(2821)](n, e, a, r);
    const o = this[x(3702)], c = this[x(2242)];
    for (let h = 0; h !== c; ++h)
      o[h][x(555)](r);
    return this;
  }
  [s(2187)](e) {
    const x = s;
    this.time = 0;
    for (let t = 0; t < this[x(3010)][x(3105)]; t++)
      this._actions[t].time = 0;
    return this[x(3452)](e);
  }
  [s(1949)]() {
    return this[s(1909)];
  }
  uncacheClip(e) {
    const x = s, t = this[x(3010)], i = e.uuid, n = this[x(1539)], a = n[i];
    if (a !== void 0) {
      const r = a.knownActions;
      for (let o = 0, c = r[x(3105)]; o !== c; ++o) {
        const h = r[o];
        this[x(2643)](h);
        const f = h[x(3008)], u = t[t[x(3105)] - 1];
        h[x(3008)] = null, h._byClipCacheIndex = null, u._cacheIndex = f, t[f] = u, t[x(465)](), this[x(2950)](h);
      }
      delete n[i];
    }
  }
  [s(1806)](e) {
    const x = s, t = e[x(3104)], i = this[x(1539)];
    for (const r in i) {
      const o = i[r][x(1612)], c = o[t];
      c !== void 0 && (this[x(2643)](c), this[x(1403)](c));
    }
    const n = this[x(3197)], a = n[t];
    if (a !== void 0)
      for (const r in a) {
        const o = a[r];
        o[x(3190)](), this[x(3357)](o);
      }
  }
  [s(3465)](e, x) {
    const t = s, i = this[t(2390)](e, x);
    i !== null && (this._deactivateAction(i), this[t(1403)](i));
  }
}
class so {
  constructor(e) {
    const x = s;
    this[x(1811)] = e;
  }
  [s(2272)]() {
    const e = s;
    return new so(this[e(1811)][e(2272)] === void 0 ? this.value : this.value.clone());
  }
}
let b1 = 0;
class p1 extends Ye {
  constructor() {
    const e = s;
    super(), this[e(469)] = !![], Object[e(1117)](this, "id", { value: b1++ }), this.name = "", this.usage = On, this[e(2833)] = [];
  }
  [s(3026)](e) {
    const x = s;
    return this[x(2833)][x(3156)](e), this;
  }
  [s(3137)](e) {
    const x = s, t = this[x(2833)].indexOf(e);
    return t !== -1 && this[x(2833)][x(1733)](t, 1), this;
  }
  [s(3454)](e) {
    const x = s;
    return this[x(3710)] = e, this;
  }
  [s(3542)](e) {
    const x = s;
    return this[x(3067)] = e, this;
  }
  dispose() {
    const e = s;
    return this[e(3157)]({ type: e(3387) }), this;
  }
  [s(2875)](e) {
    const x = s;
    this.name = e.name, this[x(3067)] = e[x(3067)];
    const t = e[x(2833)];
    this[x(2833)].length = 0;
    for (let i = 0, n = t[x(3105)]; i < n; i++)
      this[x(2833)][x(3156)](t[i][x(2272)]());
    return this;
  }
  [s(2272)]() {
    const e = s;
    return new this.constructor()[e(2875)](this);
  }
}
class m1 extends Yn {
  constructor(e, x, t = 1) {
    const i = s;
    super(e, x), this.isInstancedInterleavedBuffer = !![], this[i(656)] = t;
  }
  copy(e) {
    const x = s;
    return super.copy(e), this[x(656)] = e[x(656)], this;
  }
  [s(2272)](e) {
    const x = s, t = super[x(2272)](e);
    return t[x(656)] = this[x(656)], t;
  }
  [s(3139)](e) {
    const x = s, t = super[x(3139)](e);
    return t[x(886)] = !![], t[x(656)] = this[x(656)], t;
  }
}
class g1 {
  constructor(e, x, t, i, n) {
    const a = s;
    this[a(2025)] = !![], this[a(3710)] = "", this[a(2770)] = e, this[a(566)] = x, this[a(3290)] = t, this.elementSize = i, this.count = n, this[a(2185)] = 0;
  }
  set needsUpdate(e) {
    e === !![] && this.version++;
  }
  [s(763)](e) {
    const x = s;
    return this[x(2770)] = e, this;
  }
  [s(1494)](e, x) {
    const t = s;
    return this[t(566)] = e, this[t(2873)] = x, this;
  }
  setItemSize(e) {
    const x = s;
    return this[x(3290)] = e, this;
  }
  [s(2346)](e) {
    const x = s;
    return this[x(1267)] = e, this;
  }
}
class Bh {
  constructor(e, x, t = 0, i = 1 / 0) {
    const n = s;
    this[n(1096)] = new jn(e, x), this[n(1448)] = t, this[n(3691)] = i, this[n(2189)] = null, this.layers = new ya(), this[n(517)] = { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} };
  }
  [s(1260)](e, x) {
    const t = s;
    this.ray[t(1260)](e, x);
  }
  [s(3128)](e, x) {
    const t = s;
    x[t(2480)] ? (this[t(1096)][t(1149)][t(683)](x[t(490)]), this[t(1096)].direction.set(e.x, e.y, 0.5)[t(1603)](x).sub(this[t(1096)][t(1149)])[t(608)](), this.camera = x) : x.isOrthographicCamera ? (this[t(1096)][t(1149)].set(e.x, e.y, (x[t(1448)] + x[t(3691)]) / (x[t(1448)] - x[t(3691)]))[t(1603)](x), this[t(1096)][t(2847)].set(0, 0, -1)[t(1657)](x.matrixWorld), this[t(2189)] = x) : console[t(533)](t(2348) + x[t(566)]);
  }
  [s(2580)](e, x = !![], t = []) {
    const i = s;
    return d2(e, this, t, x), t[i(614)](_c), t;
  }
  [s(2206)](e, x = !![], t = []) {
    const i = s;
    for (let n = 0, a = e[i(3105)]; n < a; n++)
      d2(e[n], this, t, x);
    return t.sort(_c), t;
  }
}
function _c(d, e) {
  const x = s;
  return d.distance - e[x(1183)];
}
function d2(d, e, x, t) {
  const i = s;
  if (d[i(479)][i(1081)](e.layers) && d[i(2803)](e, x), t === !![]) {
    const n = d[i(3049)];
    for (let a = 0, r = n[i(3105)]; a < r; a++)
      d2(n[a], e, x, !![]);
  }
}
class _1 {
  constructor(e = 1, x = 0, t = 0) {
    const i = s;
    return this[i(1232)] = e, this[i(1088)] = x, this[i(2949)] = t, this;
  }
  [s(1260)](e, x, t) {
    const i = s;
    return this[i(1232)] = e, this[i(1088)] = x, this[i(2949)] = t, this;
  }
  [s(2875)](e) {
    const x = s;
    return this[x(1232)] = e[x(1232)], this[x(1088)] = e[x(1088)], this[x(2949)] = e.theta, this;
  }
  [s(2184)]() {
    const e = s, x = 1e-6;
    return this[e(1088)] = Math.max(x, Math[e(3085)](Math.PI - x, this[e(1088)])), this;
  }
  [s(3506)](e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  [s(1187)](e, x, t) {
    const i = s;
    return this[i(1232)] = Math[i(713)](e * e + x * x + t * t), this[i(1232)] === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math[i(1722)](e, t), this.phi = Math[i(2765)](Gx(x / this[i(1232)], -1, 1))), this;
  }
  clone() {
    const e = s;
    return new this[e(2787)]()[e(2875)](this);
  }
}
class v1 {
  constructor(e = 1, x = 0, t = 0) {
    const i = s;
    return this[i(1232)] = e, this[i(2949)] = x, this.y = t, this;
  }
  [s(1260)](e, x, t) {
    const i = s;
    return this[i(1232)] = e, this[i(2949)] = x, this.y = t, this;
  }
  [s(2875)](e) {
    const x = s;
    return this[x(1232)] = e.radius, this[x(2949)] = e[x(2949)], this.y = e.y, this;
  }
  setFromVector3(e) {
    return this[s(1187)](e.x, e.y, e.z);
  }
  [s(1187)](e, x, t) {
    const i = s;
    return this[i(1232)] = Math[i(713)](e * e + t * t), this.theta = Math[i(1722)](e, t), this.y = x, this;
  }
  [s(2272)]() {
    const e = s;
    return new this[e(2787)]()[e(2875)](this);
  }
}
const vc = new d0();
class y1 {
  constructor(e = new d0(1 / 0, 1 / 0), x = new d0(-1 / 0, -1 / 0)) {
    const t = s;
    this[t(3615)] = !![], this[t(3085)] = e, this[t(1803)] = x;
  }
  set(e, x) {
    const t = s;
    return this[t(3085)][t(2875)](e), this[t(1803)][t(2875)](x), this;
  }
  [s(646)](e) {
    const x = s;
    this[x(2561)]();
    for (let t = 0, i = e[x(3105)]; t < i; t++)
      this[x(1186)](e[t]);
    return this;
  }
  setFromCenterAndSize(e, x) {
    const t = s, i = vc[t(2875)](x)[t(580)](0.5);
    return this[t(3085)][t(2875)](e)[t(1943)](i), this[t(1803)].copy(e)[t(3026)](i), this;
  }
  [s(2272)]() {
    const e = s;
    return new this[e(2787)]()[e(2875)](this);
  }
  copy(e) {
    const x = s;
    return this.min[x(2875)](e[x(3085)]), this.max.copy(e.max), this;
  }
  [s(2561)]() {
    const e = s;
    return this[e(3085)].x = this.min.y = 1 / 0, this[e(1803)].x = this.max.y = -1 / 0, this;
  }
  [s(2253)]() {
    const e = s;
    return this.max.x < this.min.x || this[e(1803)].y < this[e(3085)].y;
  }
  getCenter(e) {
    const x = s;
    return this.isEmpty() ? e[x(1260)](0, 0) : e.addVectors(this[x(3085)], this[x(1803)])[x(580)](0.5);
  }
  getSize(e) {
    const x = s;
    return this[x(2253)]() ? e[x(1260)](0, 0) : e[x(1061)](this[x(1803)], this[x(3085)]);
  }
  [s(1186)](e) {
    const x = s;
    return this[x(3085)][x(3085)](e), this[x(1803)][x(1803)](e), this;
  }
  expandByVector(e) {
    const x = s;
    return this[x(3085)].sub(e), this[x(1803)].add(e), this;
  }
  [s(3249)](e) {
    const x = s;
    return this[x(3085)][x(3688)](-e), this.max.addScalar(e), this;
  }
  [s(3014)](e) {
    const x = s;
    return e.x < this[x(3085)].x || e.x > this[x(1803)].x || e.y < this.min.y || e.y > this.max.y ? ![] : !![];
  }
  [s(812)](e) {
    const x = s;
    return this[x(3085)].x <= e[x(3085)].x && e[x(1803)].x <= this.max.x && this[x(3085)].y <= e[x(3085)].y && e.max.y <= this.max.y;
  }
  [s(3516)](e, x) {
    const t = s;
    return x[t(1260)]((e.x - this[t(3085)].x) / (this[t(1803)].x - this[t(3085)].x), (e.y - this[t(3085)].y) / (this[t(1803)].y - this[t(3085)].y));
  }
  intersectsBox(e) {
    const x = s;
    return e[x(1803)].x < this[x(3085)].x || e.min.x > this[x(1803)].x || e[x(1803)].y < this[x(3085)].y || e[x(3085)].y > this[x(1803)].y ? ![] : !![];
  }
  [s(3081)](e, x) {
    const t = s;
    return x[t(2875)](e)[t(3135)](this[t(3085)], this[t(1803)]);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, vc).distanceTo(e);
  }
  intersect(e) {
    const x = s;
    return this[x(3085)].max(e[x(3085)]), this[x(1803)][x(3085)](e[x(1803)]), this.isEmpty() && this[x(2561)](), this;
  }
  [s(1618)](e) {
    const x = s;
    return this[x(3085)][x(3085)](e.min), this[x(1803)][x(1803)](e.max), this;
  }
  [s(864)](e) {
    const x = s;
    return this[x(3085)][x(3026)](e), this[x(1803)][x(3026)](e), this;
  }
  [s(2828)](e) {
    const x = s;
    return e[x(3085)].equals(this[x(3085)]) && e[x(1803)].equals(this[x(1803)]);
  }
}
const yc = new z(), js = new z();
class w1 {
  constructor(e = new z(), x = new z()) {
    const t = s;
    this[t(1917)] = e, this[t(1475)] = x;
  }
  [s(1260)](e, x) {
    const t = s;
    return this[t(1917)][t(2875)](e), this[t(1475)][t(2875)](x), this;
  }
  [s(2875)](e) {
    const x = s;
    return this.start[x(2875)](e[x(1917)]), this[x(1475)][x(2875)](e.end), this;
  }
  [s(1658)](e) {
    const x = s;
    return e.addVectors(this[x(1917)], this.end)[x(580)](0.5);
  }
  [s(530)](e) {
    const x = s;
    return e[x(1061)](this[x(1475)], this[x(1917)]);
  }
  [s(1470)]() {
    const e = s;
    return this[e(1917)][e(1679)](this.end);
  }
  distance() {
    const e = s;
    return this[e(1917)][e(3570)](this.end);
  }
  at(e, x) {
    const t = s;
    return this.delta(x)[t(580)](e)[t(3026)](this.start);
  }
  [s(2796)](e, x) {
    const t = s;
    yc[t(1061)](e, this[t(1917)]), js[t(1061)](this[t(1475)], this[t(1917)]);
    const i = js.dot(js);
    let a = js[t(1454)](yc) / i;
    return x && (a = Gx(a, 0, 1)), a;
  }
  [s(2559)](e, x, t) {
    const i = s, n = this[i(2796)](e, x);
    return this[i(530)](t)[i(580)](n)[i(3026)](this.start);
  }
  [s(2442)](e) {
    const x = s;
    return this.start[x(2442)](e), this[x(1475)].applyMatrix4(e), this;
  }
  [s(2828)](e) {
    const x = s;
    return e[x(1917)][x(2828)](this[x(1917)]) && e[x(1475)][x(2828)](this.end);
  }
  [s(2272)]() {
    const e = s;
    return new this[e(2787)]().copy(this);
  }
}
const wc = new z();
class M1 extends px {
  constructor(e, x) {
    const t = s;
    super(), this[t(1288)] = e, this[t(1067)] = e[t(490)], this[t(1126)] = ![], this[t(3282)] = x, this[t(566)] = t(2779);
    const i = new ox(), n = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
    for (let r = 0, o = 1, c = 32; r < c; r++, o++) {
      const h = r / c * Math.PI * 2, f = o / c * Math.PI * 2;
      n[t(3156)](Math[t(2063)](h), Math.sin(h), 1, Math.cos(f), Math[t(2626)](f), 1);
    }
    i[t(3599)]("position", new W0(n, 3));
    const a = new te({ fog: ![], toneMapped: ![] });
    this[t(3017)] = new Ue(i, a), this[t(3026)](this[t(3017)]), this[t(3452)]();
  }
  [s(3387)]() {
    const e = s;
    this[e(3017)][e(1353)].dispose(), this[e(3017)][e(1870)][e(3387)]();
  }
  update() {
    const e = s;
    this[e(1288)][e(630)](!![], ![]), this.light[e(671)][e(630)](!![], ![]);
    const x = this.light.distance ? this[e(1288)][e(1183)] : 1e3, t = x * Math[e(745)](this[e(1288)][e(2202)]);
    this.cone[e(2204)].set(t, t, x), wc.setFromMatrixPosition(this[e(1288)][e(671)].matrixWorld), this[e(3017)][e(2577)](wc), this[e(3282)] !== void 0 ? this[e(3017)][e(1870)][e(3282)].set(this.color) : this[e(3017)][e(1870)][e(3282)].copy(this[e(1288)][e(3282)]);
  }
}
const lt = new z(), Xs = new ix(), pr = new ix();
class S1 extends Ue {
  constructor(e) {
    const x = s, t = Fh(e), i = new ox(), n = [], a = [], r = new P0(0, 0, 1), o = new P0(0, 1, 0);
    for (let h = 0; h < t[x(3105)]; h++) {
      const f = t[h];
      f[x(3562)] && f[x(3562)][x(1317)] && (n[x(3156)](0, 0, 0), n.push(0, 0, 0), a[x(3156)](r.r, r.g, r.b), a[x(3156)](o.r, o.g, o.b));
    }
    i[x(3599)](x(3571), new W0(n, 3)), i.setAttribute(x(3282), new W0(a, 3));
    const c = new te({ vertexColors: !![], depthTest: ![], depthWrite: ![], toneMapped: ![], transparent: !![] });
    super(i, c), this[x(3410)] = !![], this[x(566)] = "SkeletonHelper", this[x(2065)] = e, this.bones = t, this[x(1067)] = e[x(490)], this[x(1126)] = ![];
  }
  [s(3640)](e) {
    const x = s, t = this[x(3694)], i = this[x(1353)], n = i[x(1740)](x(3571));
    pr[x(2875)](this.root.matrixWorld).invert();
    for (let a = 0, r = 0; a < t[x(3105)]; a++) {
      const o = t[a];
      o.parent && o.parent.isBone && (Xs[x(3117)](pr, o[x(490)]), lt[x(683)](Xs), n[x(1167)](r, lt.x, lt.y, lt.z), Xs.multiplyMatrices(pr, o[x(3562)][x(490)]), lt.setFromMatrixPosition(Xs), n[x(1167)](r + 1, lt.x, lt.y, lt.z), r += 2);
    }
    i[x(1740)](x(3571)).needsUpdate = !![], super.updateMatrixWorld(e);
  }
  [s(3387)]() {
    const e = s;
    this[e(1353)][e(3387)](), this[e(1870)][e(3387)]();
  }
}
function Fh(d) {
  const e = s, x = [];
  d[e(1317)] === !![] && x.push(d);
  for (let t = 0; t < d.children[e(3105)]; t++)
    x[e(3156)][e(555)](x, Fh(d.children[t]));
  return x;
}
class Gh extends Wx {
  constructor(e, x, t) {
    const i = s, n = new tn(x, 4, 2), a = new be({ wireframe: !![], fog: ![], toneMapped: ![] });
    super(n, a), this[i(1288)] = e, this[i(3282)] = t, this.type = "PointLightHelper", this.matrix = this[i(1288)][i(490)], this[i(1126)] = ![], this[i(3452)]();
  }
  [s(3387)]() {
    const e = s;
    this[e(1353)][e(3387)](), this[e(1870)][e(3387)]();
  }
  [s(3452)]() {
    const e = s;
    this[e(1288)].updateWorldMatrix(!![], ![]), this[e(3282)] !== void 0 ? this[e(1870)][e(3282)][e(1260)](this[e(3282)]) : this[e(1870)][e(3282)][e(2875)](this[e(1288)][e(3282)]);
  }
}
const T1 = new z(), Mc = new P0(), Sc = new P0();
class E1 extends px {
  constructor(e, x, t) {
    const i = s;
    super(), this[i(1288)] = e, this[i(1067)] = e[i(490)], this.matrixAutoUpdate = ![], this[i(3282)] = t, this[i(566)] = i(858);
    const n = new en(x);
    n[i(899)](Math.PI * 0.5), this.material = new be({ wireframe: !![], fog: ![], toneMapped: ![] }), this[i(3282)] === void 0 && (this[i(1870)][i(3530)] = !![]);
    const a = n[i(1740)]("position"), r = new Float32Array(a[i(1267)] * 3);
    n[i(3599)](i(3282), new gx(r, 3)), this.add(new Wx(n, this.material)), this[i(3452)]();
  }
  [s(3387)]() {
    const e = s;
    this[e(3049)][0][e(1353)][e(3387)](), this.children[0][e(1870)][e(3387)]();
  }
  [s(3452)]() {
    const e = s, x = this[e(3049)][0];
    if (this[e(3282)] !== void 0)
      this[e(1870)][e(3282)][e(1260)](this.color);
    else {
      const t = x[e(1353)][e(1740)]("color");
      Mc[e(2875)](this[e(1288)][e(3282)]), Sc[e(2875)](this[e(1288)].groundColor);
      for (let i = 0, n = t.count; i < n; i++) {
        const a = i < n / 2 ? Mc : Sc;
        t[e(1167)](i, a.r, a.g, a.b);
      }
      t[e(3035)] = !![];
    }
    this[e(1288)][e(630)](!![], ![]), x[e(2577)](T1[e(683)](this.light[e(490)])[e(3515)]());
  }
}
class A1 extends Ue {
  constructor(e = 10, x = 10, t = 4473924, i = 8947848) {
    const n = s;
    t = new P0(t), i = new P0(i);
    const a = x / 2, r = e / x, o = e / 2, c = [], h = [];
    for (let l = 0, _ = 0, p = -o; l <= x; l++, p += r) {
      c[n(3156)](-o, 0, p, o, 0, p), c[n(3156)](p, 0, -o, p, 0, o);
      const m = l === a ? t : i;
      m[n(1496)](h, _), _ += 3, m[n(1496)](h, _), _ += 3, m[n(1496)](h, _), _ += 3, m[n(1496)](h, _), _ += 3;
    }
    const f = new ox();
    f[n(3599)](n(3571), new W0(c, 3)), f.setAttribute(n(3282), new W0(h, 3));
    const u = new te({ vertexColors: !![], toneMapped: ![] });
    super(f, u), this.type = "GridHelper";
  }
  [s(3387)]() {
    const e = s;
    this[e(1353)][e(3387)](), this[e(1870)][e(3387)]();
  }
}
class C1 extends Ue {
  constructor(e = 10, x = 16, t = 8, i = 64, n = 4473924, a = 8947848) {
    const r = s;
    n = new P0(n), a = new P0(a);
    const o = [], c = [];
    if (x > 1)
      for (let u = 0; u < x; u++) {
        const l = u / x * (Math.PI * 2), _ = Math.sin(l) * e, p = Math[r(2063)](l) * e;
        o[r(3156)](0, 0, 0), o[r(3156)](_, 0, p);
        const m = u & 1 ? n : a;
        c[r(3156)](m.r, m.g, m.b), c.push(m.r, m.g, m.b);
      }
    for (let u = 0; u < t; u++) {
      const l = u & 1 ? n : a, _ = e - e / t * u;
      for (let p = 0; p < i; p++) {
        let m = p / i * (Math.PI * 2), y = Math[r(2626)](m) * _, v = Math.cos(m) * _;
        o[r(3156)](y, 0, v), c[r(3156)](l.r, l.g, l.b), m = (p + 1) / i * (Math.PI * 2), y = Math.sin(m) * _, v = Math.cos(m) * _, o[r(3156)](y, 0, v), c[r(3156)](l.r, l.g, l.b);
      }
    }
    const h = new ox();
    h[r(3599)](r(3571), new W0(o, 3)), h.setAttribute(r(3282), new W0(c, 3));
    const f = new te({ vertexColors: !![], toneMapped: ![] });
    super(h, f), this[r(566)] = r(970);
  }
  [s(3387)]() {
    const e = s;
    this.geometry[e(3387)](), this[e(1870)][e(3387)]();
  }
}
const Tc = new z(), qs = new z(), Ec = new z();
class Hh extends px {
  constructor(e, x, t) {
    const i = s;
    super(), this[i(1288)] = e, this[i(1067)] = e[i(490)], this[i(1126)] = ![], this[i(3282)] = t, this[i(566)] = i(2849), x === void 0 && (x = 1);
    let n = new ox();
    n.setAttribute(i(3571), new W0([-x, x, 0, x, x, 0, x, -x, 0, -x, -x, 0, -x, x, 0], 3));
    const a = new te({ fog: ![], toneMapped: ![] });
    this[i(2257)] = new st(n, a), this[i(3026)](this[i(2257)]), n = new ox(), n.setAttribute("position", new W0([0, 0, 0, 0, 0, 1], 3)), this[i(2698)] = new st(n, a), this[i(3026)](this[i(2698)]), this[i(3452)]();
  }
  dispose() {
    const e = s;
    this[e(2257)][e(1353)][e(3387)](), this[e(2257)][e(1870)][e(3387)](), this[e(2698)][e(1353)].dispose(), this[e(2698)].material.dispose();
  }
  [s(3452)]() {
    const e = s;
    this[e(1288)][e(630)](!![], ![]), this[e(1288)][e(671)].updateWorldMatrix(!![], ![]), Tc[e(683)](this[e(1288)][e(490)]), qs.setFromMatrixPosition(this.light.target[e(490)]), Ec[e(1061)](qs, Tc), this[e(2257)][e(2577)](qs), this[e(3282)] !== void 0 ? (this[e(2257)][e(1870)].color[e(1260)](this[e(3282)]), this[e(2698)][e(1870)].color.set(this.color)) : (this[e(2257)].material[e(3282)].copy(this[e(1288)].color), this[e(2698)][e(1870)][e(3282)][e(2875)](this[e(1288)][e(3282)])), this[e(2698)][e(2577)](qs), this[e(2698)][e(2204)].z = Ec.length();
  }
}
const Ys = new z(), zx = new wa();
class L1 extends Ue {
  constructor(e) {
    const x = s, t = new ox(), i = new te({ color: 16777215, vertexColors: !![], toneMapped: ![] }), n = [], a = [], r = {};
    o("n1", "n2"), o("n2", "n4"), o("n4", "n3"), o("n3", "n1"), o("f1", "f2"), o("f2", "f4"), o("f4", "f3"), o("f3", "f1"), o("n1", "f1"), o("n2", "f2"), o("n3", "f3"), o("n4", "f4"), o("p", "n1"), o("p", "n2"), o("p", "n3"), o("p", "n4"), o("u1", "u2"), o("u2", "u3"), o("u3", "u1"), o("c", "t"), o("p", "c"), o("cn1", x(728)), o(x(2306), x(1901)), o(x(2652), x(559)), o(x(1768), x(3569));
    function o(p, m) {
      c(p), c(m);
    }
    function c(p) {
      const m = x;
      n[m(3156)](0, 0, 0), a[m(3156)](0, 0, 0), r[p] === void 0 && (r[p] = []), r[p].push(n[m(3105)] / 3 - 1);
    }
    t[x(3599)](x(3571), new W0(n, 3)), t[x(3599)](x(3282), new W0(a, 3)), super(t, i), this[x(566)] = x(943), this[x(2189)] = e, this[x(2189)].updateProjectionMatrix && this[x(2189)][x(1701)](), this[x(1067)] = e.matrixWorld, this[x(1126)] = ![], this[x(3475)] = r, this[x(3452)]();
    const h = new P0(16755200), f = new P0(16711680), u = new P0(43775), l = new P0(16777215), _ = new P0(3355443);
    this[x(842)](h, f, u, l, _);
  }
  [s(842)](e, x, t, i, n) {
    const a = s, r = this[a(1353)], o = r.getAttribute(a(3282));
    o[a(1167)](0, e.r, e.g, e.b), o[a(1167)](1, e.r, e.g, e.b), o.setXYZ(2, e.r, e.g, e.b), o[a(1167)](3, e.r, e.g, e.b), o.setXYZ(4, e.r, e.g, e.b), o.setXYZ(5, e.r, e.g, e.b), o[a(1167)](6, e.r, e.g, e.b), o.setXYZ(7, e.r, e.g, e.b), o[a(1167)](8, e.r, e.g, e.b), o[a(1167)](9, e.r, e.g, e.b), o[a(1167)](10, e.r, e.g, e.b), o[a(1167)](11, e.r, e.g, e.b), o[a(1167)](12, e.r, e.g, e.b), o[a(1167)](13, e.r, e.g, e.b), o.setXYZ(14, e.r, e.g, e.b), o[a(1167)](15, e.r, e.g, e.b), o[a(1167)](16, e.r, e.g, e.b), o[a(1167)](17, e.r, e.g, e.b), o.setXYZ(18, e.r, e.g, e.b), o[a(1167)](19, e.r, e.g, e.b), o[a(1167)](20, e.r, e.g, e.b), o[a(1167)](21, e.r, e.g, e.b), o.setXYZ(22, e.r, e.g, e.b), o[a(1167)](23, e.r, e.g, e.b), o[a(1167)](24, x.r, x.g, x.b), o[a(1167)](25, x.r, x.g, x.b), o[a(1167)](26, x.r, x.g, x.b), o[a(1167)](27, x.r, x.g, x.b), o[a(1167)](28, x.r, x.g, x.b), o.setXYZ(29, x.r, x.g, x.b), o[a(1167)](30, x.r, x.g, x.b), o[a(1167)](31, x.r, x.g, x.b), o[a(1167)](32, t.r, t.g, t.b), o.setXYZ(33, t.r, t.g, t.b), o.setXYZ(34, t.r, t.g, t.b), o[a(1167)](35, t.r, t.g, t.b), o[a(1167)](36, t.r, t.g, t.b), o[a(1167)](37, t.r, t.g, t.b), o[a(1167)](38, i.r, i.g, i.b), o[a(1167)](39, i.r, i.g, i.b), o[a(1167)](40, n.r, n.g, n.b), o[a(1167)](41, n.r, n.g, n.b), o[a(1167)](42, n.r, n.g, n.b), o.setXYZ(43, n.r, n.g, n.b), o.setXYZ(44, n.r, n.g, n.b), o[a(1167)](45, n.r, n.g, n.b), o[a(1167)](46, n.r, n.g, n.b), o[a(1167)](47, n.r, n.g, n.b), o[a(1167)](48, n.r, n.g, n.b), o[a(1167)](49, n.r, n.g, n.b), o[a(3035)] = !![];
  }
  [s(3452)]() {
    const e = s, x = this[e(1353)], t = this.pointMap, i = 1, n = 1;
    zx[e(583)][e(2875)](this[e(2189)][e(583)]), Fx("c", t, x, zx, 0, 0, -1), Fx("t", t, x, zx, 0, 0, 1), Fx("n1", t, x, zx, -i, -n, -1), Fx("n2", t, x, zx, i, -n, -1), Fx("n3", t, x, zx, -i, n, -1), Fx("n4", t, x, zx, i, n, -1), Fx("f1", t, x, zx, -i, -n, 1), Fx("f2", t, x, zx, i, -n, 1), Fx("f3", t, x, zx, -i, n, 1), Fx("f4", t, x, zx, i, n, 1), Fx("u1", t, x, zx, i * 0.7, n * 1.1, -1), Fx("u2", t, x, zx, -i * 0.7, n * 1.1, -1), Fx("u3", t, x, zx, 0, n * 2, -1), Fx(e(2652), t, x, zx, -i, 0, 1), Fx(e(559), t, x, zx, i, 0, 1), Fx("cf3", t, x, zx, 0, -n, 1), Fx(e(3569), t, x, zx, 0, n, 1), Fx(e(693), t, x, zx, -i, 0, -1), Fx("cn2", t, x, zx, i, 0, -1), Fx(e(2306), t, x, zx, 0, -n, -1), Fx("cn4", t, x, zx, 0, n, -1), x[e(1740)](e(3571))[e(3035)] = !![];
  }
  [s(3387)]() {
    const e = s;
    this[e(1353)].dispose(), this.material[e(3387)]();
  }
}
function Fx(d, e, x, t, i, n, a) {
  const r = s;
  Ys[r(1260)](i, n, a)[r(1603)](t);
  const o = e[d];
  if (o !== void 0) {
    const c = x[r(1740)](r(3571));
    for (let h = 0, f = o[r(3105)]; h < f; h++)
      c.setXYZ(o[h], Ys.x, Ys.y, Ys.z);
  }
}
const Zs = new at();
class R1 extends Ue {
  constructor(e, x = 16776960) {
    const t = s, i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), n = new Float32Array(8 * 3), a = new ox();
    a[t(2203)](new gx(i, 1)), a.setAttribute("position", new gx(n, 3)), super(a, new te({ color: x, toneMapped: ![] })), this[t(1413)] = e, this[t(566)] = t(1348), this[t(1126)] = ![], this[t(3452)]();
  }
  [s(3452)](e) {
    const x = s;
    if (e !== void 0 && console[x(3629)]("THREE.BoxHelper: .update() has no longer arguments."), this.object !== void 0 && Zs[x(3392)](this[x(1413)]), Zs[x(2253)]())
      return;
    const t = Zs[x(3085)], i = Zs.max, n = this[x(1353)][x(3265)][x(3571)], a = n[x(2712)];
    a[0] = i.x, a[1] = i.y, a[2] = i.z, a[3] = t.x, a[4] = i.y, a[5] = i.z, a[6] = t.x, a[7] = t.y, a[8] = i.z, a[9] = i.x, a[10] = t.y, a[11] = i.z, a[12] = i.x, a[13] = i.y, a[14] = t.z, a[15] = t.x, a[16] = i.y, a[17] = t.z, a[18] = t.x, a[19] = t.y, a[20] = t.z, a[21] = i.x, a[22] = t.y, a[23] = t.z, n.needsUpdate = !![], this.geometry[x(2613)]();
  }
  setFromObject(e) {
    const x = s;
    return this[x(1413)] = e, this[x(3452)](), this;
  }
  [s(2875)](e, x) {
    const t = s;
    return super[t(2875)](e, x), this.object = e[t(1413)], this;
  }
  [s(3387)]() {
    const e = s;
    this.geometry[e(3387)](), this.material[e(3387)]();
  }
}
class P1 extends Ue {
  constructor(e, x = 16776960) {
    const t = s, i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), n = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], a = new ox();
    a[t(2203)](new gx(i, 1)), a[t(3599)](t(3571), new W0(n, 3)), super(a, new te({ color: x, toneMapped: ![] })), this[t(1423)] = e, this[t(566)] = "Box3Helper", this[t(1353)][t(2613)]();
  }
  [s(3640)](e) {
    const x = s, t = this.box;
    t.isEmpty() || (t.getCenter(this.position), t[x(561)](this.scale), this[x(2204)][x(580)](0.5), super[x(3640)](e));
  }
  dispose() {
    const e = s;
    this.geometry[e(3387)](), this.material[e(3387)]();
  }
}
class I1 extends st {
  constructor(e, x = 1, t = 16776960) {
    const i = s, n = t, a = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], r = new ox();
    r[i(3599)](i(3571), new W0(a, 3)), r[i(2613)](), super(r, new te({ color: n, toneMapped: ![] })), this[i(566)] = i(3229), this[i(2386)] = e, this[i(3073)] = x;
    const o = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], c = new ox();
    c[i(3599)](i(3571), new W0(o, 3)), c[i(2613)](), this.add(new Wx(c, new be({ color: n, opacity: 0.2, transparent: !![], depthWrite: ![], toneMapped: ![] })));
  }
  [s(3640)](e) {
    const x = s;
    this[x(3571)][x(1260)](0, 0, 0), this[x(2204)][x(1260)](0.5 * this[x(3073)], 0.5 * this[x(3073)], 1), this[x(2577)](this[x(2386)].normal), this[x(3409)](-this[x(2386)][x(2656)]), super.updateMatrixWorld(e);
  }
  dispose() {
    const e = s;
    this[e(1353)][e(3387)](), this[e(1870)][e(3387)](), this[e(3049)][0].geometry[e(3387)](), this[e(3049)][0][e(1870)][e(3387)]();
  }
}
const Ac = new z();
let Ks, mr;
class D1 extends px {
  constructor(e = new z(0, 0, 1), x = new z(0, 0, 0), t = 1, i = 16776960, n = t * 0.2, a = n * 0.2) {
    const r = s;
    super(), this[r(566)] = r(3286), Ks === void 0 && (Ks = new ox(), Ks.setAttribute(r(3571), new W0([0, 0, 0, 0, 1, 0], 3)), mr = new ci(0, 0.5, 1, 5, 1), mr.translate(0, -0.5, 0)), this.position[r(2875)](x), this[r(3319)] = new st(Ks, new te({ color: i, toneMapped: ![] })), this.line[r(1126)] = ![], this[r(3026)](this[r(3319)]), this[r(3017)] = new Wx(mr, new be({ color: i, toneMapped: ![] })), this[r(3017)][r(1126)] = ![], this[r(3026)](this[r(3017)]), this[r(1961)](e), this.setLength(t, n, a);
  }
  [s(1961)](e) {
    const x = s;
    if (e.y > 0.99999)
      this.quaternion[x(1260)](0, 0, 0, 1);
    else if (e.y < -0.99999)
      this.quaternion[x(1260)](1, 0, 0, 0);
    else {
      Ac[x(1260)](e.z, 0, -e.x)[x(608)]();
      const t = Math[x(2765)](e.y);
      this[x(3055)].setFromAxisAngle(Ac, t);
    }
  }
  [s(3399)](e, x = e * 0.2, t = x * 0.2) {
    const i = s;
    this[i(3319)][i(2204)].set(1, Math[i(1803)](1e-4, e - x), 1), this[i(3319)].updateMatrix(), this[i(3017)][i(2204)][i(1260)](t, x, t), this[i(3017)].position.y = e, this[i(3017)].updateMatrix();
  }
  [s(1583)](e) {
    const x = s;
    this.line[x(1870)][x(3282)][x(1260)](e), this.cone[x(1870)][x(3282)].set(e);
  }
  [s(2875)](e) {
    const x = s;
    return super[x(2875)](e, ![]), this[x(3319)].copy(e.line), this[x(3017)][x(2875)](e[x(3017)]), this;
  }
  [s(3387)]() {
    const e = s;
    this.line.geometry[e(3387)](), this.line[e(1870)].dispose(), this[e(3017)][e(1353)][e(3387)](), this[e(3017)][e(1870)][e(3387)]();
  }
}
class kh extends Ue {
  constructor(e = 1) {
    const x = s, t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e], i = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1], n = new ox();
    n[x(3599)]("position", new W0(t, 3)), n.setAttribute(x(3282), new W0(i, 3));
    const a = new te({ vertexColors: !![], toneMapped: ![] });
    super(n, a), this[x(566)] = "AxesHelper";
  }
  setColors(e, x, t) {
    const i = s, n = new P0(), a = this[i(1353)].attributes[i(3282)][i(2712)];
    return n[i(1260)](e), n[i(1496)](a, 0), n.toArray(a, 3), n[i(1260)](x), n[i(1496)](a, 6), n[i(1496)](a, 9), n[i(1260)](t), n[i(1496)](a, 12), n[i(1496)](a, 15), this[i(1353)][i(3265)][i(3282)][i(3035)] = !![], this;
  }
  [s(3387)]() {
    const e = s;
    this.geometry[e(3387)](), this[e(1870)][e(3387)]();
  }
}
class O1 {
  constructor() {
    const e = s;
    this.type = e(2435), this[e(3282)] = new P0(), this[e(3455)] = [], this[e(3540)] = null;
  }
  [s(1729)](e, x) {
    const t = s;
    return this[t(3540)] = new Fn(), this[t(3455)][t(3156)](this.currentPath), this.currentPath[t(1729)](e, x), this;
  }
  [s(3200)](e, x) {
    const t = s;
    return this[t(3540)][t(3200)](e, x), this;
  }
  [s(2423)](e, x, t, i) {
    const n = s;
    return this[n(3540)][n(2423)](e, x, t, i), this;
  }
  [s(3432)](e, x, t, i, n, a) {
    const r = s;
    return this[r(3540)][r(3432)](e, x, t, i, n, a), this;
  }
  [s(3517)](e) {
    return this[s(3540)].splineThru(e), this;
  }
  [s(2328)](e) {
    const x = s;
    function t(v) {
      const g = c0, b = [];
      for (let M = 0, A = v[g(3105)]; M < A; M++) {
        const L = v[M], P = new ni();
        P.curves = L[g(2554)], b[g(3156)](P);
      }
      return b;
    }
    function i(v, g) {
      const b = c0, M = g[b(3105)];
      let A = ![];
      for (let L = M - 1, P = 0; P < M; L = P++) {
        let S = g[L], I = g[P], C = I.x - S.x, G = I.y - S.y;
        if (Math.abs(G) > Number[b(633)]) {
          if (G < 0 && (S = g[P], C = -C, I = g[L], G = -G), v.y < S.y || v.y > I.y)
            continue;
          if (v.y === S.y) {
            if (v.x === S.x)
              return !![];
          } else {
            const $ = G * (v.x - S.x) - C * (v.y - S.y);
            if ($ === 0)
              return !![];
            if ($ < 0)
              continue;
            A = !A;
          }
        } else {
          if (v.y !== S.y)
            continue;
          if (I.x <= v.x && v.x <= S.x || S.x <= v.x && v.x <= I.x)
            return !![];
        }
      }
      return A;
    }
    const n = je.isClockWise, a = this[x(3455)];
    if (a[x(3105)] === 0)
      return [];
    let r, o, c;
    const h = [];
    if (a[x(3105)] === 1)
      return o = a[0], c = new ni(), c[x(2554)] = o[x(2554)], h.push(c), h;
    let f = !n(a[0][x(2137)]());
    f = e ? !f : f;
    const u = [], l = [];
    let _ = [], p = 0, m;
    l[p] = void 0, _[p] = [];
    for (let v = 0, g = a[x(3105)]; v < g; v++)
      o = a[v], m = o[x(2137)](), r = n(m), r = e ? !r : r, r ? (!f && l[p] && p++, l[p] = { s: new ni(), p: m }, l[p].s[x(2554)] = o[x(2554)], f && p++, _[p] = []) : _[p][x(3156)]({ h: o, p: m[0] });
    if (!l[0])
      return t(a);
    if (l[x(3105)] > 1) {
      let v = ![], g = 0;
      for (let b = 0, M = l[x(3105)]; b < M; b++)
        u[b] = [];
      for (let b = 0, M = l[x(3105)]; b < M; b++) {
        const A = _[b];
        for (let L = 0; L < A[x(3105)]; L++) {
          const P = A[L];
          let S = !![];
          for (let I = 0; I < l.length; I++)
            i(P.p, l[I].p) && (b !== I && g++, S ? (S = ![], u[I][x(3156)](P)) : v = !![]);
          S && u[b][x(3156)](P);
        }
      }
      g > 0 && v === ![] && (_ = u);
    }
    let y;
    for (let v = 0, g = l[x(3105)]; v < g; v++) {
      c = l[v].s, h[x(3156)](c), y = _[v];
      for (let b = 0, M = y.length; b < M; b++)
        c[x(2254)][x(3156)](y[b].h);
    }
    return h;
  }
}
const tt = N1();
function N1() {
  const d = new ArrayBuffer(4), e = new Float32Array(d), x = new Uint32Array(d), t = new Uint32Array(512), i = new Uint32Array(512);
  for (let o = 0; o < 256; ++o) {
    const c = o - 127;
    c < -27 ? (t[o] = 0, t[o | 256] = 32768, i[o] = 24, i[o | 256] = 24) : c < -14 ? (t[o] = 1024 >> -c - 14, t[o | 256] = 1024 >> -c - 14 | 32768, i[o] = -c - 1, i[o | 256] = -c - 1) : c <= 15 ? (t[o] = c + 15 << 10, t[o | 256] = c + 15 << 10 | 32768, i[o] = 13, i[o | 256] = 13) : c < 128 ? (t[o] = 31744, t[o | 256] = 64512, i[o] = 24, i[o | 256] = 24) : (t[o] = 31744, t[o | 256] = 64512, i[o] = 13, i[o | 256] = 13);
  }
  const n = new Uint32Array(2048), a = new Uint32Array(64), r = new Uint32Array(64);
  for (let o = 1; o < 1024; ++o) {
    let c = o << 13, h = 0;
    for (; !(c & 8388608); )
      c <<= 1, h -= 8388608;
    c &= -8388609, h += 947912704, n[o] = c | h;
  }
  for (let o = 1024; o < 2048; ++o)
    n[o] = 939524096 + (o - 1024 << 13);
  for (let o = 1; o < 31; ++o)
    a[o] = o << 23;
  a[31] = 1199570944, a[32] = 2147483648;
  for (let o = 33; o < 63; ++o)
    a[o] = 2147483648 + (o - 32 << 23);
  a[63] = 3347054592;
  for (let o = 1; o < 64; ++o)
    o !== 32 && (r[o] = 1024);
  return { floatView: e, uint32View: x, baseTable: t, shiftTable: i, mantissaTable: n, exponentTable: a, offsetTable: r };
}
function U1(d) {
  const e = s;
  Math.abs(d) > 65504 && console[e(3629)](e(2581)), d = Gx(d, -65504, 65504), tt[e(1824)][0] = d;
  const x = tt[e(2436)][0], t = x >> 23 & 511;
  return tt[e(3188)][t] + ((x & 8388607) >> tt[e(1038)][t]);
}
function z1(d) {
  const e = s, x = d >> 10;
  return tt.uint32View[0] = tt[e(3778)][tt[e(3449)][x] + (d & 1023)] + tt[e(1055)][x], tt.floatView[0];
}
const Qt = { toHalfFloat: U1, fromHalfFloat: z1 };
class B1 extends It {
  constructor(e, x, t, i, n, a) {
    console.warn("THREE.BoxBufferGeometry has been renamed to THREE.BoxGeometry."), super(e, x, t, i, n, a);
  }
}
class F1 extends Kn {
  constructor(e, x, t, i) {
    const n = s;
    console[n(3629)](n(2675)), super(e, x, t, i);
  }
}
class G1 extends $n {
  constructor(e, x, t, i) {
    console.warn("THREE.CircleBufferGeometry has been renamed to THREE.CircleGeometry."), super(e, x, t, i);
  }
}
class H1 extends Jn {
  constructor(e, x, t, i, n, a, r) {
    console[s(3629)]("THREE.ConeBufferGeometry has been renamed to THREE.ConeGeometry."), super(e, x, t, i, n, a, r);
  }
}
class k1 extends ci {
  constructor(e, x, t, i, n, a, r, o) {
    console.warn("THREE.CylinderBufferGeometry has been renamed to THREE.CylinderGeometry."), super(e, x, t, i, n, a, r, o);
  }
}
class V1 extends Qn {
  constructor(e, x) {
    console[s(3629)]("THREE.DodecahedronBufferGeometry has been renamed to THREE.DodecahedronGeometry."), super(e, x);
  }
}
class W1 extends xs {
  constructor(e, x) {
    const t = s;
    console[t(3629)](t(3623)), super(e, x);
  }
}
class j1 extends es {
  constructor(e, x) {
    console.warn(s(1053)), super(e, x);
  }
}
class X1 extends xn {
  constructor(e, x, t, i) {
    console[s(3629)]("THREE.LatheBufferGeometry has been renamed to THREE.LatheGeometry."), super(e, x, t, i);
  }
}
class q1 extends en {
  constructor(e, x) {
    const t = s;
    console[t(3629)](t(1601)), super(e, x);
  }
}
class Y1 extends $i {
  constructor(e, x, t, i) {
    console[s(3629)]("THREE.PlaneBufferGeometry has been renamed to THREE.PlaneGeometry."), super(e, x, t, i);
  }
}
class Z1 extends rt {
  constructor(e, x, t, i) {
    const n = s;
    console[n(3629)](n(1749)), super(e, x, t, i);
  }
}
class K1 extends ts {
  constructor(e, x, t, i, n, a) {
    console.warn(s(1415)), super(e, x, t, i, n, a);
  }
}
class $1 extends is {
  constructor(e, x) {
    const t = s;
    console[t(3629)](t(3535)), super(e, x);
  }
}
class J1 extends tn {
  constructor(e, x, t, i, n, a, r) {
    const o = s;
    console[o(3629)](o(576)), super(e, x, t, i, n, a, r);
  }
}
class Q1 extends ns {
  constructor(e, x) {
    const t = s;
    console[t(3629)](t(1927)), super(e, x);
  }
}
class x3 extends ss {
  constructor(e, x, t, i, n) {
    const a = s;
    console[a(3629)](a(1506)), super(e, x, t, i, n);
  }
}
class e3 extends as {
  constructor(e, x, t, i, n, a) {
    const r = s;
    console[r(3629)](r(1999)), super(e, x, t, i, n, a);
  }
}
class t3 extends rs {
  constructor(e, x, t, i, n) {
    console[s(3629)]("THREE.TubeBufferGeometry has been renamed to THREE.TubeGeometry."), super(e, x, t, i, n);
  }
}
typeof __THREE_DEVTOOLS__ !== s(2011) && __THREE_DEVTOOLS__[s(3157)](new CustomEvent("register", { detail: { revision: pa } }));
typeof window < "u" && (window[s(2633)] ? console[s(3629)](s(1489)) : window[s(2633)] = pa);
const i3 = Object[s(1169)](Object.defineProperty({ __proto__: null, ACESFilmicToneMapping: pd, AddEquation: jt, AddOperation: ld, AdditiveAnimationBlendMode: M2, AdditiveBlending: ha, AlphaFormat: Md, AlwaysDepth: ad, AlwaysStencilFunc: Bd, AmbientLight: eo, AmbientLightProbe: Km, AnimationClip: qi, AnimationLoader: Gm, AnimationMixer: zh, AnimationObjectGroup: f1, AnimationUtils: Um, ArcCurve: sh, ArrayCamera: Qd, ArrowHelper: D1, Audio: Nh, AudioAnalyser: t1, AudioContext: to, AudioListener: Qm, AudioLoader: Ym, AxesHelper: kh, BackSide: re, BasicDepthPacking: Nd, BasicShadowMap: sf, Bone: Ca, BooleanKeyframeTrack: qt, Box2: y1, Box3: at, Box3Helper: P1, BoxBufferGeometry: B1, BoxGeometry: It, BoxHelper: R1, BufferAttribute: gx, BufferGeometry: ox, BufferGeometryLoader: Dh, ByteType: gd, Cache: Lt, Camera: wa, CameraHelper: L1, CanvasTexture: am, CapsuleBufferGeometry: F1, CapsuleGeometry: Kn, CatmullRomCurve3: ah, CineonToneMapping: bd, CircleBufferGeometry: G1, CircleGeometry: $n, ClampToEdgeWrapping: Zx, Clock: za, Color: P0, ColorKeyframeTrack: K2, ColorManagement: xe, CompressedArrayTexture: sm, CompressedTexture: G2, CompressedTextureLoader: Hm, ConeBufferGeometry: H1, ConeGeometry: Jn, CubeCamera: jd, CubeReflectionMapping: St, CubeRefractionMapping: Tt, CubeTexture: qn, CubeTextureLoader: km, CubeUVReflectionMapping: Ki, CubicBezierCurve: k2, CubicBezierCurve3: rh, CubicInterpolant: Sh, CullFaceBack: Lr, CullFaceFront: jc, CullFaceFrontBack: nf, CullFaceNone: Wc, Curve: ze, CurvePath: ch, CustomBlending: qc, CustomToneMapping: md, CylinderBufferGeometry: k1, CylinderGeometry: ci, Cylindrical: v1, Data3DTexture: C2, DataArrayTexture: va, DataTexture: Bi, DataTextureLoader: J2, DataUtils: Qt, DecrementStencilOp: bf, DecrementWrapStencilOp: mf, DefaultLoadingManager: Ah, DepthFormat: wt, DepthStencilFormat: si, DepthTexture: xh, DirectionalLight: Oa, DirectionalLightHelper: Hh, DiscreteInterpolant: Th, DisplayP3ColorSpace: T2, DodecahedronBufferGeometry: V1, DodecahedronGeometry: Qn, DoubleSide: ke, DstAlphaFactor: xd, DstColorFactor: td, DynamicCopyUsage: If, DynamicDrawUsage: Ef, DynamicReadUsage: Lf, EdgesGeometry: dh, EllipseCurve: Ra, EqualDepth: od, EqualStencilFunc: yf, EquirectangularReflectionMapping: Gi, EquirectangularRefractionMapping: Pn, Euler: Xn, EventDispatcher: Ye, ExtrudeBufferGeometry: W1, ExtrudeGeometry: xs, FileLoader: ye, Float16BufferAttribute: gl, Float32BufferAttribute: W0, Float64BufferAttribute: _l, FloatType: ae, Fog: Aa, FogExp2: Ea, FramebufferTexture: nm, FrontSide: Xe, Frustum: Ma, GLBufferAttribute: g1, GLSL1: Of, GLSL3: i2, GreaterDepth: dd, GreaterEqualDepth: cd, GreaterEqualStencilFunc: Tf, GreaterStencilFunc: Mf, GridHelper: A1, Group: nt, HalfFloatType: ue, HemisphereLight: Lh, HemisphereLightHelper: E1, HemisphereLightProbe: Zm, IcosahedronBufferGeometry: j1, IcosahedronGeometry: es, ImageBitmapLoader: Oh, ImageLoader: Vn, ImageUtils: A2, IncrementStencilOp: uf, IncrementWrapStencilOp: pf, InstancedBufferAttribute: Wi, InstancedBufferGeometry: Ih, InstancedInterleavedBuffer: m1, InstancedMesh: z2, Int16BufferAttribute: pl, Int32BufferAttribute: ml, Int8BufferAttribute: ll, IntType: vd, InterleavedBuffer: Yn, InterleavedBufferAttribute: Ct, Interpolant: nn, InterpolateDiscrete: ki, InterpolateLinear: ai, InterpolateSmooth: oa, InvertStencilOp: gf, KeepStencilOp: ca, KeyframeTrack: Oe, LOD: nh, LatheBufferGeometry: X1, LatheGeometry: xn, Layers: ya, LessDepth: rd, LessEqualDepth: fa, LessEqualStencilFunc: wf, LessStencilFunc: vf, Light: Dt, LightProbe: Na, Line: st, Line3: w1, LineBasicMaterial: te, LineCurve: Pa, LineCurve3: oh, LineDashedMaterial: wh, LineLoop: B2, LineSegments: Ue, LinearEncoding: Ne, LinearFilter: Cx, LinearInterpolant: Z2, LinearMipMapLinearFilter: df, LinearMipMapNearestFilter: cf, LinearMipmapLinearFilter: qe, LinearMipmapNearestFilter: ga, LinearSRGBColorSpace: ri, LinearToneMapping: ud, Loader: ce, LoaderUtils: Yi, LoadingManager: $2, LoopOnce: w2, LoopPingPong: Dd, LoopRepeat: Id, LuminanceAlphaFormat: Td, LuminanceFormat: Sd, MOUSE: ef, Material: jx, MaterialLoader: Ua, MathUtils: Hd, Matrix3: Kx, Matrix4: ix, MaxEquation: Dr, Mesh: Wx, MeshBasicMaterial: be, MeshDepthMaterial: I2, MeshDistanceMaterial: D2, MeshLambertMaterial: vh, MeshMatcapMaterial: yh, MeshNormalMaterial: _h, MeshPhongMaterial: mh, MeshPhysicalMaterial: ot, MeshStandardMaterial: os, MeshToonMaterial: gh, MinEquation: Ir, MirroredRepeatWrapping: Hi, MixOperation: fd, MultiplyBlending: Pr, MultiplyOperation: Wn, NearestFilter: Bx, NearestMipMapLinearFilter: of, NearestMipMapNearestFilter: rf, NearestMipmapLinearFilter: Ui, NearestMipmapNearestFilter: In, NeverDepth: sd, NeverStencilFunc: _f, NoBlending: Ve, NoColorSpace: hf, NoToneMapping: We, NormalAnimationBlendMode: _a, NormalBlending: ei, NotEqualDepth: hd, NotEqualStencilFunc: Sf, NumberKeyframeTrack: ji, Object3D: px, ObjectLoader: Xm, ObjectSpaceNormalMap: zd, OctahedronBufferGeometry: q1, OctahedronGeometry: en, OneFactor: $c, OneMinusDstAlphaFactor: ed, OneMinusDstColorFactor: id, OneMinusSrcAlphaFactor: g2, OneMinusSrcColorFactor: Qc, OrthographicCamera: Ji, PCFShadowMap: p2, PCFSoftShadowMap: Xc, PMREMGenerator: Bn, Path: Fn, PerspectiveCamera: Vx, Plane: mt, PlaneBufferGeometry: Y1, PlaneGeometry: $i, PlaneHelper: I1, PointLight: Da, PointLightHelper: Gh, Points: F2, PointsMaterial: La, PolarGridHelper: C1, PolyhedronBufferGeometry: Z1, PolyhedronGeometry: rt, PositionalAudio: e1, PropertyBinding: ux, PropertyMixer: Uh, QuadraticBezierCurve: V2, QuadraticBezierCurve3: W2, Quaternion: $x, QuaternionKeyframeTrack: Mt, QuaternionLinearInterpolant: Eh, RED_GREEN_RGTC2_Format: e2, RED_RGTC1_Format: Pd, REVISION: pa, RGBADepthPacking: Ud, RGBAFormat: le, RGBAIntegerFormat: Ld, RGBA_ASTC_10x10_Format: $r, RGBA_ASTC_10x5_Format: Yr, RGBA_ASTC_10x6_Format: Zr, RGBA_ASTC_10x8_Format: Kr, RGBA_ASTC_12x10_Format: Jr, RGBA_ASTC_12x12_Format: Qr, RGBA_ASTC_4x4_Format: Gr, RGBA_ASTC_5x4_Format: Hr, RGBA_ASTC_5x5_Format: kr, RGBA_ASTC_6x5_Format: Vr, RGBA_ASTC_6x6_Format: Wr, RGBA_ASTC_8x5_Format: jr, RGBA_ASTC_8x6_Format: Xr, RGBA_ASTC_8x8_Format: qr, RGBA_BPTC_Format: ra, RGBA_ETC2_EAC_Format: Fr, RGBA_PVRTC_2BPPV1_Format: zr, RGBA_PVRTC_4BPPV1_Format: Ur, RGBA_S3TC_DXT1_Format: na, RGBA_S3TC_DXT3_Format: sa, RGBA_S3TC_DXT5_Format: aa, RGB_ETC1_Format: Rd, RGB_ETC2_Format: Br, RGB_PVRTC_2BPPV1_Format: Nr, RGB_PVRTC_4BPPV1_Format: Or, RGB_S3TC_DXT1_Format: ia, RGFormat: Ad, RGIntegerFormat: Cd, RawShaderMaterial: ph, Ray: jn, Raycaster: Bh, RectAreaLight: Rh, RedFormat: y2, RedIntegerFormat: Ed, ReinhardToneMapping: _2, RepeatWrapping: Et, ReplaceStencilOp: lf, ReverseSubtractEquation: Zc, RingBufferGeometry: K1, RingGeometry: ts, SIGNED_RED_GREEN_RGTC2_Format: t2, SIGNED_RED_RGTC1_Format: x2, SRGBColorSpace: _e, Scene: O2, ShaderChunk: dx, ShaderLib: De, ShaderMaterial: ee, ShadowMaterial: bh, Shape: ni, ShapeBufferGeometry: $1, ShapeGeometry: is, ShapePath: O1, ShapeUtils: je, ShortType: _d, Skeleton: Zn, SkeletonHelper: S1, SkinnedMesh: U2, Source: $t, Sphere: Pt, SphereBufferGeometry: J1, SphereGeometry: tn, Spherical: _1, SphericalHarmonics3: Ph, SplineCurve: j2, SpotLight: xo, SpotLightHelper: M1, Sprite: ih, SpriteMaterial: N2, SrcAlphaFactor: m2, SrcAlphaSaturateFactor: nd, SrcColorFactor: Jc, StaticCopyUsage: Pf, StaticDrawUsage: On, StaticReadUsage: Cf, StereoCamera: $m, StreamCopyUsage: Df, StreamDrawUsage: Af, StreamReadUsage: Rf, StringKeyframeTrack: Yt, SubtractEquation: Yc, SubtractiveBlending: Rr, TOUCH: tf, TangentSpaceNormalMap: Rt, TetrahedronBufferGeometry: Q1, TetrahedronGeometry: ns, Texture: Ux, TextureLoader: Ch, TorusBufferGeometry: x3, TorusGeometry: ss, TorusKnotBufferGeometry: e3, TorusKnotGeometry: as, Triangle: Ee, TriangleFanDrawMode: la, TriangleStripDrawMode: S2, TrianglesDrawMode: Od, TubeBufferGeometry: t3, TubeGeometry: rs, TwoPassDoubleSide: af, UVMapping: ma, Uint16BufferAttribute: L2, Uint32BufferAttribute: R2, Uint8BufferAttribute: ul, Uint8ClampedBufferAttribute: bl, Uniform: so, UniformsGroup: p1, UniformsLib: I0, UniformsUtils: zn, UnsignedByteType: At, UnsignedInt248Type: ti, UnsignedIntType: _t, UnsignedShort4444Type: yd, UnsignedShort5551Type: wd, UnsignedShortType: v2, VSMShadowMap: Ii, Vector2: d0, Vector3: z, Vector4: Mx, VectorKeyframeTrack: Xi, VideoTexture: im, WebGL1Renderer: eh, WebGL3DRenderTarget: il, WebGLArrayRenderTarget: tl, WebGLCubeRenderTarget: Xd, WebGLMultipleRenderTargets: nl, WebGLRenderTarget: oe, WebGLRenderer: Ta, WebGLUtils: Jd, WireframeGeometry: uh, WrapAroundEnding: Dn, ZeroCurvatureEnding: Zt, ZeroFactor: Kc, ZeroSlopeEnding: Kt, ZeroStencilOp: ff, _SRGBAFormat: ua, sRGBEncoding: _x }, Symbol[s(3609)], { value: "Module" }));
function Cc(d, e) {
  const x = s;
  if (e === Od)
    return console[x(3629)]("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), d;
  if (e === la || e === S2) {
    let t = d.getIndex();
    if (t === null) {
      const r = [], o = d[x(1740)](x(3571));
      if (o !== void 0) {
        for (let c = 0; c < o[x(1267)]; c++)
          r.push(c);
        d[x(2203)](r), t = d[x(2570)]();
      } else
        return console[x(533)](x(3279)), d;
    }
    const i = t[x(1267)] - 2, n = [];
    if (e === la)
      for (let r = 1; r <= i; r++)
        n[x(3156)](t[x(781)](0)), n.push(t[x(781)](r)), n.push(t.getX(r + 1));
    else
      for (let r = 0; r < i; r++)
        r % 2 === 0 ? (n.push(t[x(781)](r)), n[x(3156)](t[x(781)](r + 1)), n.push(t[x(781)](r + 2))) : (n[x(3156)](t[x(781)](r + 2)), n.push(t.getX(r + 1)), n[x(3156)](t[x(781)](r)));
    n[x(3105)] / 3 !== i && console[x(533)]("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    const a = d.clone();
    return a[x(2203)](n), a[x(3382)](), a;
  } else
    return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", e), d;
}
class n3 extends ce {
  constructor(e) {
    const x = s;
    super(e), this[x(3186)] = null, this[x(3685)] = null, this[x(1997)] = null, this[x(3592)] = [], this[x(3610)](function(t) {
      return new c3(t);
    }), this[x(3610)](function(t) {
      return new p3(t);
    }), this[x(3610)](function(t) {
      return new m3(t);
    }), this[x(3610)](function(t) {
      return new g3(t);
    }), this[x(3610)](function(t) {
      return new h3(t);
    }), this[x(3610)](function(t) {
      return new f3(t);
    }), this[x(3610)](function(t) {
      return new l3(t);
    }), this[x(3610)](function(t) {
      return new u3(t);
    }), this[x(3610)](function(t) {
      return new o3(t);
    }), this[x(3610)](function(t) {
      return new b3(t);
    }), this[x(3610)](function(t) {
      return new d3(t);
    }), this.register(function(t) {
      return new a3(t);
    }), this.register(function(t) {
      return new _3(t);
    }), this.register(function(t) {
      return new v3(t);
    });
  }
  [s(3442)](e, x, t, i) {
    const n = s, a = this;
    let r;
    this[n(1421)] !== "" ? r = this.resourcePath : this[n(597)] !== "" ? r = this[n(597)] : r = Yi[n(3380)](e), this[n(3235)][n(2663)](e);
    const o = function(h) {
      const f = n;
      i ? i(h) : console[f(533)](h), a[f(3235)][f(829)](e), a[f(3235)].itemEnd(e);
    }, c = new ye(this.manager);
    c[n(3121)](this[n(597)]), c[n(2624)]("arraybuffer"), c[n(590)](this[n(1283)]), c[n(2958)](this[n(1062)]), c.load(e, function(h) {
      const f = n;
      try {
        a[f(1359)](h, r, function(u) {
          const l = f;
          x(u), a[l(3235)][l(3239)](e);
        }, o);
      } catch (u) {
        o(u);
      }
    }, t, o);
  }
  [s(2726)](e) {
    const x = s;
    return this[x(3186)] = e, this;
  }
  [s(2286)]() {
    const e = s;
    throw new Error(e(1967));
  }
  [s(1913)](e) {
    return this.ktx2Loader = e, this;
  }
  [s(2088)](e) {
    const x = s;
    return this[x(1997)] = e, this;
  }
  [s(3610)](e) {
    const x = s;
    return this[x(3592)][x(882)](e) === -1 && this[x(3592)].push(e), this;
  }
  [s(1628)](e) {
    const x = s;
    return this[x(3592)][x(882)](e) !== -1 && this[x(3592)][x(1733)](this.pluginCallbacks.indexOf(e), 1), this;
  }
  [s(1359)](e, x, t, i) {
    const n = s;
    let a;
    const r = {}, o = {}, c = new TextDecoder();
    if (typeof e === n(3335))
      a = JSON[n(1359)](e);
    else if (e instanceof ArrayBuffer)
      if (c[n(528)](new Uint8Array(e, 0, 4)) === Vh) {
        try {
          r[bx[n(2115)]] = new y3(e);
        } catch (u) {
          i && i(u);
          return;
        }
        a = JSON[n(1359)](r[bx.KHR_BINARY_GLTF][n(1040)]);
      } else
        a = JSON[n(1359)](c[n(528)](e));
    else
      a = e;
    if (a.asset === void 0 || a[n(1991)].version[0] < 2) {
      i && i(new Error(n(1584)));
      return;
    }
    const h = new O3(a, { path: x || this[n(1421)] || "", crossOrigin: this[n(2825)], requestHeader: this[n(1283)], manager: this.manager, ktx2Loader: this[n(3685)], meshoptDecoder: this[n(1997)] });
    h.fileLoader[n(590)](this.requestHeader);
    for (let f = 0; f < this[n(3592)][n(3105)]; f++) {
      const u = this[n(3592)][f](h);
      o[u[n(3710)]] = u, r[u[n(3710)]] = !![];
    }
    if (a[n(1238)])
      for (let f = 0; f < a.extensionsUsed[n(3105)]; ++f) {
        const u = a[n(1238)][f], l = a[n(563)] || [];
        switch (u) {
          case bx[n(1011)]:
            r[u] = new r3();
            break;
          case bx.KHR_DRACO_MESH_COMPRESSION:
            r[u] = new w3(a, this.dracoLoader);
            break;
          case bx[n(1550)]:
            r[u] = new M3();
            break;
          case bx[n(3446)]:
            r[u] = new S3();
            break;
          default:
            l[n(882)](u) >= 0 && o[u] === void 0 && console[n(3629)](n(3341) + u + '".');
        }
      }
    h[n(2422)](r), h[n(915)](o), h[n(1359)](t, i);
  }
  [s(2384)](e, x) {
    const t = this;
    return new Promise(function(i, n) {
      t.parse(e, x, i, n);
    });
  }
}
function s3() {
  let d = {};
  return { get: function(e) {
    return d[e];
  }, add: function(e, x) {
    d[e] = x;
  }, remove: function(e) {
    delete d[e];
  }, removeAll: function() {
    d = {};
  } };
}
const bx = { KHR_BINARY_GLTF: s(3728), KHR_DRACO_MESH_COMPRESSION: s(1597), KHR_LIGHTS_PUNCTUAL: s(1647), KHR_MATERIALS_CLEARCOAT: s(3031), KHR_MATERIALS_IOR: s(472), KHR_MATERIALS_SHEEN: s(1351), KHR_MATERIALS_SPECULAR: s(1989), KHR_MATERIALS_TRANSMISSION: s(975), KHR_MATERIALS_IRIDESCENCE: s(2676), KHR_MATERIALS_UNLIT: s(2207), KHR_MATERIALS_VOLUME: s(1339), KHR_TEXTURE_BASISU: s(1691), KHR_TEXTURE_TRANSFORM: s(2031), KHR_MESH_QUANTIZATION: "KHR_mesh_quantization", KHR_MATERIALS_EMISSIVE_STRENGTH: s(522), EXT_TEXTURE_WEBP: s(2166), EXT_TEXTURE_AVIF: s(1132), EXT_MESHOPT_COMPRESSION: s(1517), EXT_MESH_GPU_INSTANCING: s(3324) };
class a3 {
  constructor(e) {
    const x = s;
    this[x(1181)] = e, this.name = bx[x(2872)], this[x(2023)] = { refs: {}, uses: {} };
  }
  [s(2176)]() {
    const e = s, x = this[e(1181)], t = this[e(1181)].json[e(1347)] || [];
    for (let i = 0, n = t.length; i < n; i++) {
      const a = t[i];
      a[e(3323)] && a[e(3323)][this[e(3710)]] && a[e(3323)][this.name][e(1288)] !== void 0 && x[e(1624)](this.cache, a[e(3323)][this.name].light);
    }
  }
  [s(1302)](e) {
    const x = s, t = this[x(1181)], i = "light:" + e;
    let n = t[x(2023)][x(3016)](i);
    if (n)
      return n;
    const a = t[x(3143)], r = a[x(3323)] && a[x(3323)][this[x(3710)]] || {}, o = r.lights || [], c = o[e];
    let h;
    const f = new P0(16777215);
    c[x(3282)] !== void 0 && f[x(666)](c.color);
    const u = c[x(3246)] !== void 0 ? c[x(3246)] : 0;
    switch (c.type) {
      case "directional":
        h = new Oa(f), h[x(671)].position[x(1260)](0, 0, -1), h[x(3026)](h[x(671)]);
        break;
      case "point":
        h = new Da(f), h.distance = u;
        break;
      case x(1337):
        h = new xo(f), h[x(1183)] = u, c[x(1337)] = c[x(1337)] || {}, c[x(1337)][x(2678)] = c[x(1337)][x(2678)] !== void 0 ? c[x(1337)][x(2678)] : 0, c.spot[x(681)] = c[x(1337)][x(681)] !== void 0 ? c.spot[x(681)] : Math.PI / 4, h[x(2202)] = c[x(1337)].outerConeAngle, h[x(2276)] = 1 - c.spot[x(2678)] / c[x(1337)][x(681)], h[x(671)][x(3571)][x(1260)](0, 0, -1), h[x(3026)](h[x(671)]);
        break;
      default:
        throw new Error(x(2964) + c[x(566)]);
    }
    return h[x(3571)].set(0, 0, 0), h[x(3411)] = 2, gt(h, c), c.intensity !== void 0 && (h.intensity = c.intensity), h[x(3710)] = t[x(3103)](c[x(3710)] || x(1561) + e), n = Promise[x(3450)](h), t.cache[x(3026)](i, n), n;
  }
  getDependency(e, x) {
    const t = s;
    if (e === t(1288))
      return this[t(1302)](x);
  }
  createNodeAttachment(e) {
    const x = s, t = this, i = this[x(1181)], n = i.json, a = n.nodes[e], r = a[x(3323)] && a.extensions[this[x(3710)]] || {}, o = r[x(1288)];
    return o === void 0 ? null : this[x(1302)](o)[x(1941)](function(c) {
      return i[x(3665)](t.cache, o, c);
    });
  }
}
class r3 {
  constructor() {
    const e = s;
    this[e(3710)] = bx[e(1011)];
  }
  [s(2924)]() {
    return be;
  }
  [s(980)](e, x, t) {
    const i = s, n = [];
    e[i(3282)] = new P0(1, 1, 1), e[i(3746)] = 1;
    const a = x[i(1600)];
    if (a) {
      if (Array.isArray(a[i(527)])) {
        const r = a.baseColorFactor;
        e[i(3282)][i(666)](r), e.opacity = r[3];
      }
      a[i(520)] !== void 0 && n[i(3156)](t.assignTexture(e, i(3644), a.baseColorTexture, _x));
    }
    return Promise[i(3029)](n);
  }
}
class o3 {
  constructor(e) {
    const x = s;
    this.parser = e, this[x(3710)] = bx[x(1129)];
  }
  [s(2303)](e, x) {
    const t = s, i = this[t(1181)], n = i[t(3143)][t(1876)][e];
    if (!n.extensions || !n[t(3323)][this.name])
      return Promise[t(3450)]();
    const a = n[t(3323)][this[t(3710)]].emissiveStrength;
    return a !== void 0 && (x.emissiveIntensity = a), Promise.resolve();
  }
}
class c3 {
  constructor(e) {
    const x = s;
    this.parser = e, this[x(3710)] = bx[x(2094)];
  }
  [s(2924)](e) {
    const x = s, t = this[x(1181)], i = t[x(3143)][x(1876)][e];
    return !i[x(3323)] || !i.extensions[this.name] ? null : ot;
  }
  [s(2303)](e, x) {
    const t = s, i = this.parser, n = i[t(3143)][t(1876)][e];
    if (!n[t(3323)] || !n[t(3323)][this[t(3710)]])
      return Promise.resolve();
    const a = [], r = n[t(3323)][this[t(3710)]];
    if (r[t(3050)] !== void 0 && (x[t(2317)] = r[t(3050)]), r.clearcoatTexture !== void 0 && a[t(3156)](i[t(2239)](x, t(945), r[t(3666)])), r.clearcoatRoughnessFactor !== void 0 && (x[t(1163)] = r[t(3048)]), r.clearcoatRoughnessTexture !== void 0 && a[t(3156)](i[t(2239)](x, t(1660), r[t(1395)])), r[t(3375)] !== void 0 && (a[t(3156)](i[t(2239)](x, t(3674), r[t(3375)])), r[t(3375)][t(2204)] !== void 0)) {
      const o = r.clearcoatNormalTexture.scale;
      x[t(1111)] = new d0(o, o);
    }
    return Promise[t(3029)](a);
  }
}
class d3 {
  constructor(e) {
    const x = s;
    this[x(1181)] = e, this.name = bx[x(2983)];
  }
  [s(2924)](e) {
    const x = s, t = this.parser, i = t[x(3143)][x(1876)][e];
    return !i.extensions || !i[x(3323)][this.name] ? null : ot;
  }
  [s(2303)](e, x) {
    const t = s, i = this[t(1181)], n = i[t(3143)].materials[e];
    if (!n[t(3323)] || !n[t(3323)][this[t(3710)]])
      return Promise[t(3450)]();
    const a = [], r = n[t(3323)][this[t(3710)]];
    return r[t(1751)] !== void 0 && (x[t(3727)] = r.iridescenceFactor), r[t(1161)] !== void 0 && a[t(3156)](i[t(2239)](x, "iridescenceMap", r[t(1161)])), r[t(1510)] !== void 0 && (x.iridescenceIOR = r[t(1510)]), x.iridescenceThicknessRange === void 0 && (x.iridescenceThicknessRange = [100, 400]), r[t(644)] !== void 0 && (x.iridescenceThicknessRange[0] = r[t(644)]), r.iridescenceThicknessMaximum !== void 0 && (x[t(2845)][1] = r[t(2605)]), r[t(3281)] !== void 0 && a[t(3156)](i.assignTexture(x, t(3360), r[t(3281)])), Promise[t(3029)](a);
  }
}
class h3 {
  constructor(e) {
    const x = s;
    this[x(1181)] = e, this.name = bx[x(1059)];
  }
  [s(2924)](e) {
    const x = s, t = this[x(1181)], i = t[x(3143)][x(1876)][e];
    return !i[x(3323)] || !i[x(3323)][this[x(3710)]] ? null : ot;
  }
  [s(2303)](e, x) {
    const t = s, i = this[t(1181)], n = i.json[t(1876)][e];
    if (!n.extensions || !n[t(3323)][this.name])
      return Promise[t(3450)]();
    const a = [];
    x[t(807)] = new P0(0, 0, 0), x.sheenRoughness = 0, x[t(1031)] = 1;
    const r = n[t(3323)][this.name];
    return r[t(3378)] !== void 0 && x[t(807)].fromArray(r[t(3378)]), r[t(3559)] !== void 0 && (x[t(1915)] = r[t(3559)]), r.sheenColorTexture !== void 0 && a[t(3156)](i.assignTexture(x, t(2078), r.sheenColorTexture, _x)), r[t(3020)] !== void 0 && a.push(i.assignTexture(x, t(3168), r.sheenRoughnessTexture)), Promise.all(a);
  }
}
class f3 {
  constructor(e) {
    const x = s;
    this[x(1181)] = e, this[x(3710)] = bx.KHR_MATERIALS_TRANSMISSION;
  }
  [s(2924)](e) {
    const x = s, t = this[x(1181)], i = t[x(3143)][x(1876)][e];
    return !i[x(3323)] || !i.extensions[this[x(3710)]] ? null : ot;
  }
  [s(2303)](e, x) {
    const t = s, i = this[t(1181)], n = i[t(3143)][t(1876)][e];
    if (!n[t(3323)] || !n[t(3323)][this.name])
      return Promise.resolve();
    const a = [], r = n[t(3323)][this[t(3710)]];
    return r.transmissionFactor !== void 0 && (x[t(2123)] = r[t(1459)]), r[t(1074)] !== void 0 && a[t(3156)](i[t(2239)](x, t(2325), r[t(1074)])), Promise[t(3029)](a);
  }
}
class l3 {
  constructor(e) {
    const x = s;
    this[x(1181)] = e, this[x(3710)] = bx[x(3220)];
  }
  [s(2924)](e) {
    const x = s, t = this[x(1181)], i = t.json.materials[e];
    return !i[x(3323)] || !i[x(3323)][this[x(3710)]] ? null : ot;
  }
  [s(2303)](e, x) {
    const t = s, i = this[t(1181)], n = i[t(3143)][t(1876)][e];
    if (!n[t(3323)] || !n[t(3323)][this.name])
      return Promise.resolve();
    const a = [], r = n[t(3323)][this.name];
    x[t(2908)] = r[t(3285)] !== void 0 ? r.thicknessFactor : 0, r[t(1696)] !== void 0 && a[t(3156)](i[t(2239)](x, t(1051), r[t(1696)])), x[t(532)] = r[t(532)] || 1 / 0;
    const o = r[t(2786)] || [1, 1, 1];
    return x[t(2786)] = new P0(o[0], o[1], o[2]), Promise[t(3029)](a);
  }
}
class u3 {
  constructor(e) {
    const x = s;
    this[x(1181)] = e, this.name = bx[x(3668)];
  }
  [s(2924)](e) {
    const x = s, t = this[x(1181)], i = t[x(3143)].materials[e];
    return !i[x(3323)] || !i[x(3323)][this[x(3710)]] ? null : ot;
  }
  [s(2303)](e, x) {
    const t = s, i = this[t(1181)], n = i[t(3143)][t(1876)][e];
    if (!n[t(3323)] || !n[t(3323)][this.name])
      return Promise[t(3450)]();
    const a = n.extensions[this[t(3710)]];
    return x.ior = a.ior !== void 0 ? a[t(3252)] : 1.5, Promise.resolve();
  }
}
class b3 {
  constructor(e) {
    const x = s;
    this[x(1181)] = e, this[x(3710)] = bx.KHR_MATERIALS_SPECULAR;
  }
  [s(2924)](e) {
    const x = s, t = this[x(1181)], i = t[x(3143)][x(1876)][e];
    return !i[x(3323)] || !i[x(3323)][this[x(3710)]] ? null : ot;
  }
  [s(2303)](e, x) {
    const t = s, i = this.parser, n = i.json[t(1876)][e];
    if (!n[t(3323)] || !n[t(3323)][this[t(3710)]])
      return Promise.resolve();
    const a = [], r = n[t(3323)][this[t(3710)]];
    x[t(1354)] = r[t(2584)] !== void 0 ? r[t(2584)] : 1, r[t(720)] !== void 0 && a.push(i[t(2239)](x, t(1581), r[t(720)]));
    const o = r[t(724)] || [1, 1, 1];
    return x[t(3367)] = new P0(o[0], o[1], o[2]), r[t(680)] !== void 0 && a[t(3156)](i[t(2239)](x, "specularColorMap", r[t(680)], _x)), Promise[t(3029)](a);
  }
}
class p3 {
  constructor(e) {
    const x = s;
    this.parser = e, this[x(3710)] = bx[x(3774)];
  }
  [s(3736)](e) {
    const x = s, t = this[x(1181)], i = t[x(3143)], n = i[x(1822)][e];
    if (!n[x(3323)] || !n[x(3323)][this[x(3710)]])
      return null;
    const a = n.extensions[this.name], r = t[x(3459)][x(3685)];
    if (!r) {
      if (i[x(563)] && i[x(563)][x(882)](this[x(3710)]) >= 0)
        throw new Error(x(1932));
      return null;
    }
    return t[x(1437)](e, a.source, r);
  }
}
class m3 {
  constructor(e) {
    const x = s;
    this.parser = e, this[x(3710)] = bx.EXT_TEXTURE_WEBP, this[x(2124)] = null;
  }
  [s(3736)](e) {
    const x = s, t = this[x(3710)], i = this[x(1181)], n = i.json, a = n[x(1822)][e];
    if (!a[x(3323)] || !a[x(3323)][t])
      return null;
    const r = a[x(3323)][t], o = n[x(1090)][r[x(796)]];
    let c = i[x(2881)];
    if (o[x(3658)]) {
      const h = i[x(3459)].manager[x(2129)](o[x(3658)]);
      h !== null && (c = h);
    }
    return this[x(1029)]().then(function(h) {
      const f = x;
      if (h)
        return i.loadTextureImage(e, r[f(796)], c);
      if (n[f(563)] && n[f(563)][f(882)](t) >= 0)
        throw new Error(f(1732));
      return i[f(3736)](e);
    });
  }
  detectSupport() {
    const e = s;
    return !this.isSupported && (this[e(2124)] = new Promise(function(x) {
      const t = e, i = new Image();
      i.src = t(1425), i[t(821)] = i[t(464)] = function() {
        x(i.height === 1);
      };
    })), this.isSupported;
  }
}
class g3 {
  constructor(e) {
    const x = s;
    this.parser = e, this[x(3710)] = bx[x(3216)], this.isSupported = null;
  }
  loadTexture(e) {
    const x = s, t = this[x(3710)], i = this[x(1181)], n = i[x(3143)], a = n[x(1822)][e];
    if (!a[x(3323)] || !a.extensions[t])
      return null;
    const r = a.extensions[t], o = n.images[r[x(796)]];
    let c = i.textureLoader;
    if (o[x(3658)]) {
      const h = i[x(3459)][x(3235)][x(2129)](o[x(3658)]);
      h !== null && (c = h);
    }
    return this.detectSupport()[x(1941)](function(h) {
      const f = x;
      if (h)
        return i[f(1437)](e, r[f(796)], c);
      if (n[f(563)] && n[f(563)][f(882)](t) >= 0)
        throw new Error(f(2211));
      return i.loadTexture(e);
    });
  }
  [s(1029)]() {
    const e = s;
    return !this[e(2124)] && (this.isSupported = new Promise(function(x) {
      const t = e, i = new Image();
      i[t(3095)] = t(2936), i[t(821)] = i[t(464)] = function() {
        x(i[t(1674)] === 1);
      };
    })), this.isSupported;
  }
}
class _3 {
  constructor(e) {
    const x = s;
    this[x(3710)] = bx[x(1652)], this[x(1181)] = e;
  }
  loadBufferView(e) {
    const x = s, t = this.parser[x(3143)], i = t[x(3440)][e];
    if (i[x(3323)] && i[x(3323)][this[x(3710)]]) {
      const n = i[x(3323)][this.name], a = this[x(1181)].getDependency(x(2770), n[x(2770)]), r = this[x(1181)][x(3459)][x(1997)];
      if (!r || !r[x(2071)]) {
        if (t[x(563)] && t.extensionsRequired[x(882)](this[x(3710)]) >= 0)
          throw new Error(x(2865));
        return null;
      }
      return a[x(1941)](function(o) {
        const c = x, h = n[c(2151)] || 0, f = n[c(3247)] || 0, u = n.count, l = n[c(2033)], _ = new Uint8Array(o, h, f);
        return r[c(2692)] ? r[c(2692)](u, l, _, n.mode, n.filter).then(function(p) {
          return p.buffer;
        }) : r[c(1101)][c(1941)](function() {
          const p = c, m = new ArrayBuffer(u * l);
          return r[p(813)](new Uint8Array(m), u, l, _, n[p(3753)], n[p(3587)]), m;
        });
      });
    } else
      return null;
  }
}
class v3 {
  constructor(e) {
    const x = s;
    this[x(3710)] = bx.EXT_MESH_GPU_INSTANCING, this.parser = e;
  }
  createNodeMesh(e) {
    const x = s, t = this[x(1181)][x(3143)], i = t[x(1347)][e];
    if (!i[x(3323)] || !i[x(3323)][this[x(3710)]] || i[x(2939)] === void 0)
      return null;
    const n = t[x(1501)][i[x(2939)]];
    for (const h of n[x(1614)])
      if (h.mode !== Se[x(3649)] && h[x(3753)] !== Se[x(1810)] && h.mode !== Se[x(2212)] && h.mode !== void 0)
        return null;
    const a = i[x(3323)][this[x(3710)]], r = a[x(3265)], o = [], c = {};
    for (const h in r)
      o[x(3156)](this[x(1181)].getDependency("accessor", r[h])[x(1941)]((f) => (c[h] = f, c[h])));
    return o[x(3105)] < 1 ? null : (o[x(3156)](this.parser[x(3074)](e)), Promise[x(3029)](o).then((h) => {
      const f = x, u = h[f(465)](), l = u[f(801)] ? u[f(3049)] : [u], _ = h[0][f(1267)], p = [];
      for (const m of l) {
        const y = new ix(), v = new z(), g = new $x(), b = new z(1, 1, 1), M = new z2(m.geometry, m.material, _);
        for (let A = 0; A < _; A++)
          c[f(1527)] && v[f(804)](c[f(1527)], A), c[f(3673)] && g[f(804)](c[f(3673)], A), c[f(514)] && b[f(804)](c[f(514)], A), M[f(3651)](A, y[f(1825)](v, g, b));
        for (const A in c)
          A !== f(1527) && A !== f(3673) && A !== f(514) && m[f(1353)][f(3599)](A, c[A]);
        px[f(2028)][f(2875)][f(1656)](M, m), M[f(3431)] = ![], this[f(1181)].assignFinalMaterial(M), p[f(3156)](M);
      }
      return u[f(801)] ? (u.clear(), u[f(3026)](...p), u) : p[0];
    }));
  }
}
const Vh = "glTF", _n = 12, Lc = { JSON: 1313821514, BIN: 5130562 };
class y3 {
  constructor(e) {
    const x = s;
    this[x(3710)] = bx[x(2115)], this[x(1040)] = null, this[x(1698)] = null;
    const t = new DataView(e, 0, _n), i = new TextDecoder();
    if (this[x(2883)] = { magic: i[x(528)](new Uint8Array(e.slice(0, 4))), version: t[x(2114)](4, !![]), length: t[x(2114)](8, !![]) }, this.header[x(2284)] !== Vh)
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this[x(2883)][x(2185)] < 2)
      throw new Error(x(1615));
    const n = this[x(2883)][x(3105)] - _n, a = new DataView(e, _n);
    let r = 0;
    for (; r < n; ) {
      const o = a.getUint32(r, !![]);
      r += 4;
      const c = a[x(2114)](r, !![]);
      if (r += 4, c === Lc[x(1160)]) {
        const h = new Uint8Array(e, _n + r, o);
        this.content = i[x(528)](h);
      } else if (c === Lc.BIN) {
        const h = _n + r;
        this[x(1698)] = e.slice(h, h + o);
      }
      r += o;
    }
    if (this.content === null)
      throw new Error(x(2052));
  }
}
class w3 {
  constructor(e, x) {
    const t = s;
    if (!x)
      throw new Error(t(1390));
    this[t(3710)] = bx[t(3715)], this[t(3143)] = e, this.dracoLoader = x, this[t(3186)][t(1868)]();
  }
  [s(581)](e, x) {
    const t = s, i = this[t(3143)], n = this[t(3186)], a = e[t(3323)][this.name].bufferView, r = e[t(3323)][this.name][t(3265)], o = {}, c = {}, h = {};
    for (const f in r) {
      const u = h2[f] || f[t(2050)]();
      o[u] = r[f];
    }
    for (const f in e[t(3265)]) {
      const u = h2[f] || f[t(2050)]();
      if (r[f] !== void 0) {
        const l = i[t(2468)][e.attributes[f]], _ = Fi[l[t(1113)]];
        h[u] = _[t(3710)], c[u] = l[t(3320)] === !![];
      }
    }
    return x[t(846)](t(682), a)[t(1941)](function(f) {
      return new Promise(function(u) {
        const l = c0;
        n[l(1150)](f, function(_) {
          const p = l;
          for (const m in _[p(3265)]) {
            const y = _[p(3265)][m], v = c[m];
            v !== void 0 && (y[p(3320)] = v);
          }
          u(_);
        }, o, h);
      });
    });
  }
}
class M3 {
  constructor() {
    const e = s;
    this[e(3710)] = bx[e(1550)];
  }
  [s(2400)](e, x) {
    const t = s;
    return x.texCoord !== void 0 && console[t(3629)](t(1736) + this[t(3710)] + t(1808)), x[t(592)] === void 0 && x[t(591)] === void 0 && x.scale === void 0 || (e = e[t(2272)](), x.offset !== void 0 && e[t(592)][t(666)](x[t(592)]), x[t(591)] !== void 0 && (e[t(591)] = x.rotation), x[t(2204)] !== void 0 && e[t(2806)].fromArray(x[t(2204)]), e[t(3035)] = !![]), e;
  }
}
class S3 {
  constructor() {
    const e = s;
    this[e(3710)] = bx.KHR_MESH_QUANTIZATION;
  }
}
class Wh extends nn {
  constructor(e, x, t, i) {
    super(e, x, t, i);
  }
  [s(1841)](e) {
    const x = s, t = this[x(902)], i = this[x(3089)], n = this[x(814)], a = e * n * 3 + n;
    for (let r = 0; r !== n; r++)
      t[r] = i[a + r];
    return t;
  }
  [s(2513)](e, x, t, i) {
    const n = s, a = this[n(902)], r = this[n(3089)], o = this[n(814)], c = o * 2, h = o * 3, f = i - x, u = (t - x) / f, l = u * u, _ = l * u, p = e * h, m = p - h, y = -2 * _ + 3 * l, v = _ - l, g = 1 - y, b = v - l + u;
    for (let M = 0; M !== o; M++) {
      const A = r[m + M + o], L = r[m + M + c] * f, P = r[p + M + o], S = r[p + M] * f;
      a[M] = g * A + b * L + y * P + v * S;
    }
    return a;
  }
}
const T3 = new $x();
class E3 extends Wh {
  [s(2513)](e, x, t, i) {
    const n = s, a = super[n(2513)](e, x, t, i);
    return T3[n(666)](a).normalize()[n(1496)](a), a;
  }
}
const Se = { FLOAT: 5126, FLOAT_MAT3: 35675, FLOAT_MAT4: 35676, FLOAT_VEC2: 35664, FLOAT_VEC3: 35665, FLOAT_VEC4: 35666, LINEAR: 9729, REPEAT: 10497, SAMPLER_2D: 35678, POINTS: 0, LINES: 1, LINE_LOOP: 2, LINE_STRIP: 3, TRIANGLES: 4, TRIANGLE_STRIP: 5, TRIANGLE_FAN: 6, UNSIGNED_BYTE: 5121, UNSIGNED_SHORT: 5123 }, Fi = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array }, Rc = { 9728: Bx, 9729: Cx, 9984: In, 9985: ga, 9986: Ui, 9987: qe }, Pc = { 33071: Zx, 33648: Hi, 10497: Et }, gr = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 }, h2 = { POSITION: s(3571), NORMAL: s(2111), TANGENT: s(3404), TEXCOORD_0: "uv", TEXCOORD_1: s(1166), COLOR_0: s(3282), WEIGHTS_0: s(3441), JOINTS_0: s(3625) }, ut = { scale: s(2204), translation: s(3571), rotation: s(3055), weights: s(2072) }, A3 = { CUBICSPLINE: void 0, LINEAR: ai, STEP: ki }, _r = { OPAQUE: "OPAQUE", MASK: "MASK", BLEND: s(1994) };
function C3(d) {
  const e = s;
  return d.DefaultMaterial === void 0 && (d.DefaultMaterial = new os({ color: 16777215, emissive: 0, metalness: 1, roughness: 1, transparent: ![], depthTest: !![], side: Xe })), d[e(2629)];
}
function vn(d, e, x) {
  const t = s;
  for (const i in x[t(3323)])
    d[i] === void 0 && (e[t(2066)].gltfExtensions = e[t(2066)][t(1357)] || {}, e[t(2066)][t(1357)][i] = x.extensions[i]);
}
function gt(d, e) {
  const x = s;
  e.extras !== void 0 && (typeof e.extras == "object" ? Object[x(1188)](d[x(2066)], e[x(3101)]) : console[x(3629)](x(863) + e[x(3101)]));
}
function L3(d, e, x) {
  const t = s;
  let i = ![], n = ![], a = ![];
  for (let h = 0, f = e[t(3105)]; h < f; h++) {
    const u = e[h];
    if (u[t(2218)] !== void 0 && (i = !![]), u[t(3339)] !== void 0 && (n = !![]), u[t(1069)] !== void 0 && (a = !![]), i && n && a)
      break;
  }
  if (!i && !n && !a)
    return Promise[t(3450)](d);
  const r = [], o = [], c = [];
  for (let h = 0, f = e.length; h < f; h++) {
    const u = e[h];
    if (i) {
      const l = u.POSITION !== void 0 ? x[t(846)]("accessor", u.POSITION) : d[t(3265)][t(3571)];
      r[t(3156)](l);
    }
    if (n) {
      const l = u[t(3339)] !== void 0 ? x.getDependency(t(2608), u[t(3339)]) : d.attributes.normal;
      o[t(3156)](l);
    }
    if (a) {
      const l = u[t(1069)] !== void 0 ? x[t(846)](t(2608), u[t(1069)]) : d[t(3265)][t(3282)];
      c[t(3156)](l);
    }
  }
  return Promise.all([Promise.all(r), Promise[t(3029)](o), Promise.all(c)]).then(function(h) {
    const f = t, u = h[0], l = h[1], _ = h[2];
    return i && (d[f(1034)][f(3571)] = u), n && (d[f(1034)][f(2111)] = l), a && (d[f(1034)][f(3282)] = _), d.morphTargetsRelative = !![], d;
  });
}
function R3(d, e) {
  const x = s;
  if (d[x(697)](), e[x(3012)] !== void 0)
    for (let t = 0, i = e[x(3012)].length; t < i; t++)
      d[x(2072)][t] = e[x(3012)][t];
  if (e[x(3101)] && Array[x(1609)](e[x(3101)][x(3108)])) {
    const t = e[x(3101)][x(3108)];
    if (d[x(2072)].length === t[x(3105)]) {
      d[x(3398)] = {};
      for (let i = 0, n = t.length; i < n; i++)
        d[x(3398)][t[i]] = i;
    } else
      console[x(3629)]("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
  }
}
function P3(d) {
  const e = s, x = d[e(3323)] && d[e(3323)][bx[e(3715)]];
  let t;
  return x ? t = e(2804) + x[e(682)] + ":" + x.indices + ":" + Ic(x[e(3265)]) : t = d[e(3198)] + ":" + Ic(d[e(3265)]) + ":" + d[e(3753)], t;
}
function Ic(d) {
  const e = s;
  let x = "";
  const t = Object.keys(d)[e(614)]();
  for (let i = 0, n = t[e(3105)]; i < n; i++)
    x += t[i] + ":" + d[t[i]] + ";";
  return x;
}
function f2(d) {
  const e = s;
  switch (d) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error(e(2195));
  }
}
function I3(d) {
  const e = s;
  return d[e(3343)](/\.jpe?g($|\?)/i) > 0 || d[e(3343)](/^data\:image\/jpeg/) === 0 ? e(1294) : d[e(3343)](/\.webp($|\?)/i) > 0 || d.search(/^data\:image\/webp/) === 0 ? e(1379) : "image/png";
}
const D3 = new ix();
class O3 {
  constructor(e = {}, x = {}) {
    const t = s;
    this[t(3143)] = e, this.extensions = {}, this.plugins = {}, this.options = x, this[t(2023)] = new s3(), this.associations = /* @__PURE__ */ new Map(), this[t(3263)] = {}, this[t(1017)] = {}, this[t(3015)] = { refs: {}, uses: {} }, this[t(607)] = { refs: {}, uses: {} }, this[t(1412)] = { refs: {}, uses: {} }, this[t(1450)] = {}, this[t(1452)] = {}, this[t(2430)] = {};
    let i = ![], n = ![], a = -1;
    typeof navigator !== t(2011) && (i = /^((?!chrome|android).)*safari/i.test(navigator[t(3490)]) === !![], n = navigator.userAgent[t(882)]("Firefox") > -1, a = n ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), typeof createImageBitmap === t(2011) || i || n && a < 98 ? this.textureLoader = new Ch(this[t(3459)][t(3235)]) : this[t(2881)] = new Oh(this.options[t(3235)]), this[t(2881)][t(1086)](this.options[t(2825)]), this[t(2881)][t(590)](this.options[t(1283)]), this[t(1114)] = new ye(this[t(3459)][t(3235)]), this.fileLoader[t(2624)]("arraybuffer"), this.options[t(2825)] === t(2594) && this[t(1114)][t(2958)](!![]);
  }
  [s(2422)](e) {
    const x = s;
    this[x(3323)] = e;
  }
  [s(915)](e) {
    const x = s;
    this[x(3187)] = e;
  }
  [s(1359)](e, x) {
    const t = s, i = this, n = this[t(3143)], a = this.extensions;
    this[t(2023)].removeAll(), this[t(1017)] = {}, this._invokeAll(function(r) {
      const o = t;
      return r[o(2176)] && r[o(2176)]();
    }), Promise.all(this._invokeAll(function(r) {
      const o = t;
      return r[o(430)] && r[o(430)]();
    }))[t(1941)](function() {
      const r = t;
      return Promise[r(3029)]([i[r(1875)](r(662)), i[r(1875)](r(2956)), i[r(1875)](r(2189))]);
    })[t(1941)](function(r) {
      const o = t, c = { scene: r[0][n[o(662)] || 0], scenes: r[0], animations: r[1], cameras: r[2], asset: n[o(1991)], parser: i, userData: {} };
      vn(a, c, n), gt(c, n), Promise[o(3029)](i[o(3257)](function(h) {
        const f = o;
        return h[f(2098)] && h[f(2098)](c);
      }))[o(1941)](function() {
        e(c);
      });
    })[t(747)](x);
  }
  [s(2176)]() {
    const e = s, x = this[e(3143)][e(1347)] || [], t = this[e(3143)][e(2674)] || [], i = this[e(3143)][e(1501)] || [];
    for (let n = 0, a = t[e(3105)]; n < a; n++) {
      const r = t[n][e(1205)];
      for (let o = 0, c = r.length; o < c; o++)
        x[r[o]][e(1317)] = !![];
    }
    for (let n = 0, a = x[e(3105)]; n < a; n++) {
      const r = x[n];
      r[e(2939)] !== void 0 && (this._addNodeRef(this[e(3015)], r[e(2939)]), r[e(1687)] !== void 0 && (i[r[e(2939)]][e(1918)] = !![])), r.camera !== void 0 && this[e(1624)](this[e(607)], r[e(2189)]);
    }
  }
  [s(1624)](e, x) {
    const t = s;
    x !== void 0 && (e[t(3768)][x] === void 0 && (e.refs[x] = e[t(1746)][x] = 0), e[t(3768)][x]++);
  }
  _getNodeRef(e, x, t) {
    const i = s;
    if (e[i(3768)][x] <= 1)
      return t;
    const n = t[i(2272)](), a = (r, o) => {
      const c = i, h = this[c(1384)].get(r);
      h != null && this.associations[c(1260)](o, h);
      for (const [f, u] of r[c(3049)][c(1196)]())
        a(u, o[c(3049)][f]);
    };
    return a(t, n), n[i(3710)] += i(3743) + e[i(1746)][x]++, n;
  }
  _invokeOne(e) {
    const x = s, t = Object[x(910)](this[x(3187)]);
    t[x(3156)](this);
    for (let i = 0; i < t.length; i++) {
      const n = e(t[i]);
      if (n)
        return n;
    }
    return null;
  }
  [s(3257)](e) {
    const x = s, t = Object[x(910)](this[x(3187)]);
    t[x(2248)](this);
    const i = [];
    for (let n = 0; n < t[x(3105)]; n++) {
      const a = e(t[n]);
      a && i[x(3156)](a);
    }
    return i;
  }
  [s(846)](e, x) {
    const t = s, i = e + ":" + x;
    let n = this[t(2023)][t(3016)](i);
    if (!n) {
      switch (e) {
        case "scene":
          n = this.loadScene(x);
          break;
        case t(3792):
          n = this[t(1340)](function(a) {
            const r = t;
            return a[r(1937)] && a[r(1937)](x);
          });
          break;
        case t(2939):
          n = this[t(1340)](function(a) {
            const r = t;
            return a[r(1854)] && a[r(1854)](x);
          });
          break;
        case t(2608):
          n = this[t(2896)](x);
          break;
        case t(682):
          n = this._invokeOne(function(a) {
            const r = t;
            return a[r(798)] && a[r(798)](x);
          });
          break;
        case t(2770):
          n = this[t(661)](x);
          break;
        case t(1870):
          n = this[t(1340)](function(a) {
            const r = t;
            return a.loadMaterial && a[r(444)](x);
          });
          break;
        case t(2431):
          n = this[t(1340)](function(a) {
            const r = t;
            return a.loadTexture && a[r(3736)](x);
          });
          break;
        case t(1687):
          n = this.loadSkin(x);
          break;
        case t(2956):
          n = this[t(1340)](function(a) {
            const r = t;
            return a[r(1524)] && a[r(1524)](x);
          });
          break;
        case "camera":
          n = this[t(1587)](x);
          break;
        default:
          if (n = this[t(1340)](function(a) {
            const r = t;
            return a != this && a[r(846)] && a[r(846)](e, x);
          }), !n)
            throw new Error(t(2380) + e);
          break;
      }
      this[t(2023)][t(3026)](i, n);
    }
    return n;
  }
  [s(1875)](e) {
    const x = s;
    let t = this[x(2023)][x(3016)](e);
    if (!t) {
      const i = this, n = this[x(3143)][e + (e === x(2939) ? "es" : "s")] || [];
      t = Promise[x(3029)](n[x(3644)](function(a, r) {
        return i[x(846)](e, r);
      })), this[x(2023)].add(e, t);
    }
    return t;
  }
  [s(661)](e) {
    const x = s, t = this.json[x(2563)][e], i = this[x(1114)];
    if (t.type && t[x(566)] !== x(1756))
      throw new Error(x(2574) + t[x(566)] + x(2967));
    if (t[x(3658)] === void 0 && e === 0)
      return Promise[x(3450)](this[x(3323)][bx[x(2115)]][x(1698)]);
    const n = this[x(3459)];
    return new Promise(function(a, r) {
      const o = x;
      i.load(Yi.resolveURL(t[o(3658)], n.path), a, void 0, function() {
        const c = o;
        r(new Error(c(1358) + t[c(3658)] + '".'));
      });
    });
  }
  [s(798)](e) {
    const x = s, t = this.json.bufferViews[e];
    return this[x(846)](x(2770), t[x(2770)])[x(1941)](function(i) {
      const n = x, a = t.byteLength || 0, r = t[n(2151)] || 0;
      return i[n(3482)](r, r + a);
    });
  }
  [s(2896)](e) {
    const x = s, t = this, i = this[x(3143)], n = this[x(3143)][x(2468)][e];
    if (n.bufferView === void 0 && n[x(2476)] === void 0) {
      const r = gr[n[x(566)]], o = Fi[n.componentType], c = n.normalized === !![], h = new o(n[x(1267)] * r);
      return Promise[x(3450)](new gx(h, r, c));
    }
    const a = [];
    return n[x(682)] !== void 0 ? a.push(this.getDependency(x(682), n[x(682)])) : a[x(3156)](null), n[x(2476)] !== void 0 && (a[x(3156)](this.getDependency(x(682), n.sparse[x(3198)].bufferView)), a[x(3156)](this[x(846)]("bufferView", n.sparse[x(910)][x(682)]))), Promise.all(a)[x(1941)](function(r) {
      const o = x, c = r[0], h = gr[n[o(566)]], f = Fi[n[o(1113)]], u = f[o(2823)], l = u * h, _ = n[o(2151)] || 0, p = n[o(682)] !== void 0 ? i[o(3440)][n.bufferView][o(2033)] : void 0, m = n.normalized === !![];
      let y, v;
      if (p && p !== l) {
        const g = Math[o(2697)](_ / p), b = o(2985) + n[o(682)] + ":" + n.componentType + ":" + g + ":" + n.count;
        let M = t[o(2023)][o(3016)](b);
        !M && (y = new f(c, g * p, n.count * p / u), M = new Yn(y, p / u), t[o(2023)][o(3026)](b, M)), v = new Ct(M, h, _ % p / u, m);
      } else
        c === null ? y = new f(n[o(1267)] * h) : y = new f(c, _, n.count * h), v = new gx(y, h, m);
      if (n.sparse !== void 0) {
        const g = gr[o(1013)], b = Fi[n[o(2476)][o(3198)][o(1113)]], M = n[o(2476)][o(3198)][o(2151)] || 0, A = n[o(2476)][o(910)][o(2151)] || 0, L = new b(r[1], M, n[o(2476)].count * g), P = new f(r[2], A, n[o(2476)][o(1267)] * h);
        c !== null && (v = new gx(v[o(2712)][o(3482)](), v[o(3290)], v[o(3320)]));
        for (let S = 0, I = L.length; S < I; S++) {
          const C = L[S];
          if (v.setX(C, P[S * h]), h >= 2 && v[o(712)](C, P[S * h + 1]), h >= 3 && v.setZ(C, P[S * h + 2]), h >= 4 && v[o(2934)](C, P[S * h + 3]), h >= 5)
            throw new Error(o(3561));
        }
      }
      return v;
    });
  }
  [s(3736)](e) {
    const x = s, t = this[x(3143)], i = this.options, n = t[x(1822)][e], a = n[x(796)], r = t[x(1090)][a];
    let o = this[x(2881)];
    if (r[x(3658)]) {
      const c = i.manager.getHandler(r[x(3658)]);
      c !== null && (o = c);
    }
    return this[x(1437)](e, a, o);
  }
  [s(1437)](e, x, t) {
    const i = s, n = this, a = this[i(3143)], r = a.textures[e], o = a[i(1090)][x], c = (o[i(3658)] || o[i(682)]) + ":" + r.sampler;
    if (this.textureCache[c])
      return this.textureCache[c];
    const h = this[i(3051)](x, t)[i(1941)](function(f) {
      const u = i;
      f[u(1739)] = ![], f[u(3710)] = r[u(3710)] || o[u(3710)] || "";
      const l = a[u(424)] || {}, _ = l[r[u(2783)]] || {};
      return f[u(999)] = Rc[_[u(999)]] || Cx, f.minFilter = Rc[_[u(991)]] || qe, f[u(578)] = Pc[_[u(578)]] || Et, f.wrapT = Pc[_.wrapT] || Et, n[u(1384)].set(f, { textures: e }), f;
    })[i(747)](function() {
      return null;
    });
    return this[i(1452)][c] = h, h;
  }
  [s(3051)](e, x) {
    const t = s, i = this, n = this[t(3143)], a = this[t(3459)];
    if (this[t(1450)][e] !== void 0)
      return this[t(1450)][e].then((u) => u[t(2272)]());
    const r = n[t(1090)][e], o = self[t(568)] || self[t(2545)];
    let c = r[t(3658)] || "", h = ![];
    if (r.bufferView !== void 0)
      c = i.getDependency(t(682), r[t(682)])[t(1941)](function(u) {
        const l = t;
        h = !![];
        const _ = new Blob([u], { type: r[l(3608)] });
        return c = o[l(2076)](_), c;
      });
    else if (r[t(3658)] === void 0)
      throw new Error(t(1537) + e + t(2451));
    const f = Promise.resolve(c)[t(1941)](function(u) {
      return new Promise(function(l, _) {
        const p = c0;
        let m = l;
        x.isImageBitmapLoader === !![] && (m = function(y) {
          const v = c0, g = new Ux(y);
          g[v(3035)] = !![], l(g);
        }), x[p(3442)](Yi.resolveURL(u, a[p(597)]), m, void 0, _);
      });
    })[t(1941)](function(u) {
      const l = t;
      return h === !![] && o[l(460)](c), u.userData[l(3608)] = r[l(3608)] || I3(r[l(3658)]), u;
    })[t(747)](function(u) {
      const l = t;
      throw console[l(533)](l(2596), c), u;
    });
    return this[t(1450)][e] = f, f;
  }
  [s(2239)](e, x, t, i) {
    const n = s, a = this;
    return this[n(846)]("texture", t[n(3678)])[n(1941)](function(r) {
      const o = n;
      if (!r)
        return null;
      if (t[o(1855)] !== void 0 && t.texCoord != 0 && !(x === "aoMap" && t[o(1855)] == 1) && console[o(3629)]("THREE.GLTFLoader: Custom UV set " + t.texCoord + " for texture " + x + o(2755)), a[o(3323)][bx.KHR_TEXTURE_TRANSFORM]) {
        const c = t[o(3323)] !== void 0 ? t.extensions[bx.KHR_TEXTURE_TRANSFORM] : void 0;
        if (c) {
          const h = a[o(1384)][o(3016)](r);
          r = a[o(3323)][bx[o(1550)]][o(2400)](r, c), a.associations[o(1260)](r, h);
        }
      }
      return i !== void 0 && (r[o(523)] = i), e[x] = r, r;
    });
  }
  [s(3447)](e) {
    const x = s, t = e[x(1353)];
    let i = e[x(1870)];
    const n = t[x(3265)][x(3404)] === void 0, a = t.attributes[x(3282)] !== void 0, r = t[x(3265)][x(2111)] === void 0;
    if (e[x(3114)]) {
      const o = "PointsMaterial:" + i[x(3104)];
      let c = this[x(2023)].get(o);
      !c && (c = new La(), jx[x(2028)][x(2875)][x(1656)](c, i), c.color[x(2875)](i[x(3282)]), c[x(3644)] = i.map, c[x(2907)] = ![], this[x(2023)].add(o, c)), i = c;
    } else if (e[x(725)]) {
      const o = "LineBasicMaterial:" + i[x(3104)];
      let c = this[x(2023)].get(o);
      !c && (c = new te(), jx.prototype[x(2875)][x(1656)](c, i), c[x(3282)][x(2875)](i[x(3282)]), this[x(2023)][x(3026)](o, c)), i = c;
    }
    if (n || a || r) {
      let o = "ClonedMaterial:" + i.uuid + ":";
      n && (o += x(2333)), a && (o += x(1310)), r && (o += "flat-shading:");
      let c = this[x(2023)][x(3016)](o);
      c || (c = i[x(2272)](), a && (c[x(3530)] = !![]), r && (c[x(1529)] = !![]), n && (c[x(2650)] && (c[x(2650)].y *= -1), c[x(1111)] && (c[x(1111)].y *= -1)), this[x(2023)][x(3026)](o, c), this[x(1384)].set(c, this[x(1384)][x(3016)](i))), i = c;
    }
    i.aoMap && t[x(3265)][x(1166)] === void 0 && t[x(3265)].uv !== void 0 && t[x(3599)](x(1166), t[x(3265)].uv), e[x(1870)] = i;
  }
  [s(2924)]() {
    return os;
  }
  [s(444)](e) {
    const x = s, t = this, i = this[x(3143)], n = this.extensions, a = i.materials[e];
    let r;
    const o = {}, c = a[x(3323)] || {}, h = [];
    if (c[bx.KHR_MATERIALS_UNLIT]) {
      const u = n[bx[x(1011)]];
      r = u.getMaterialType(), h[x(3156)](u[x(980)](o, a, t));
    } else {
      const u = a[x(1600)] || {};
      if (o[x(3282)] = new P0(1, 1, 1), o.opacity = 1, Array.isArray(u[x(527)])) {
        const l = u[x(527)];
        o[x(3282)].fromArray(l), o[x(3746)] = l[3];
      }
      u[x(520)] !== void 0 && h[x(3156)](t[x(2239)](o, "map", u[x(520)], _x)), o[x(1586)] = u.metallicFactor !== void 0 ? u.metallicFactor : 1, o[x(771)] = u[x(2766)] !== void 0 ? u[x(2766)] : 1, u[x(475)] !== void 0 && (h.push(t[x(2239)](o, x(989), u.metallicRoughnessTexture)), h[x(3156)](t.assignTexture(o, x(3213), u[x(475)]))), r = this[x(1340)](function(l) {
        const _ = x;
        return l[_(2924)] && l[_(2924)](e);
      }), h[x(3156)](Promise.all(this._invokeAll(function(l) {
        const _ = x;
        return l[_(2303)] && l[_(2303)](e, o);
      })));
    }
    a[x(2481)] === !![] && (o[x(679)] = ke);
    const f = a[x(3291)] || _r[x(743)];
    if (f === _r[x(1994)] ? (o[x(1885)] = !![], o[x(3307)] = ![]) : (o[x(1885)] = ![], f === _r[x(2661)] && (o[x(3303)] = a.alphaCutoff !== void 0 ? a.alphaCutoff : 0.5)), a[x(2628)] !== void 0 && r !== be && (h[x(3156)](t[x(2239)](o, "normalMap", a[x(2628)])), o[x(2650)] = new d0(1, 1), a[x(2628)].scale !== void 0)) {
      const u = a[x(2628)][x(2204)];
      o[x(2650)][x(1260)](u, u);
    }
    return a[x(1328)] !== void 0 && r !== be && (h[x(3156)](t[x(2239)](o, x(2107), a[x(1328)])), a.occlusionTexture.strength !== void 0 && (o.aoMapIntensity = a[x(1328)][x(3218)])), a.emissiveFactor !== void 0 && r !== be && (o[x(1599)] = new P0()[x(666)](a[x(664)])), a[x(2227)] !== void 0 && r !== be && h[x(3156)](t.assignTexture(o, x(2730), a[x(2227)], _x)), Promise[x(3029)](h)[x(1941)](function() {
      const u = x, l = new r(o);
      return a[u(3710)] && (l[u(3710)] = a[u(3710)]), gt(l, a), t[u(1384)][u(1260)](l, { materials: e }), a[u(3323)] && vn(n, l, a), l;
    });
  }
  createUniqueName(e) {
    const x = s, t = ux[x(3377)](e || "");
    let i = t;
    for (let n = 1; this.nodeNamesUsed[i]; ++n)
      i = t + "_" + n;
    return this[x(2430)][i] = !![], i;
  }
  [s(3211)](e) {
    const x = s, t = this, i = this[x(3323)], n = this[x(3263)];
    function a(o) {
      const c = x;
      return i[bx[c(3715)]][c(581)](o, t)[c(1941)](function(h) {
        return Dc(h, o, t);
      });
    }
    const r = [];
    for (let o = 0, c = e[x(3105)]; o < c; o++) {
      const h = e[o], f = P3(h), u = n[f];
      if (u)
        r[x(3156)](u[x(1311)]);
      else {
        let l;
        h.extensions && h[x(3323)][bx[x(3715)]] ? l = a(h) : l = Dc(new ox(), h, t), n[f] = { primitive: h, promise: l }, r.push(l);
      }
    }
    return Promise[x(3029)](r);
  }
  [s(1854)](e) {
    const x = s, t = this, i = this[x(3143)], n = this[x(3323)], a = i.meshes[e], r = a[x(1614)], o = [];
    for (let c = 0, h = r[x(3105)]; c < h; c++) {
      const f = r[c][x(1870)] === void 0 ? C3(this[x(2023)]) : this[x(846)](x(1870), r[c][x(1870)]);
      o[x(3156)](f);
    }
    return o.push(t.loadGeometries(r)), Promise[x(3029)](o).then(function(c) {
      const h = x, f = c[h(3482)](0, c[h(3105)] - 1), u = c[c[h(3105)] - 1], l = [];
      for (let p = 0, m = u.length; p < m; p++) {
        const y = u[p], v = r[p];
        let g;
        const b = f[p];
        if (v.mode === Se[h(3649)] || v[h(3753)] === Se[h(1810)] || v[h(3753)] === Se[h(2212)] || v.mode === void 0)
          g = a[h(1918)] === !![] ? new U2(y, b) : new Wx(y, b), g[h(1918)] === !![] && g[h(2197)](), v[h(3753)] === Se[h(1810)] ? g[h(1353)] = Cc(g[h(1353)], S2) : v[h(3753)] === Se.TRIANGLE_FAN && (g[h(1353)] = Cc(g[h(1353)], la));
        else if (v.mode === Se[h(3242)])
          g = new Ue(y, b);
        else if (v[h(3753)] === Se[h(917)])
          g = new st(y, b);
        else if (v[h(3753)] === Se.LINE_LOOP)
          g = new B2(y, b);
        else if (v[h(3753)] === Se.POINTS)
          g = new F2(y, b);
        else
          throw new Error(h(3352) + v[h(3753)]);
        Object.keys(g.geometry[h(1034)])[h(3105)] > 0 && R3(g, a), g[h(3710)] = t.createUniqueName(a[h(3710)] || h(2813) + e), gt(g, a), v[h(3323)] && vn(n, g, v), t[h(3447)](g), l[h(3156)](g);
      }
      for (let p = 0, m = l[h(3105)]; p < m; p++)
        t[h(1384)][h(1260)](l[p], { meshes: e, primitives: p });
      if (l[h(3105)] === 1)
        return l[0];
      const _ = new nt();
      t[h(1384)][h(1260)](_, { meshes: e });
      for (let p = 0, m = l[h(3105)]; p < m; p++)
        _[h(3026)](l[p]);
      return _;
    });
  }
  [s(1587)](e) {
    const x = s;
    let t;
    const i = this[x(3143)][x(1752)][e], n = i[i[x(566)]];
    if (!n) {
      console.warn(x(1821));
      return;
    }
    return i[x(566)] === x(3407) ? t = new Vx(Hd[x(1362)](n[x(2923)]), n[x(2837)] || 1, n.znear || 1, n[x(2893)] || 2e6) : i.type === x(1555) && (t = new Ji(-n[x(2970)], n[x(2970)], n[x(2719)], -n[x(2719)], n[x(2739)], n[x(2893)])), i.name && (t[x(3710)] = this[x(3103)](i[x(3710)])), gt(t, i), Promise[x(3450)](t);
  }
  [s(2493)](e) {
    const x = s, t = this[x(3143)].skins[e], i = [];
    for (let n = 0, a = t[x(1205)].length; n < a; n++)
      i[x(3156)](this[x(2150)](t[x(1205)][n]));
    return t[x(2391)] !== void 0 ? i[x(3156)](this.getDependency(x(2608), t.inverseBindMatrices)) : i[x(3156)](null), Promise.all(i).then(function(n) {
      const a = x, r = n[a(465)](), o = n, c = [], h = [];
      for (let f = 0, u = o[a(3105)]; f < u; f++) {
        const l = o[f];
        if (l) {
          c.push(l);
          const _ = new ix();
          r !== null && _[a(666)](r[a(2712)], f * 16), h.push(_);
        } else
          console[a(3629)]('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[f]);
      }
      return new Zn(c, h);
    });
  }
  loadAnimation(e) {
    const x = s, t = this[x(3143)], i = t[x(1280)][e], n = [], a = [], r = [], o = [], c = [];
    for (let h = 0, f = i[x(2273)][x(3105)]; h < f; h++) {
      const u = i[x(2273)][h], l = i[x(424)][u[x(2783)]], _ = u[x(671)], p = _[x(3792)], m = i.parameters !== void 0 ? i[x(1063)][l[x(2895)]] : l[x(2895)], y = i[x(1063)] !== void 0 ? i[x(1063)][l[x(3312)]] : l[x(3312)];
      n[x(3156)](this[x(846)](x(3792), p)), a[x(3156)](this[x(846)](x(2608), m)), r.push(this[x(846)](x(2608), y)), o[x(3156)](l), c.push(_);
    }
    return Promise[x(3029)]([Promise.all(n), Promise.all(a), Promise[x(3029)](r), Promise[x(3029)](o), Promise[x(3029)](c)]).then(function(h) {
      const f = x, u = h[0], l = h[1], _ = h[2], p = h[3], m = h[4], y = [];
      for (let g = 0, b = u[f(3105)]; g < b; g++) {
        const M = u[g], A = l[g], L = _[g], P = p[g], S = m[g];
        if (M === void 0)
          continue;
        M.updateMatrix();
        let I;
        switch (ut[S.path]) {
          case ut[f(3012)]:
            I = ji;
            break;
          case ut.rotation:
            I = Mt;
            break;
          case ut[f(3571)]:
          case ut[f(2204)]:
          default:
            I = Xi;
            break;
        }
        const C = M[f(3710)] ? M.name : M[f(3104)], G = P[f(3062)] !== void 0 ? A3[P.interpolation] : ai, $ = [];
        ut[S[f(597)]] === ut.weights ? M[f(2413)](function(V) {
          const X = f;
          V[X(2072)] && $[X(3156)](V[X(3710)] ? V.name : V[X(3104)]);
        }) : $[f(3156)](C);
        let N = L[f(2712)];
        if (L[f(3320)]) {
          const V = f2(N.constructor), X = new Float32Array(N[f(3105)]);
          for (let n0 = 0, b0 = N[f(3105)]; n0 < b0; n0++)
            X[n0] = N[n0] * V;
          N = X;
        }
        for (let V = 0, X = $[f(3105)]; V < X; V++) {
          const n0 = new I($[V] + "." + ut[S.path], A[f(2712)], N, G);
          P[f(3062)] === "CUBICSPLINE" && (n0[f(1300)] = function(Q) {
            const r0 = f, l0 = this instanceof Mt ? E3 : Wh;
            return new l0(this[r0(2621)], this[r0(910)], this[r0(913)]() / 3, Q);
          }, n0[f(1300)][f(3718)] = !![]), y[f(3156)](n0);
        }
      }
      const v = i[f(3710)] ? i.name : f(3709) + e;
      return new qi(v, void 0, y);
    });
  }
  [s(3074)](e) {
    const x = s, t = this[x(3143)], i = this, n = t[x(1347)][e];
    return n.mesh === void 0 ? null : i[x(846)](x(2939), n.mesh)[x(1941)](function(a) {
      const r = x, o = i._getNodeRef(i[r(3015)], n.mesh, a);
      return n.weights !== void 0 && o[r(2413)](function(c) {
        const h = r;
        if (c[h(3464)])
          for (let f = 0, u = n.weights.length; f < u; f++)
            c.morphTargetInfluences[f] = n[h(3012)][f];
      }), o;
    });
  }
  loadNode(e) {
    const x = s, t = this[x(3143)], i = this, n = t[x(1347)][e], a = i[x(2150)](e), r = [], o = n.children || [];
    for (let h = 0, f = o[x(3105)]; h < f; h++)
      r[x(3156)](i[x(846)]("node", o[h]));
    const c = n[x(1687)] === void 0 ? Promise[x(3450)](null) : i.getDependency(x(1687), n[x(1687)]);
    return Promise[x(3029)]([a, Promise[x(3029)](r), c])[x(1941)](function(h) {
      const f = x, u = h[0], l = h[1], _ = h[2];
      _ !== null && u[f(2413)](function(p) {
        const m = f;
        p.isSkinnedMesh && p[m(3529)](_, D3);
      });
      for (let p = 0, m = l[f(3105)]; p < m; p++)
        u[f(3026)](l[p]);
      return u;
    });
  }
  [s(2150)](e) {
    const x = s, t = this[x(3143)], i = this[x(3323)], n = this;
    if (this[x(1017)][e] !== void 0)
      return this.nodeCache[e];
    const a = t[x(1347)][e], r = a.name ? n[x(3103)](a[x(3710)]) : "", o = [], c = n[x(1340)](function(h) {
      const f = x;
      return h[f(3074)] && h[f(3074)](e);
    });
    return c && o[x(3156)](c), a[x(2189)] !== void 0 && o[x(3156)](n[x(846)](x(2189), a[x(2189)]).then(function(h) {
      const f = x;
      return n._getNodeRef(n[f(607)], a[f(2189)], h);
    })), n._invokeAll(function(h) {
      return h[x(2396)] && h.createNodeAttachment(e);
    })[x(1220)](function(h) {
      o[x(3156)](h);
    }), this[x(1017)][e] = Promise[x(3029)](o).then(function(h) {
      const f = x;
      let u;
      if (a[f(1317)] === !![] ? u = new Ca() : h[f(3105)] > 1 ? u = new nt() : h[f(3105)] === 1 ? u = h[0] : u = new px(), u !== h[0])
        for (let l = 0, _ = h[f(3105)]; l < _; l++)
          u[f(3026)](h[l]);
      if (a[f(3710)] && (u[f(2066)][f(3710)] = a[f(3710)], u[f(3710)] = r), gt(u, a), a[f(3323)] && vn(i, u, a), a[f(1067)] !== void 0) {
        const l = new ix();
        l[f(666)](a[f(1067)]), u.applyMatrix4(l);
      } else
        a[f(1579)] !== void 0 && u.position[f(666)](a[f(1579)]), a[f(591)] !== void 0 && u[f(3055)].fromArray(a[f(591)]), a[f(2204)] !== void 0 && u[f(2204)][f(666)](a[f(2204)]);
      return !n[f(1384)][f(2086)](u) && n[f(1384)][f(1260)](u, {}), n[f(1384)].get(u)[f(1347)] = e, u;
    }), this.nodeCache[e];
  }
  [s(3241)](e) {
    const x = s, t = this[x(3323)], i = this[x(3143)][x(1147)][e], n = this, a = new nt();
    i[x(3710)] && (a[x(3710)] = n.createUniqueName(i[x(3710)])), gt(a, i), i[x(3323)] && vn(t, a, i);
    const r = i[x(1347)] || [], o = [];
    for (let c = 0, h = r[x(3105)]; c < h; c++)
      o[x(3156)](n[x(846)](x(3792), r[c]));
    return Promise[x(3029)](o)[x(1941)](function(c) {
      const h = x;
      for (let u = 0, l = c[h(3105)]; u < l; u++)
        a[h(3026)](c[u]);
      const f = (u) => {
        const l = h, _ = /* @__PURE__ */ new Map();
        for (const [p, m] of n.associations)
          (p instanceof jx || p instanceof Ux) && _.set(p, m);
        return u[l(2413)]((p) => {
          const m = l, y = n[m(1384)][m(3016)](p);
          y != null && _[m(1260)](p, y);
        }), _;
      };
      return n[h(1384)] = f(a), a;
    });
  }
}
function N3(d, e, x) {
  const t = s, i = e.attributes, n = new at();
  if (i[t(2218)] !== void 0) {
    const o = x[t(3143)][t(2468)][i.POSITION], c = o[t(3085)], h = o[t(1803)];
    if (c !== void 0 && h !== void 0) {
      if (n[t(1260)](new z(c[0], c[1], c[2]), new z(h[0], h[1], h[2])), o.normalized) {
        const f = f2(Fi[o.componentType]);
        n[t(3085)].multiplyScalar(f), n.max[t(580)](f);
      }
    } else {
      console[t(3629)](t(3717));
      return;
    }
  } else
    return;
  const a = e[t(1957)];
  if (a !== void 0) {
    const o = new z(), c = new z();
    for (let h = 0, f = a.length; h < f; h++) {
      const u = a[h];
      if (u[t(2218)] !== void 0) {
        const l = x[t(3143)][t(2468)][u[t(2218)]], _ = l[t(3085)], p = l[t(1803)];
        if (_ !== void 0 && p !== void 0) {
          if (c[t(2357)](Math[t(1803)](Math.abs(_[0]), Math[t(3373)](p[0]))), c[t(712)](Math[t(1803)](Math[t(3373)](_[1]), Math[t(3373)](p[1]))), c[t(3096)](Math.max(Math[t(3373)](_[2]), Math.abs(p[2]))), l[t(3320)]) {
            const m = f2(Fi[l.componentType]);
            c[t(580)](m);
          }
          o[t(1803)](c);
        } else
          console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      }
    }
    n[t(734)](o);
  }
  d[t(3151)] = n;
  const r = new Pt();
  n[t(1658)](r[t(551)]), r[t(1232)] = n[t(3085)][t(3570)](n[t(1803)]) / 2, d[t(3689)] = r;
}
function Dc(d, e, x) {
  const t = s, i = e[t(3265)], n = [];
  function a(r, o) {
    const c = t;
    return x.getDependency(c(2608), r)[c(1941)](function(h) {
      d[c(3599)](o, h);
    });
  }
  for (const r in i) {
    const o = h2[r] || r[t(2050)]();
    o in d.attributes || n[t(3156)](a(i[r], o));
  }
  if (e[t(3198)] !== void 0 && !d.index) {
    const r = x[t(846)](t(2608), e[t(3198)])[t(1941)](function(o) {
      d[t(2203)](o);
    });
    n[t(3156)](r);
  }
  return gt(d, e), N3(d, e, x), Promise.all(n)[t(1941)](function() {
    return e[t(1957)] !== void 0 ? L3(d, e.targets, x) : d;
  });
}
const vr = /* @__PURE__ */ new WeakMap();
class U3 extends ce {
  constructor(e) {
    const x = s;
    super(e), this[x(3567)] = "", this[x(492)] = {}, this[x(677)] = null, this.decoderPending = null, this[x(675)] = 4, this[x(2030)] = [], this[x(699)] = 1, this[x(3388)] = "", this.defaultAttributeIDs = { position: x(2218), normal: "NORMAL", color: "COLOR", uv: x(2732) }, this[x(1464)] = { position: x(1570), normal: x(1570), color: x(1570), uv: x(1570) };
  }
  [s(1042)](e) {
    const x = s;
    return this[x(3567)] = e, this;
  }
  [s(953)](e) {
    const x = s;
    return this[x(492)] = e, this;
  }
  setWorkerLimit(e) {
    const x = s;
    return this[x(675)] = e, this;
  }
  [s(3442)](e, x, t, i) {
    const n = s, a = new ye(this.manager);
    a[n(3121)](this.path), a.setResponseType(n(1756)), a[n(590)](this[n(1283)]), a.setWithCredentials(this[n(1062)]), a[n(3442)](e, (r) => {
      this[n(1359)](r, x, i);
    }, t, i);
  }
  [s(1359)](e, x, t) {
    this.decodeDracoFile(e, x, null, null, _e).catch(t);
  }
  [s(1150)](e, x, t, i, n = ri) {
    const a = s, r = { attributeIDs: t || this[a(3258)], attributeTypes: i || this[a(1464)], useUniqueIDs: !!t, vertexColorSpace: n };
    return this[a(1694)](e, r)[a(1941)](x);
  }
  [s(1694)](e, x) {
    const t = s, i = JSON[t(3338)](x);
    if (vr[t(2086)](e)) {
      const c = vr.get(e);
      if (c.key === i)
        return c[t(1311)];
      if (e[t(3247)] === 0)
        throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different " + t(2487));
    }
    let n;
    const a = this.workerNextTaskID++, r = e[t(3247)], o = this._getWorker(a, r)[t(1941)]((c) => (n = c, new Promise((h, f) => {
      const u = c0;
      n[u(1175)][a] = { resolve: h, reject: f }, n[u(2808)]({ type: u(528), id: a, taskConfig: x, buffer: e }, [e]);
    }))).then((c) => this[t(3329)](c[t(1353)]));
    return o[t(747)](() => !![])[t(1941)](() => {
      n && a && this[t(1761)](n, a);
    }), vr[t(1260)](e, { key: i, promise: o }), o;
  }
  [s(3329)](e) {
    const x = s, t = new ox();
    e.index && t.setIndex(new gx(e.index[x(2712)], 1));
    for (let i = 0; i < e.attributes[x(3105)]; i++) {
      const n = e[x(3265)][i], a = n[x(3710)], r = n.array, o = n.itemSize, c = new gx(r, o);
      a === x(3282) && this[x(1726)](c, n.vertexColorSpace), t.setAttribute(a, c);
    }
    return t;
  }
  [s(1726)](e, x) {
    const t = s;
    if (x !== _e)
      return;
    const i = new P0();
    for (let n = 0, a = e.count; n < a; n++)
      i.fromBufferAttribute(e, n)[t(1292)](), e[t(1167)](n, i.r, i.g, i.b);
  }
  [s(880)](e, x) {
    const t = s, i = new ye(this.manager);
    return i[t(3121)](this[t(3567)]), i.setResponseType(x), i.setWithCredentials(this.withCredentials), new Promise((n, a) => {
      i[t(3442)](e, n, void 0, a);
    });
  }
  [s(1868)]() {
    return this[s(1649)](), this;
  }
  [s(1649)]() {
    const e = s;
    if (this[e(1277)])
      return this.decoderPending;
    const x = typeof WebAssembly !== e(1413) || this[e(492)].type === "js", t = [];
    return x ? t[e(3156)](this[e(880)]("draco_decoder.js", "text")) : (t[e(3156)](this[e(880)]("draco_wasm_wrapper.js", e(3536))), t[e(3156)](this[e(880)](e(2744), e(1756)))), this[e(1277)] = Promise[e(3029)](t)[e(1941)]((i) => {
      const n = e, a = i[0];
      !x && (this[n(492)][n(2172)] = i[1]);
      const r = z3.toString(), o = [n(3106), a, "", n(2706), r[n(2597)](r[n(882)]("{") + 1, r.lastIndexOf("}"))][n(3443)](`
`);
      this[n(3388)] = URL[n(2076)](new Blob([o]));
    }), this[e(1277)];
  }
  _getWorker(e, x) {
    const t = s;
    return this[t(1649)]()[t(1941)](() => {
      const i = t;
      if (this[i(2030)][i(3105)] < this.workerLimit) {
        const a = new Worker(this[i(3388)]);
        a[i(1175)] = {}, a[i(3345)] = {}, a[i(1065)] = 0, a[i(2808)]({ type: i(2156), decoderConfig: this[i(492)] }), a.onmessage = function(r) {
          const o = i, c = r.data;
          switch (c[o(566)]) {
            case o(528):
              a[o(1175)][c.id][o(3450)](c);
              break;
            case o(533):
              a[o(1175)][c.id][o(3374)](c);
              break;
            default:
              console[o(533)](o(2653) + c[o(566)] + '"');
          }
        }, this[i(2030)][i(3156)](a);
      } else
        this[i(2030)][i(614)](function(a, r) {
          const o = i;
          return a._taskLoad > r[o(1065)] ? -1 : 1;
        });
      const n = this[i(2030)][this[i(2030)].length - 1];
      return n[i(3345)][e] = x, n._taskLoad += x, n;
    });
  }
  [s(1761)](e, x) {
    const t = s;
    e[t(1065)] -= e[t(3345)][x], delete e._callbacks[x], delete e[t(3345)][x];
  }
  [s(3231)]() {
    const e = s;
    console[e(2773)]("Task load: ", this[e(2030)][e(3644)]((x) => x._taskLoad));
  }
  dispose() {
    const e = s;
    for (let x = 0; x < this[e(2030)][e(3105)]; ++x)
      this.workerPool[x][e(876)]();
    return this[e(2030)][e(3105)] = 0, this.workerSourceURL !== "" && URL[e(460)](this[e(3388)]), this;
  }
}
function z3() {
  let d, e;
  onmessage = function(a) {
    const r = c0, o = a.data;
    switch (o[r(566)]) {
      case "init":
        d = o[r(492)], e = new Promise(function(f) {
          const u = r;
          d[u(2816)] = function(l) {
            f({ draco: l });
          }, DracoDecoderModule(d);
        });
        break;
      case r(528):
        const c = o.buffer, h = o[r(949)];
        e[r(1941)]((f) => {
          const u = r, l = f.draco, _ = new l[u(1759)]();
          try {
            const p = x(l, _, new Int8Array(c), h), m = p[u(3265)].map((y) => y[u(2712)][u(2770)]);
            p[u(3678)] && m.push(p[u(3678)].array[u(2770)]), self[u(2808)]({ type: u(528), id: o.id, geometry: p }, m);
          } catch (p) {
            console[u(533)](p), self.postMessage({ type: u(533), id: o.id, error: p[u(2622)] });
          } finally {
            l[u(893)](_);
          }
        });
        break;
    }
  };
  function x(a, r, o, c) {
    const h = c0, f = c.attributeIDs, u = c.attributeTypes;
    let l, _;
    const p = r[h(1255)](o);
    if (p === a.TRIANGULAR_MESH)
      l = new a[h(3191)](), _ = r[h(3631)](o, o.byteLength, l);
    else if (p === a[h(1286)])
      l = new a[h(1138)](), _ = r[h(776)](o, o[h(3247)], l);
    else
      throw new Error(h(1895));
    if (!_.ok() || l[h(714)] === 0)
      throw new Error(h(1435) + _.error_msg());
    const m = { index: null, attributes: [] };
    for (const y in f) {
      const v = self[u[y]];
      let g, b;
      if (c[h(2768)])
        b = f[y], g = r.GetAttributeByUniqueId(l, b);
      else {
        if (b = r[h(2784)](l, a[f[y]]), b === -1)
          continue;
        g = r.GetAttribute(l, b);
      }
      const M = i(a, r, l, y, v, g);
      y === h(3282) && (M[h(3261)] = c[h(3261)]), m[h(3265)][h(3156)](M);
    }
    return p === a[h(2668)] && (m.index = t(a, r, l)), a[h(893)](l), m;
  }
  function t(a, r, o) {
    const c = c0, h = o[c(2316)](), f = h * 3, u = f * 4, l = a[c(1621)](u);
    r[c(3328)](o, u, l);
    const _ = new Uint32Array(a[c(3083)][c(2770)], l, f).slice();
    return a._free(l), { array: _, itemSize: 1 };
  }
  function i(a, r, o, c, h, f) {
    const u = c0, l = f[u(1742)](), _ = o[u(3177)](), p = _ * l, m = p * h.BYTES_PER_ELEMENT, y = n(a, h), v = a[u(1621)](m);
    r[u(2019)](o, f, y, m, v);
    const g = new h(a[u(3083)].buffer, v, p)[u(3482)]();
    return a._free(v), { name: c, array: g, itemSize: l };
  }
  function n(a, r) {
    const o = c0;
    switch (r) {
      case Float32Array:
        return a[o(3707)];
      case Int8Array:
        return a[o(434)];
      case Int16Array:
        return a.DT_INT16;
      case Int32Array:
        return a[o(2818)];
      case Uint8Array:
        return a[o(2945)];
      case Uint16Array:
        return a[o(2427)];
      case Uint32Array:
        return a.DT_UINT32;
    }
  }
}
class B3 extends J2 {
  constructor(e) {
    const x = s;
    super(e), this[x(566)] = ue;
  }
  [s(1359)](e) {
    const x = s, t = -1, i = 1, n = 2, a = 3, r = 4, o = function(b, M) {
      const A = c0;
      switch (b) {
        case i:
          console[A(533)](A(1781) + (M || ""));
          break;
        case n:
          console.error(A(2986) + (M || ""));
          break;
        case a:
          console.error("THREE.RGBELoader Bad File Format: " + (M || ""));
          break;
        default:
        case r:
          console[A(533)](A(2672) + (M || ""));
      }
      return t;
    }, c = 1, h = 2, f = 4, u = `
`, l = function(b, M, A) {
      const L = c0, P = 128;
      M = M || 1024;
      let S = b.pos, I = -1, C = 0, G = "", $ = String.fromCharCode[L(555)](null, new Uint16Array(b[L(1049)](S, S + P)));
      for (; 0 > (I = $.indexOf(u)) && C < M && S < b[L(3247)]; )
        G += $, C += $.length, S += P, $ += String.fromCharCode[L(555)](null, new Uint16Array(b[L(1049)](S, S + P)));
      return -1 < I ? (![] !== A && (b.pos += C + I + 1), G + $[L(3482)](0, I)) : ![];
    }, _ = function(b) {
      const M = c0, A = /^#\?(\S+)/, L = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/, P = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/, S = /^\s*FORMAT=(\S+)\s*$/, I = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/, C = { valid: 0, string: "", comments: "", programtype: "RGBE", format: "", gamma: 1, exposure: 1, width: 0, height: 0 };
      let G, $;
      if (b[M(1365)] >= b.byteLength || !(G = l(b)))
        return o(i, "no header found");
      if (!($ = G[M(2465)](A)))
        return o(a, M(3237));
      for (C.valid |= c, C[M(1145)] = $[1], C.string += G + `
`; [] && (G = l(b), ![] !== G); ) {
        if (C[M(3335)] += G + `
`, G[M(1451)](0) === "#") {
          C[M(2429)] += G + `
`;
          continue;
        }
        if (($ = G[M(2465)](L)) && (C.gamma = parseFloat($[1])), ($ = G[M(2465)](P)) && (C[M(2307)] = parseFloat($[1])), ($ = G[M(2465)](S)) && (C[M(2407)] |= h, C.format = $[1]), ($ = G[M(2465)](I)) && (C[M(2407)] |= f, C[M(1674)] = parseInt($[1], 10), C[M(1631)] = parseInt($[2], 10)), C.valid & h && C.valid & f)
          break;
      }
      return C[M(2407)] & h ? C[M(2407)] & f ? C : o(a, M(1706)) : o(a, M(2464));
    }, p = function(b, M, A) {
      const L = c0, P = M;
      if (P < 8 || P > 32767 || b[0] !== 2 || b[1] !== 2 || b[2] & 128)
        return new Uint8Array(b);
      if (P !== (b[2] << 8 | b[3]))
        return o(a, L(940));
      const S = new Uint8Array(4 * M * A);
      if (!S.length)
        return o(r, "unable to allocate buffer space");
      let I = 0, C = 0;
      const G = 4 * P, $ = new Uint8Array(4), N = new Uint8Array(G);
      let V = A;
      for (; V > 0 && C < b.byteLength; ) {
        if (C + 4 > b[L(3247)])
          return o(i);
        if ($[0] = b[C++], $[1] = b[C++], $[2] = b[C++], $[3] = b[C++], $[0] != 2 || $[1] != 2 || ($[2] << 8 | $[3]) != P)
          return o(a, L(2526));
        let X = 0, n0;
        for (; X < G && C < b[L(3247)]; ) {
          n0 = b[C++];
          const Q = n0 > 128;
          if (Q && (n0 -= 128), n0 === 0 || X + n0 > G)
            return o(a, "bad scanline data");
          if (Q) {
            const r0 = b[C++];
            for (let l0 = 0; l0 < n0; l0++)
              N[X++] = r0;
          } else
            N.set(b[L(1049)](C, C + n0), X), X += n0, C += n0;
        }
        const b0 = P;
        for (let Q = 0; Q < b0; Q++) {
          let r0 = 0;
          S[I] = N[Q + r0], r0 += P, S[I + 1] = N[Q + r0], r0 += P, S[I + 2] = N[Q + r0], r0 += P, S[I + 3] = N[Q + r0], I += 4;
        }
        V--;
      }
      return S;
    }, m = function(b, M, A, L) {
      const P = b[M + 3], S = Math.pow(2, P - 128) / 255;
      A[L + 0] = b[M + 0] * S, A[L + 1] = b[M + 1] * S, A[L + 2] = b[M + 2] * S, A[L + 3] = 1;
    }, y = function(b, M, A, L) {
      const P = c0, S = b[M + 3], I = Math[P(3196)](2, S - 128) / 255;
      A[L + 0] = Qt[P(1032)](Math[P(3085)](b[M + 0] * I, 65504)), A[L + 1] = Qt[P(1032)](Math[P(3085)](b[M + 1] * I, 65504)), A[L + 2] = Qt[P(1032)](Math[P(3085)](b[M + 2] * I, 65504)), A[L + 3] = Qt[P(1032)](1);
    }, v = new Uint8Array(e);
    v[x(1365)] = 0;
    const g = _(v);
    if (t !== g) {
      const b = g[x(1631)], M = g[x(1674)], A = p(v[x(1049)](v[x(1365)]), b, M);
      if (t !== A) {
        let L, P, S;
        switch (this[x(566)]) {
          case ae:
            S = A[x(3105)] / 4;
            const I = new Float32Array(S * 4);
            for (let G = 0; G < S; G++)
              m(A, G * 4, I, G * 4);
            L = I, P = ae;
            break;
          case ue:
            S = A[x(3105)] / 4;
            const C = new Uint16Array(S * 4);
            for (let G = 0; G < S; G++)
              y(A, G * 4, C, G * 4);
            L = C, P = ue;
            break;
          default:
            console.error(x(1364), this.type);
            break;
        }
        return { width: b, height: M, data: L, header: g[x(3335)], gamma: g.gamma, exposure: g[x(2307)], type: P };
      }
    }
    return null;
  }
  [s(2820)](e) {
    const x = s;
    return this[x(566)] = e, this;
  }
  [s(3442)](e, x, t, i) {
    function n(a, r) {
      const o = c0;
      switch (a.type) {
        case ae:
        case ue:
          a[o(523)] = Ne, a[o(991)] = Cx, a[o(999)] = Cx, a[o(3632)] = ![], a[o(1739)] = !![];
          break;
      }
      x && x(a, r);
    }
    return super.load(e, n, t, i);
  }
}
var Oc = function(d) {
  const e = s;
  return URL[e(2076)](new Blob([d], { type: e(3660) }));
};
try {
  URL[s(460)](Oc(""));
} catch {
  Oc = function(e) {
    return "data:application/javascript;charset=UTF-8," + encodeURI(e);
  };
}
var Ae = Uint8Array, yt = Uint16Array, l2 = Uint32Array, jh = new Ae([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), Xh = new Ae([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), F3 = new Ae([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), qh = function(d, e) {
  for (var x = new yt(31), t = 0; t < 31; ++t)
    x[t] = e += 1 << d[t - 1];
  for (var i = new l2(x[30]), t = 1; t < 30; ++t)
    for (var n = x[t]; n < x[t + 1]; ++n)
      i[n] = n - x[t] << 5 | t;
  return [x, i];
}, Yh = qh(jh, 2), Zh = Yh[0], G3 = Yh[1];
Zh[28] = 258, G3[258] = 28;
var H3 = qh(Xh, 0), k3 = H3[0], u2 = new yt(32768);
for (var Rx = 0; Rx < 32768; ++Rx) {
  var bt = (Rx & 43690) >>> 1 | (Rx & 21845) << 1;
  bt = (bt & 52428) >>> 2 | (bt & 13107) << 2, bt = (bt & 61680) >>> 4 | (bt & 3855) << 4, u2[Rx] = ((bt & 65280) >>> 8 | (bt & 255) << 8) >>> 1;
}
var Rn = function(d, e, x) {
  for (var i = d[s(3105)], n = 0, a = new yt(e); n < i; ++n)
    ++a[d[n] - 1];
  var r = new yt(e);
  for (n = 0; n < e; ++n)
    r[n] = r[n - 1] + a[n - 1] << 1;
  var o;
  if (x) {
    o = new yt(1 << e);
    var c = 15 - e;
    for (n = 0; n < i; ++n)
      if (d[n])
        for (var h = n << 4 | d[n], f = e - d[n], u = r[d[n] - 1]++ << f, l = u | (1 << f) - 1; u <= l; ++u)
          o[u2[u] >>> c] = h;
  } else
    for (o = new yt(i), n = 0; n < i; ++n)
      d[n] && (o[n] = u2[r[d[n] - 1]++] >>> 15 - d[n]);
  return o;
}, cs = new Ae(288);
for (var Rx = 0; Rx < 144; ++Rx)
  cs[Rx] = 8;
for (var Rx = 144; Rx < 256; ++Rx)
  cs[Rx] = 9;
for (var Rx = 256; Rx < 280; ++Rx)
  cs[Rx] = 7;
for (var Rx = 280; Rx < 288; ++Rx)
  cs[Rx] = 8;
var Kh = new Ae(32);
for (var Rx = 0; Rx < 32; ++Rx)
  Kh[Rx] = 5;
var V3 = Rn(cs, 9, 1), W3 = Rn(Kh, 5, 1), yr = function(d) {
  const e = s;
  for (var x = d[0], t = 1; t < d[e(3105)]; ++t)
    d[t] > x && (x = d[t]);
  return x;
}, Pe = function(d, e, x) {
  var t = e / 8 | 0;
  return (d[t] | d[t + 1] << 8) >> (e & 7) & x;
}, wr = function(d, e) {
  var x = e / 8 | 0;
  return (d[x] | d[x + 1] << 8 | d[x + 2] << 16) >> (e & 7);
}, j3 = function(d) {
  return (d / 8 | 0) + (d & 7 && 1);
}, X3 = function(d, e, x) {
  const t = s;
  (e == null || e < 0) && (e = 0), (x == null || x > d[t(3105)]) && (x = d[t(3105)]);
  var i = new (d instanceof yt ? yt : d instanceof l2 ? l2 : Ae)(x - e);
  return i[t(1260)](d[t(1049)](e, x)), i;
}, q3 = function(d, e, x) {
  const t = s;
  var i = d[t(3105)];
  if (!i || x && !x.l && i < 5)
    return e || new Ae(0);
  var n = !e || x, a = !x || x.i;
  x || (x = {}), e || (e = new Ae(i * 3));
  var r = function(p0) {
    const y0 = t;
    var L0 = e[y0(3105)];
    if (p0 > L0) {
      var k0 = new Ae(Math[y0(1803)](L0 * 2, p0));
      k0[y0(1260)](e), e = k0;
    }
  }, o = x.f || 0, c = x.p || 0, h = x.b || 0, f = x.l, u = x.d, l = x.m, _ = x.n, p = i * 8;
  do {
    if (!f) {
      x.f = o = Pe(d, c, 1);
      var m = Pe(d, c + 1, 3);
      if (c += 3, m)
        if (m == 1)
          f = V3, u = W3, l = 9, _ = 5;
        else if (m == 2) {
          var b = Pe(d, c, 31) + 257, M = Pe(d, c + 10, 15) + 4, A = b + Pe(d, c + 5, 31) + 1;
          c += 14;
          for (var L = new Ae(A), P = new Ae(19), S = 0; S < M; ++S)
            P[F3[S]] = Pe(d, c + S * 3, 7);
          c += M * 3;
          for (var I = yr(P), C = (1 << I) - 1, G = Rn(P, I, 1), S = 0; S < A; ) {
            var $ = G[Pe(d, c, C)];
            c += $ & 15;
            var y = $ >>> 4;
            if (y < 16)
              L[S++] = y;
            else {
              var N = 0, V = 0;
              for (y == 16 ? (V = 3 + Pe(d, c, 3), c += 2, N = L[S - 1]) : y == 17 ? (V = 3 + Pe(d, c, 7), c += 3) : y == 18 && (V = 11 + Pe(d, c, 127), c += 7); V--; )
                L[S++] = N;
            }
          }
          var X = L.subarray(0, b), n0 = L[t(1049)](b);
          l = yr(X), _ = yr(n0), f = Rn(X, l, 1), u = Rn(n0, _, 1);
        } else
          throw t(2201);
      else {
        var y = j3(c) + 4, v = d[y - 4] | d[y - 3] << 8, g = y + v;
        if (g > i) {
          if (a)
            throw t(685);
          break;
        }
        n && r(h + v), e[t(1260)](d.subarray(y, g), h), x.b = h += v, x.p = c = g * 8;
        continue;
      }
      if (c > p) {
        if (a)
          throw t(685);
        break;
      }
    }
    n && r(h + 131072);
    for (var b0 = (1 << l) - 1, Q = (1 << _) - 1, r0 = c; ; r0 = c) {
      var N = f[wr(d, c) & b0], l0 = N >>> 4;
      if (c += N & 15, c > p) {
        if (a)
          throw t(685);
        break;
      }
      if (!N)
        throw t(3268);
      if (l0 < 256)
        e[h++] = l0;
      else if (l0 == 256) {
        r0 = c, f = null;
        break;
      } else {
        var v0 = l0 - 254;
        if (l0 > 264) {
          var S = l0 - 257, s0 = jh[S];
          v0 = Pe(d, c, (1 << s0) - 1) + Zh[S], c += s0;
        }
        var q = u[wr(d, c) & Q], a0 = q >>> 4;
        if (!q)
          throw t(2329);
        c += q & 15;
        var n0 = k3[a0];
        if (a0 > 3) {
          var s0 = Xh[a0];
          n0 += wr(d, c) & (1 << s0) - 1, c += s0;
        }
        if (c > p) {
          if (a)
            throw t(685);
          break;
        }
        n && r(h + 131072);
        for (var e0 = h + v0; h < e0; h += 4)
          e[h] = e[h - n0], e[h + 1] = e[h + 1 - n0], e[h + 2] = e[h + 2 - n0], e[h + 3] = e[h + 3 - n0];
        h = e0;
      }
    }
    x.l = f, x.p = r0, x.b = h, f && (o = 1, x.m = l, x.d = u, x.n = _);
  } while (!o);
  return h == e[t(3105)] ? e : X3(e, 0, h);
}, Y3 = new Ae(0), Z3 = function(d) {
  const e = s;
  if ((d[0] & 15) != 8 || d[0] >>> 4 > 7 || (d[0] << 8 | d[1]) % 31)
    throw "invalid zlib data";
  if (d[1] & 32)
    throw e(3300);
};
function $s(d, e) {
  return q3((Z3(d), d.subarray(2, -4)), e);
}
var K3 = typeof TextDecoder != s(2011) && new TextDecoder(), $3 = 0;
try {
  K3.decode(Y3, { stream: !![] }), $3 = 1;
} catch {
}
class J3 extends J2 {
  constructor(e) {
    const x = s;
    super(e), this[x(566)] = ue;
  }
  [s(1359)](e) {
    const x = s, t = 1 << 16, i = t >> 3, n = 16, a = 14, r = (1 << n) + 1, o = 1 << a, c = o - 1, h = 16, f = 1 << h - 1, u = (1 << h) - 1, l = 59, _ = 63, p = 2 + _ - l, m = 8, y = 4, v = 4, g = 2, b = 1, M = 0, A = 1, L = 0, P = 1, S = 2, I = Math[x(3196)](2.7182818, 2.2);
    function C(w, T) {
      let U = 0;
      for (let i0 = 0; i0 < t; ++i0)
        (i0 == 0 || w[i0 >> 3] & 1 << (i0 & 7)) && (T[U++] = i0);
      const H = U - 1;
      for (; U < t; )
        T[U++] = 0;
      return H;
    }
    function G(w) {
      const T = x;
      for (let U = 0; U < o; U++)
        w[U] = {}, w[U][T(3775)] = 0, w[U][T(609)] = 0, w[U].p = null;
    }
    const $ = { l: 0, c: 0, lc: 0 };
    function N(w, T, U, H, i0) {
      for (; U < w; )
        T = T << 8 | $0(H, i0), U += 8;
      U -= w, $.l = T >> U & (1 << w) - 1, $.c = T, $.lc = U;
    }
    const V = new Array(59);
    function X(w) {
      for (let U = 0; U <= 58; ++U)
        V[U] = 0;
      for (let U = 0; U < r; ++U)
        V[w[U]] += 1;
      let T = 0;
      for (let U = 58; U > 0; --U) {
        const H = T + V[U] >> 1;
        V[U] = T, T = H;
      }
      for (let U = 0; U < r; ++U) {
        const H = w[U];
        H > 0 && (w[U] = H | V[H]++ << 6);
      }
    }
    function n0(w, T, U, H, i0, Y) {
      const J = x, f0 = T;
      let T0 = 0, g0 = 0;
      for (; H <= i0; H++) {
        if (f0[J(1811)] - T[J(1811)] > U)
          return ![];
        N(6, T0, g0, w, f0);
        const M0 = $.l;
        if (T0 = $.c, g0 = $.lc, Y[H] = M0, M0 == _) {
          if (f0[J(1811)] - T[J(1811)] > U)
            throw new Error("Something wrong with hufUnpackEncTable");
          N(8, T0, g0, w, f0);
          let m0 = $.l + p;
          if (T0 = $.c, g0 = $.lc, H + m0 > i0 + 1)
            throw new Error(J(2604));
          for (; m0--; )
            Y[H++] = 0;
          H--;
        } else if (M0 >= l) {
          let m0 = M0 - l + 2;
          if (H + m0 > i0 + 1)
            throw new Error("Something wrong with hufUnpackEncTable");
          for (; m0--; )
            Y[H++] = 0;
          H--;
        }
      }
      X(Y);
    }
    function b0(w) {
      return w & 63;
    }
    function Q(w) {
      return w >> 6;
    }
    function r0(w, T, U, H) {
      const i0 = x;
      for (; T <= U; T++) {
        const Y = Q(w[T]), J = b0(w[T]);
        if (Y >> J)
          throw new Error(i0(2868));
        if (J > a) {
          const f0 = H[Y >> J - a];
          if (f0[i0(3775)])
            throw new Error(i0(2868));
          if (f0.lit++, f0.p) {
            const T0 = f0.p;
            f0.p = new Array(f0[i0(609)]);
            for (let g0 = 0; g0 < f0[i0(609)] - 1; ++g0)
              f0.p[g0] = T0[g0];
          } else
            f0.p = new Array(1);
          f0.p[f0.lit - 1] = T;
        } else if (J) {
          let f0 = 0;
          for (let T0 = 1 << a - J; T0 > 0; T0--) {
            const g0 = H[(Y << a - J) + f0];
            if (g0[i0(3775)] || g0.p)
              throw new Error("Invalid table entry");
            g0[i0(3775)] = J, g0[i0(609)] = T, f0++;
          }
        }
      }
      return !![];
    }
    const l0 = { c: 0, lc: 0 };
    function v0(w, T, U, H) {
      w = w << 8 | $0(U, H), T += 8, l0.c = w, l0.lc = T;
    }
    const s0 = { c: 0, lc: 0 };
    function q(w, T, U, H, i0, Y, J, f0, T0) {
      const g0 = x;
      if (w == T) {
        H < 8 && (v0(U, H, i0, Y), U = l0.c, H = l0.lc), H -= 8;
        let M0 = U >> H;
        if (M0 = new Uint8Array([M0])[0], f0[g0(1811)] + M0 > T0)
          return ![];
        const m0 = J[f0.value - 1];
        for (; M0-- > 0; )
          J[f0[g0(1811)]++] = m0;
      } else if (f0.value < T0)
        J[f0.value++] = w;
      else
        return ![];
      s0.c = U, s0.lc = H;
    }
    function a0(w) {
      return w & 65535;
    }
    function e0(w) {
      const T = a0(w);
      return T > 32767 ? T - 65536 : T;
    }
    const p0 = { a: 0, b: 0 };
    function y0(w, T) {
      const U = e0(w), H = e0(T), i0 = H, Y = U + (i0 & 1) + (i0 >> 1), J = Y, f0 = Y - i0;
      p0.a = J, p0.b = f0;
    }
    function L0(w, T) {
      const U = a0(w), H = a0(T), i0 = U - (H >> 1) & u, Y = H + i0 - f & u;
      p0.a = Y, p0.b = i0;
    }
    function k0(w, T, U, H, i0, Y, J) {
      const f0 = J < 16384, T0 = U > i0 ? i0 : U;
      let g0 = 1, M0, m0;
      for (; g0 <= T0; )
        g0 <<= 1;
      for (g0 >>= 1, M0 = g0, g0 >>= 1; g0 >= 1; ) {
        m0 = 0;
        const C0 = m0 + Y * (i0 - M0), z0 = Y * g0, F0 = Y * M0, J0 = H * g0, q0 = H * M0;
        let G0, lx, hx, yx;
        for (; m0 <= C0; m0 += F0) {
          let mx = m0;
          const Ox = m0 + H * (U - M0);
          for (; mx <= Ox; mx += q0) {
            const ex = mx + J0, de = mx + z0, he = de + J0;
            f0 ? (y0(w[mx + T], w[de + T]), G0 = p0.a, hx = p0.b, y0(w[ex + T], w[he + T]), lx = p0.a, yx = p0.b, y0(G0, lx), w[mx + T] = p0.a, w[ex + T] = p0.b, y0(hx, yx), w[de + T] = p0.a, w[he + T] = p0.b) : (L0(w[mx + T], w[de + T]), G0 = p0.a, hx = p0.b, L0(w[ex + T], w[he + T]), lx = p0.a, yx = p0.b, L0(G0, lx), w[mx + T] = p0.a, w[ex + T] = p0.b, L0(hx, yx), w[de + T] = p0.a, w[he + T] = p0.b);
          }
          if (U & g0) {
            const ex = mx + z0;
            f0 ? y0(w[mx + T], w[ex + T]) : L0(w[mx + T], w[ex + T]), G0 = p0.a, w[ex + T] = p0.b, w[mx + T] = G0;
          }
        }
        if (i0 & g0) {
          let mx = m0;
          const Ox = m0 + H * (U - M0);
          for (; mx <= Ox; mx += q0) {
            const ex = mx + J0;
            f0 ? y0(w[mx + T], w[ex + T]) : L0(w[mx + T], w[ex + T]), G0 = p0.a, w[ex + T] = p0.b, w[mx + T] = G0;
          }
        }
        M0 = g0, g0 >>= 1;
      }
      return m0;
    }
    function Q0(w, T, U, H, i0, Y, J, f0, T0) {
      const g0 = x;
      let M0 = 0, m0 = 0;
      const C0 = J, z0 = Math[g0(2960)](H[g0(1811)] + (i0 + 7) / 8);
      for (; H[g0(1811)] < z0; )
        for (v0(M0, m0, U, H), M0 = l0.c, m0 = l0.lc; m0 >= a; ) {
          const J0 = M0 >> m0 - a & c, q0 = T[J0];
          if (q0[g0(3775)])
            m0 -= q0.len, q(q0.lit, Y, M0, m0, U, H, f0, T0, C0), M0 = s0.c, m0 = s0.lc;
          else {
            if (!q0.p)
              throw new Error(g0(2870));
            let G0;
            for (G0 = 0; G0 < q0[g0(609)]; G0++) {
              const lx = b0(w[q0.p[G0]]);
              for (; m0 < lx && H.value < z0; )
                v0(M0, m0, U, H), M0 = l0.c, m0 = l0.lc;
              if (m0 >= lx && Q(w[q0.p[G0]]) == (M0 >> m0 - lx & (1 << lx) - 1)) {
                m0 -= lx, q(q0.p[G0], Y, M0, m0, U, H, f0, T0, C0), M0 = s0.c, m0 = s0.lc;
                break;
              }
            }
            if (G0 == q0[g0(609)])
              throw new Error(g0(2870));
          }
        }
      const F0 = 8 - i0 & 7;
      for (M0 >>= F0, m0 -= F0; m0 > 0; ) {
        const J0 = T[M0 << a - m0 & c];
        if (J0[g0(3775)])
          m0 -= J0[g0(3775)], q(J0[g0(609)], Y, M0, m0, U, H, f0, T0, C0), M0 = s0.c, m0 = s0.lc;
        else
          throw new Error(g0(2870));
      }
      return !![];
    }
    function U0(w, T, U, H, i0, Y) {
      const J = x, f0 = { value: 0 }, T0 = U[J(1811)], g0 = j0(T, U), M0 = j0(T, U);
      U.value += 4;
      const m0 = j0(T, U);
      if (U[J(1811)] += 4, g0 < 0 || g0 >= r || M0 < 0 || M0 >= r)
        throw new Error(J(552));
      const C0 = new Array(r), z0 = new Array(o);
      G(z0);
      const F0 = H - (U[J(1811)] - T0);
      if (n0(w, U, F0, g0, M0, C0), m0 > 8 * (H - (U[J(1811)] - T0)))
        throw new Error(J(3389));
      r0(C0, g0, M0, z0), Q0(C0, z0, w, U, m0, M0, Y, i0, f0);
    }
    function xx(w, T, U) {
      for (let H = 0; H < U; ++H)
        T[H] = w[T[H]];
    }
    function _0(w) {
      const T = x;
      for (let U = 1; U < w[T(3105)]; U++) {
        const H = w[U - 1] + w[U] - 128;
        w[U] = H;
      }
    }
    function E0(w, T) {
      const U = x;
      let H = 0, i0 = Math[U(2697)]((w[U(3105)] + 1) / 2), Y = 0;
      const J = w.length - 1;
      for (; [] && !(Y > J || (T[Y++] = w[H++], Y > J)); )
        T[Y++] = w[i0++];
    }
    function O0(w) {
      const T = x;
      let U = w[T(3247)];
      const H = new Array();
      let i0 = 0;
      const Y = new DataView(w);
      for (; U > 0; ) {
        const J = Y[T(1500)](i0++);
        if (J < 0) {
          const f0 = -J;
          U -= f0 + 1;
          for (let T0 = 0; T0 < f0; T0++)
            H.push(Y.getUint8(i0++));
        } else {
          const f0 = J;
          U -= 2;
          const T0 = Y.getUint8(i0++);
          for (let g0 = 0; g0 < f0 + 1; g0++)
            H.push(T0);
        }
      }
      return H;
    }
    function D0(w, T, U, H, i0, Y) {
      const J = x;
      let f0 = new DataView(Y[J(2770)]);
      const T0 = U[w.idx[0]][J(1631)], g0 = U[w.idx[0]][J(1674)], M0 = 3, m0 = Math.floor(T0 / 8), C0 = Math.ceil(T0 / 8), z0 = Math.ceil(g0 / 8), F0 = T0 - (C0 - 1) * 8, J0 = g0 - (z0 - 1) * 8, q0 = { value: 0 }, G0 = new Array(M0), lx = new Array(M0), hx = new Array(M0), yx = new Array(M0), mx = new Array(M0);
      for (let ex = 0; ex < M0; ++ex)
        mx[ex] = T[w[J(1194)][ex]], G0[ex] = ex < 1 ? 0 : G0[ex - 1] + C0 * z0, lx[ex] = new Float32Array(64), hx[ex] = new Uint16Array(64), yx[ex] = new Uint16Array(C0 * 64);
      for (let ex = 0; ex < z0; ++ex) {
        let de = 8;
        ex == z0 - 1 && (de = J0);
        let he = 8;
        for (let wx = 0; wx < C0; ++wx) {
          wx == C0 - 1 && (he = F0);
          for (let Lx = 0; Lx < M0; ++Lx)
            hx[Lx][J(1314)](0), hx[Lx][0] = i0[G0[Lx]++], N0(q0, H, hx[Lx]), B0(hx[Lx], lx[Lx]), X0(lx[Lx]);
          fx(lx);
          for (let Lx = 0; Lx < M0; ++Lx)
            vx(lx[Lx], yx[Lx], wx * 64);
        }
        let pe = 0;
        for (let wx = 0; wx < M0; ++wx) {
          const Lx = U[w[J(1194)][wx]][J(566)];
          for (let Ze = 8 * ex; Ze < 8 * ex + de; ++Ze) {
            pe = mx[wx][Ze];
            for (let an = 0; an < m0; ++an) {
              const Be = an * 64 + (Ze & 7) * 8;
              f0[J(2916)](pe + 0 * g * Lx, yx[wx][Be + 0], !![]), f0[J(2916)](pe + 1 * g * Lx, yx[wx][Be + 1], !![]), f0[J(2916)](pe + 2 * g * Lx, yx[wx][Be + 2], !![]), f0.setUint16(pe + 3 * g * Lx, yx[wx][Be + 3], !![]), f0[J(2916)](pe + 4 * g * Lx, yx[wx][Be + 4], !![]), f0[J(2916)](pe + 5 * g * Lx, yx[wx][Be + 5], !![]), f0[J(2916)](pe + 6 * g * Lx, yx[wx][Be + 6], !![]), f0[J(2916)](pe + 7 * g * Lx, yx[wx][Be + 7], !![]), pe += 8 * g * Lx;
            }
          }
          if (m0 != C0)
            for (let Ze = 8 * ex; Ze < 8 * ex + de; ++Ze) {
              const an = mx[wx][Ze] + 8 * m0 * g * Lx, Be = m0 * 64 + (Ze & 7) * 8;
              for (let hs = 0; hs < he; ++hs)
                f0[J(2916)](an + hs * g * Lx, yx[wx][Be + hs], !![]);
            }
        }
      }
      const Ox = new Uint16Array(T0);
      f0 = new DataView(Y[J(2770)]);
      for (let ex = 0; ex < M0; ++ex) {
        U[w.idx[ex]][J(1882)] = !![];
        const de = U[w[J(1194)][ex]][J(566)];
        if (U[ex][J(566)] == 2)
          for (let he = 0; he < g0; ++he) {
            const pe = mx[ex][he];
            for (let wx = 0; wx < T0; ++wx)
              Ox[wx] = f0[J(3578)](pe + wx * g * de, !![]);
            for (let wx = 0; wx < T0; ++wx)
              f0[J(2523)](pe + wx * g * de, x0(Ox[wx]), !![]);
          }
      }
    }
    function N0(w, T, U) {
      const H = x;
      let i0, Y = 1;
      for (; Y < 64; )
        i0 = T[w[H(1811)]], i0 == 65280 ? Y = 64 : i0 >> 8 == 255 ? Y += i0 & 255 : (U[Y] = i0, Y++), w.value++;
    }
    function B0(w, T) {
      T[0] = x0(w[0]), T[1] = x0(w[1]), T[2] = x0(w[5]), T[3] = x0(w[6]), T[4] = x0(w[14]), T[5] = x0(w[15]), T[6] = x0(w[27]), T[7] = x0(w[28]), T[8] = x0(w[2]), T[9] = x0(w[4]), T[10] = x0(w[7]), T[11] = x0(w[13]), T[12] = x0(w[16]), T[13] = x0(w[26]), T[14] = x0(w[29]), T[15] = x0(w[42]), T[16] = x0(w[3]), T[17] = x0(w[8]), T[18] = x0(w[12]), T[19] = x0(w[17]), T[20] = x0(w[25]), T[21] = x0(w[30]), T[22] = x0(w[41]), T[23] = x0(w[43]), T[24] = x0(w[9]), T[25] = x0(w[11]), T[26] = x0(w[18]), T[27] = x0(w[24]), T[28] = x0(w[31]), T[29] = x0(w[40]), T[30] = x0(w[44]), T[31] = x0(w[53]), T[32] = x0(w[10]), T[33] = x0(w[19]), T[34] = x0(w[23]), T[35] = x0(w[32]), T[36] = x0(w[39]), T[37] = x0(w[45]), T[38] = x0(w[52]), T[39] = x0(w[54]), T[40] = x0(w[20]), T[41] = x0(w[22]), T[42] = x0(w[33]), T[43] = x0(w[38]), T[44] = x0(w[46]), T[45] = x0(w[51]), T[46] = x0(w[55]), T[47] = x0(w[60]), T[48] = x0(w[21]), T[49] = x0(w[34]), T[50] = x0(w[37]), T[51] = x0(w[47]), T[52] = x0(w[50]), T[53] = x0(w[56]), T[54] = x0(w[59]), T[55] = x0(w[61]), T[56] = x0(w[35]), T[57] = x0(w[36]), T[58] = x0(w[48]), T[59] = x0(w[49]), T[60] = x0(w[57]), T[61] = x0(w[58]), T[62] = x0(w[62]), T[63] = x0(w[63]);
    }
    function X0(w) {
      const T = x, U = 0.5 * Math[T(2063)](3.14159 / 4), H = 0.5 * Math[T(2063)](3.14159 / 16), i0 = 0.5 * Math.cos(3.14159 / 8), Y = 0.5 * Math[T(2063)](3 * 3.14159 / 16), J = 0.5 * Math.cos(5 * 3.14159 / 16), f0 = 0.5 * Math.cos(3 * 3.14159 / 8), T0 = 0.5 * Math[T(2063)](7 * 3.14159 / 16), g0 = new Array(4), M0 = new Array(4), m0 = new Array(4), C0 = new Array(4);
      for (let z0 = 0; z0 < 8; ++z0) {
        const F0 = z0 * 8;
        g0[0] = i0 * w[F0 + 2], g0[1] = f0 * w[F0 + 2], g0[2] = i0 * w[F0 + 6], g0[3] = f0 * w[F0 + 6], M0[0] = H * w[F0 + 1] + Y * w[F0 + 3] + J * w[F0 + 5] + T0 * w[F0 + 7], M0[1] = Y * w[F0 + 1] - T0 * w[F0 + 3] - H * w[F0 + 5] - J * w[F0 + 7], M0[2] = J * w[F0 + 1] - H * w[F0 + 3] + T0 * w[F0 + 5] + Y * w[F0 + 7], M0[3] = T0 * w[F0 + 1] - J * w[F0 + 3] + Y * w[F0 + 5] - H * w[F0 + 7], m0[0] = U * (w[F0 + 0] + w[F0 + 4]), m0[3] = U * (w[F0 + 0] - w[F0 + 4]), m0[1] = g0[0] + g0[3], m0[2] = g0[1] - g0[2], C0[0] = m0[0] + m0[1], C0[1] = m0[3] + m0[2], C0[2] = m0[3] - m0[2], C0[3] = m0[0] - m0[1], w[F0 + 0] = C0[0] + M0[0], w[F0 + 1] = C0[1] + M0[1], w[F0 + 2] = C0[2] + M0[2], w[F0 + 3] = C0[3] + M0[3], w[F0 + 4] = C0[3] - M0[3], w[F0 + 5] = C0[2] - M0[2], w[F0 + 6] = C0[1] - M0[1], w[F0 + 7] = C0[0] - M0[0];
      }
      for (let z0 = 0; z0 < 8; ++z0)
        g0[0] = i0 * w[16 + z0], g0[1] = f0 * w[16 + z0], g0[2] = i0 * w[48 + z0], g0[3] = f0 * w[48 + z0], M0[0] = H * w[8 + z0] + Y * w[24 + z0] + J * w[40 + z0] + T0 * w[56 + z0], M0[1] = Y * w[8 + z0] - T0 * w[24 + z0] - H * w[40 + z0] - J * w[56 + z0], M0[2] = J * w[8 + z0] - H * w[24 + z0] + T0 * w[40 + z0] + Y * w[56 + z0], M0[3] = T0 * w[8 + z0] - J * w[24 + z0] + Y * w[40 + z0] - H * w[56 + z0], m0[0] = U * (w[z0] + w[32 + z0]), m0[3] = U * (w[z0] - w[32 + z0]), m0[1] = g0[0] + g0[3], m0[2] = g0[1] - g0[2], C0[0] = m0[0] + m0[1], C0[1] = m0[3] + m0[2], C0[2] = m0[3] - m0[2], C0[3] = m0[0] - m0[1], w[0 + z0] = C0[0] + M0[0], w[8 + z0] = C0[1] + M0[1], w[16 + z0] = C0[2] + M0[2], w[24 + z0] = C0[3] + M0[3], w[32 + z0] = C0[3] - M0[3], w[40 + z0] = C0[2] - M0[2], w[48 + z0] = C0[1] - M0[1], w[56 + z0] = C0[0] - M0[0];
    }
    function fx(w) {
      for (let T = 0; T < 64; ++T) {
        const U = w[0][T], H = w[1][T], i0 = w[2][T];
        w[0][T] = U + 1.5747 * i0, w[1][T] = U - 0.1873 * H - 0.4682 * i0, w[2][T] = U + 1.8556 * H;
      }
    }
    function vx(w, T, U) {
      for (let H = 0; H < 64; ++H)
        T[U + H] = Qt.toHalfFloat(B(w[H]));
    }
    function B(w) {
      const T = x;
      return w <= 1 ? Math[T(2966)](w) * Math[T(3196)](Math[T(3373)](w), 2.2) : Math[T(2966)](w) * Math.pow(I, Math[T(3373)](w) - 1);
    }
    function E(w) {
      const T = x;
      return new DataView(w.array[T(2770)], w.offset.value, w[T(3073)]);
    }
    function j(w) {
      const T = x, U = w[T(2079)][T(2770)][T(3482)](w.offset.value, w[T(592)][T(1811)] + w[T(3073)]), H = new Uint8Array(O0(U)), i0 = new Uint8Array(H.length);
      return _0(H), E0(H, i0), new DataView(i0[T(2770)]);
    }
    function R(w) {
      const T = x, U = w[T(2712)][T(3482)](w.offset.value, w[T(592)][T(1811)] + w[T(3073)]), H = $s(U), i0 = new Uint8Array(H[T(3105)]);
      return _0(H), E0(H, i0), new DataView(i0[T(2770)]);
    }
    function h0(w) {
      const T = x, U = w.viewer, H = { value: w.offset[T(1811)] }, i0 = new Uint16Array(w.width * w[T(2042)] * (w[T(2273)] * w[T(566)])), Y = new Uint8Array(i);
      let J = 0;
      const f0 = new Array(w[T(2273)]);
      for (let J0 = 0; J0 < w[T(2273)]; J0++)
        f0[J0] = {}, f0[J0].start = J, f0[J0][T(1475)] = f0[J0].start, f0[J0].nx = w[T(1631)], f0[J0].ny = w.lines, f0[J0][T(3073)] = w.type, J += f0[J0].nx * f0[J0].ny * f0[J0][T(3073)];
      const T0 = t0(U, H), g0 = t0(U, H);
      if (g0 >= i)
        throw new Error(T(2579));
      if (T0 <= g0)
        for (let J0 = 0; J0 < g0 - T0 + 1; J0++)
          Y[J0 + T0] = Y0(U, H);
      const M0 = new Uint16Array(t), m0 = C(Y, M0), C0 = j0(U, H);
      U0(w[T(2712)], U, H, C0, i0, J);
      for (let J0 = 0; J0 < w[T(2273)]; ++J0) {
        const q0 = f0[J0];
        for (let G0 = 0; G0 < f0[J0][T(3073)]; ++G0)
          k0(i0, q0[T(1917)] + G0, q0.nx, q0[T(3073)], q0.ny, q0.nx * q0[T(3073)], m0);
      }
      xx(M0, i0, J);
      let z0 = 0;
      const F0 = new Uint8Array(i0[T(2770)][T(3247)]);
      for (let J0 = 0; J0 < w[T(1410)]; J0++)
        for (let q0 = 0; q0 < w[T(2273)]; q0++) {
          const G0 = f0[q0], lx = G0.nx * G0[T(3073)], hx = new Uint8Array(i0[T(2770)], G0[T(1475)] * g, lx * g);
          F0[T(1260)](hx, z0), z0 += lx * g, G0[T(1475)] += lx;
        }
      return new DataView(F0[T(2770)]);
    }
    function S0(w) {
      const T = x, U = w[T(2712)][T(3482)](w.offset[T(1811)], w[T(592)][T(1811)] + w[T(3073)]), H = $s(U), i0 = w.lines * w[T(2273)] * w.width, Y = w.type == 1 ? new Uint16Array(i0) : new Uint32Array(i0);
      let J = 0, f0 = 0;
      const T0 = new Array(4);
      for (let g0 = 0; g0 < w[T(1410)]; g0++)
        for (let M0 = 0; M0 < w[T(2273)]; M0++) {
          let m0 = 0;
          switch (w.type) {
            case 1:
              T0[0] = J, T0[1] = T0[0] + w[T(1631)], J = T0[1] + w[T(1631)];
              for (let C0 = 0; C0 < w.width; ++C0) {
                const z0 = H[T0[0]++] << 8 | H[T0[1]++];
                m0 += z0, Y[f0] = m0, f0++;
              }
              break;
            case 2:
              T0[0] = J, T0[1] = T0[0] + w[T(1631)], T0[2] = T0[1] + w[T(1631)], J = T0[2] + w[T(1631)];
              for (let C0 = 0; C0 < w[T(1631)]; ++C0) {
                const z0 = H[T0[0]++] << 24 | H[T0[1]++] << 16 | H[T0[2]++] << 8;
                m0 += z0, Y[f0] = m0, f0++;
              }
              break;
          }
        }
      return new DataView(Y.buffer);
    }
    function R0(w) {
      const T = x, U = w[T(2079)], H = { value: w[T(592)][T(1811)] }, i0 = new Uint8Array(w.width * w.lines * (w[T(2273)] * w[T(566)] * g)), Y = { version: sx(U, H), unknownUncompressedSize: sx(U, H), unknownCompressedSize: sx(U, H), acCompressedSize: sx(U, H), dcCompressedSize: sx(U, H), rleCompressedSize: sx(U, H), rleUncompressedSize: sx(U, H), rleRawSize: sx(U, H), totalAcUncompressedCount: sx(U, H), totalDcUncompressedCount: sx(U, H), acCompression: sx(U, H) };
      if (Y[T(2185)] < 2)
        throw new Error(T(2788) + Z.compression + T(3507) + Y[T(2185)] + T(3735));
      const J = new Array();
      let f0 = t0(U, H) - g;
      for (; f0 > 0; ) {
        const q0 = Z0(U[T(2770)], H), G0 = Y0(U, H), lx = G0 >> 2 & 3, hx = (G0 >> 4) - 1, yx = new Int8Array([hx])[0], mx = Y0(U, H);
        J[T(3156)]({ name: q0, index: yx, type: mx, compression: lx }), f0 -= q0[T(3105)] + 3;
      }
      const T0 = Z[T(2273)], g0 = new Array(w[T(2273)]);
      for (let q0 = 0; q0 < w[T(2273)]; ++q0) {
        const G0 = g0[q0] = {}, lx = T0[q0];
        G0.name = lx[T(3710)], G0[T(611)] = L, G0[T(1882)] = ![], G0[T(566)] = lx[T(1207)], G0[T(808)] = lx[T(808)], G0.width = w.width, G0[T(1674)] = w.lines;
      }
      const M0 = { idx: new Array(3) };
      for (let q0 = 0; q0 < w[T(2273)]; ++q0) {
        const G0 = g0[q0];
        for (let lx = 0; lx < J[T(3105)]; ++lx) {
          const hx = J[lx];
          G0[T(3710)] == hx[T(3710)] && (G0[T(611)] = hx.compression, hx.index >= 0 && (M0[T(1194)][hx[T(3678)]] = q0), G0[T(592)] = q0);
        }
      }
      let m0, C0, z0;
      if (Y[T(3720)] > 0)
        switch (Y[T(2008)]) {
          case M:
            m0 = new Uint16Array(Y[T(2640)]), U0(w[T(2712)], U, H, Y[T(3720)], m0, Y[T(2640)]);
            break;
          case A:
            const q0 = w[T(2712)][T(3482)](H[T(1811)], H[T(1811)] + Y[T(2640)]), G0 = $s(q0);
            m0 = new Uint16Array(G0[T(2770)]), H.value += Y[T(2640)];
            break;
        }
      if (Y[T(2858)] > 0) {
        const q0 = { array: w.array, offset: H, size: Y.dcCompressedSize };
        C0 = new Uint16Array(R(q0).buffer), H[T(1811)] += Y[T(2858)];
      }
      if (Y.rleRawSize > 0) {
        const q0 = w[T(2712)][T(3482)](H[T(1811)], H.value + Y.rleCompressedSize), G0 = $s(q0);
        z0 = O0(G0[T(2770)]), H[T(1811)] += Y[T(2410)];
      }
      let F0 = 0;
      const J0 = new Array(g0[T(3105)]);
      for (let q0 = 0; q0 < J0[T(3105)]; ++q0)
        J0[q0] = new Array();
      for (let q0 = 0; q0 < w.lines; ++q0)
        for (let G0 = 0; G0 < g0[T(3105)]; ++G0)
          J0[G0][T(3156)](F0), F0 += g0[G0][T(1631)] * w[T(566)] * g;
      D0(M0, J0, g0, m0, C0, i0);
      for (let q0 = 0; q0 < g0.length; ++q0) {
        const G0 = g0[q0];
        if (!G0[T(1882)])
          switch (G0.compression) {
            case S:
              let lx = 0, hx = 0;
              for (let yx = 0; yx < w[T(1410)]; ++yx) {
                let mx = J0[q0][lx];
                for (let Ox = 0; Ox < G0[T(1631)]; ++Ox) {
                  for (let ex = 0; ex < g * G0.type; ++ex)
                    i0[mx++] = z0[hx + ex * G0[T(1631)] * G0[T(1674)]];
                  hx++;
                }
                lx++;
              }
              break;
            case P:
            default:
              throw new Error(T(2318));
          }
      }
      return new DataView(i0.buffer);
    }
    function Z0(w, T) {
      const U = x, H = new Uint8Array(w);
      let i0 = 0;
      for (; H[T.value + i0] != 0; )
        i0 += 1;
      const Y = new TextDecoder()[U(528)](H[U(3482)](T[U(1811)], T[U(1811)] + i0));
      return T.value = T[U(1811)] + i0 + 1, Y;
    }
    function H0(w, T, U) {
      const H = x, i0 = new TextDecoder()[H(528)](new Uint8Array(w).slice(T[H(1811)], T[H(1811)] + U));
      return T.value = T[H(1811)] + U, i0;
    }
    function u0(w, T) {
      const U = K0(w, T), H = j0(w, T);
      return [U, H];
    }
    function V0(w, T) {
      const U = j0(w, T), H = j0(w, T);
      return [U, H];
    }
    function K0(w, T) {
      const U = x, H = w.getInt32(T[U(1811)], !![]);
      return T.value = T[U(1811)] + v, H;
    }
    function j0(w, T) {
      const U = x, H = w[U(2114)](T[U(1811)], !![]);
      return T.value = T[U(1811)] + v, H;
    }
    function $0(w, T) {
      const U = x, H = w[T[U(1811)]];
      return T[U(1811)] = T[U(1811)] + b, H;
    }
    function Y0(w, T) {
      const U = x, H = w[U(660)](T[U(1811)]);
      return T[U(1811)] = T[U(1811)] + b, H;
    }
    const sx = function(w, T) {
      const U = x;
      let H;
      return U(3359) in DataView[U(2028)] ? H = Number(w.getBigInt64(T[U(1811)], !![])) : H = w[U(2114)](T[U(1811)] + 4, !![]) + Number(w[U(2114)](T.value, !![]) << 32), T[U(1811)] += m, H;
    };
    function cx(w, T) {
      const U = x, H = w[U(938)](T[U(1811)], !![]);
      return T[U(1811)] += y, H;
    }
    function k(w, T) {
      return Qt[x(1032)](cx(w, T));
    }
    function x0(w) {
      const T = x, U = (w & 31744) >> 10, H = w & 1023;
      return (w >> 15 ? -1 : 1) * (U ? U === 31 ? H ? NaN : 1 / 0 : Math[T(3196)](2, U - 15) * (1 + H / 1024) : 6103515625e-14 * (H / 1024));
    }
    function t0(w, T) {
      const U = x, H = w[U(3578)](T[U(1811)], !![]);
      return T.value += g, H;
    }
    function A0(w, T) {
      return x0(t0(w, T));
    }
    function w0(w, T, U, H) {
      const i0 = x, Y = U[i0(1811)], J = [];
      for (; U[i0(1811)] < Y + H - 1; ) {
        const f0 = Z0(T, U), T0 = K0(w, U), g0 = Y0(w, U);
        U[i0(1811)] += 3;
        const M0 = K0(w, U), m0 = K0(w, U);
        J[i0(3156)]({ name: f0, pixelType: T0, pLinear: g0, xSampling: M0, ySampling: m0 });
      }
      return U[i0(1811)] += 1, J;
    }
    function ax(w, T) {
      const U = cx(w, T), H = cx(w, T), i0 = cx(w, T), Y = cx(w, T), J = cx(w, T), f0 = cx(w, T), T0 = cx(w, T), g0 = cx(w, T);
      return { redX: U, redY: H, greenX: i0, greenY: Y, blueX: J, blueY: f0, whiteX: T0, whiteY: g0 };
    }
    function Ex(w, T) {
      const U = x, H = [U(2093), U(2791), U(1606), U(3716), "PIZ_COMPRESSION", U(978), U(2426), U(934), U(1325), "DWAB_COMPRESSION"], i0 = Y0(w, T);
      return H[i0];
    }
    function kx(w, T) {
      const U = j0(w, T), H = j0(w, T), i0 = j0(w, T), Y = j0(w, T);
      return { xMin: U, yMin: H, xMax: i0, yMax: Y };
    }
    function Px(w, T) {
      const U = x, H = [U(1938)], i0 = Y0(w, T);
      return H[i0];
    }
    function Sx(w, T) {
      const U = cx(w, T), H = cx(w, T);
      return [U, H];
    }
    function ie(w, T) {
      const U = cx(w, T), H = cx(w, T), i0 = cx(w, T);
      return [U, H, i0];
    }
    function we(w, T, U, H, i0) {
      const Y = x;
      return H === "string" || H === "stringvector" || H === Y(895) ? H0(T, U, i0) : H === "chlist" ? w0(w, T, U, i0) : H === Y(3228) ? ax(w, U) : H === Y(611) ? Ex(w, U) : H === Y(435) ? kx(w, U) : H === "lineOrder" ? Px(w, U) : H === Y(2535) ? cx(w, U) : H === "v2f" ? Sx(w, U) : H === "v3f" ? ie(w, U) : H === Y(3684) ? K0(w, U) : H === Y(3548) ? u0(w, U) : H === Y(2438) ? V0(w, U) : H === Y(521) ? (U[Y(1811)] += i0, Y(3667)) : (U[Y(1811)] += i0, void 0);
    }
    function sn(w, T, U) {
      const H = x, i0 = {};
      if (w[H(2114)](0, !![]) != 20000630)
        throw new Error(H(1001));
      i0.version = w[H(660)](4);
      const Y = w[H(660)](5);
      i0[H(2780)] = { singleTile: !!(Y & 2), longName: !!(Y & 4), deepFormat: !!(Y & 8), multiPart: !!(Y & 16) }, U.value = 8;
      let J = !![];
      for (; J; ) {
        const f0 = Z0(T, U);
        if (f0 == 0)
          J = ![];
        else {
          const T0 = Z0(T, U), g0 = j0(w, U), M0 = we(w, T, U, T0, g0);
          M0 === void 0 ? console[H(3629)]("EXRLoader.parse: skipped unknown header attribute type '" + T0 + "'.") : i0[f0] = M0;
        }
      }
      if (Y & -5)
        throw console[H(533)](H(3205), i0), new Error(H(1797));
      return i0;
    }
    function Ba(w, T, U, H, i0) {
      const Y = x, J = { size: 0, viewer: T, array: U, offset: H, width: w.dataWindow[Y(2495)] - w.dataWindow[Y(1689)] + 1, height: w[Y(1198)][Y(2501)] - w[Y(1198)][Y(1812)] + 1, channels: w.channels[Y(3105)], bytesPerLine: null, lines: null, inputSize: null, type: w.channels[0].pixelType, uncompress: null, getter: null, format: null, encoding: null };
      switch (w[Y(611)]) {
        case Y(2093):
          J[Y(1410)] = 1, J[Y(2147)] = E;
          break;
        case Y(2791):
          J[Y(1410)] = 1, J[Y(2147)] = j;
          break;
        case "ZIPS_COMPRESSION":
          J[Y(1410)] = 1, J[Y(2147)] = R;
          break;
        case "ZIP_COMPRESSION":
          J[Y(1410)] = 16, J[Y(2147)] = R;
          break;
        case Y(1094):
          J[Y(1410)] = 32, J[Y(2147)] = h0;
          break;
        case Y(978):
          J[Y(1410)] = 16, J[Y(2147)] = S0;
          break;
        case "DWAA_COMPRESSION":
          J[Y(1410)] = 32, J[Y(2147)] = R0;
          break;
        case "DWAB_COMPRESSION":
          J.lines = 256, J[Y(2147)] = R0;
          break;
        default:
          throw new Error(Y(2788) + w.compression + " is unsupported");
      }
      if (J.scanlineBlockSize = J.lines, J[Y(566)] == 1)
        switch (i0) {
          case ae:
            J[Y(879)] = A0, J[Y(1766)] = g;
            break;
          case ue:
            J[Y(879)] = t0, J[Y(1766)] = g;
            break;
        }
      else if (J.type == 2)
        switch (i0) {
          case ae:
            J.getter = cx, J.inputSize = y;
            break;
          case ue:
            J[Y(879)] = k, J.inputSize = y;
        }
      else
        throw new Error(Y(1911) + J.type + Y(2746) + w.compression + ".");
      J[Y(1578)] = (w.dataWindow[Y(2501)] + 1) / J.scanlineBlockSize;
      for (let T0 = 0; T0 < J[Y(1578)]; T0++)
        sx(T, H);
      J[Y(1779)] = J[Y(2273)] == 3 ? 4 : J.channels;
      const f0 = J[Y(1631)] * J[Y(1674)] * J[Y(1779)];
      switch (i0) {
        case ae:
          J[Y(3370)] = new Float32Array(f0), J.channels < J[Y(1779)] && J[Y(3370)][Y(1314)](1, 0, f0);
          break;
        case ue:
          J.byteArray = new Uint16Array(f0), J.channels < J[Y(1779)] && J[Y(3370)][Y(1314)](15360, 0, f0);
          break;
        default:
          console[Y(533)](Y(3777), i0);
          break;
      }
      return J[Y(888)] = J.width * J.inputSize * J[Y(2273)], J[Y(1779)] == 4 ? (J.format = le, J[Y(523)] = Ne) : (J[Y(448)] = y2, J[Y(523)] = Ne), J;
    }
    const di = new DataView(e), O = new Uint8Array(e), K = { value: 0 }, Z = sn(di, e, K), D = Ba(Z, di, O, K, this[x(566)]), W = { value: 0 }, F = { R: 0, G: 1, B: 2, A: 3, Y: 0 };
    for (let w = 0; w < D[x(1674)] / D[x(2042)]; w++) {
      const T = j0(di, K);
      D[x(3073)] = j0(di, K), D[x(1410)] = T + D.scanlineBlockSize > D[x(1674)] ? D.height - T : D.scanlineBlockSize;
      const U = D.size < D.lines * D.bytesPerLine, H = U ? D[x(2147)](D) : E(D);
      K[x(1811)] += D[x(3073)];
      for (let i0 = 0; i0 < D.scanlineBlockSize; i0++) {
        const Y = i0 + w * D[x(2042)];
        if (Y >= D[x(1674)])
          break;
        for (let J = 0; J < D[x(2273)]; J++) {
          const f0 = F[Z[x(2273)][J].name];
          for (let T0 = 0; T0 < D[x(1631)]; T0++) {
            W[x(1811)] = (i0 * (D[x(2273)] * D[x(1631)]) + J * D[x(1631)] + T0) * D[x(1766)];
            const g0 = (D[x(1674)] - 1 - Y) * (D.width * D.outputChannels) + T0 * D[x(1779)] + f0;
            D[x(3370)][g0] = D.getter(H, W);
          }
        }
      }
    }
    return { header: Z, width: D[x(1631)], height: D[x(1674)], data: D[x(3370)], format: D[x(448)], encoding: D[x(523)], type: this.type };
  }
  [s(2820)](e) {
    const x = s;
    return this[x(566)] = e, this;
  }
  [s(3442)](e, x, t, i) {
    function n(a, r) {
      const o = c0;
      a[o(523)] = r.encoding, a[o(991)] = Cx, a[o(999)] = Cx, a[o(3632)] = ![], a[o(1739)] = ![], x && x(a, r);
    }
    return super.load(e, n, t, i);
  }
}
class Js {
  static [s(438)](e, x) {
    return Math.random() * (x - e) + e;
  }
  static [s(2484)](e, x) {
    const t = s;
    return Math[t(1981)](Math[t(3116)]() * (x - e) + e);
  }
  static [s(3193)](e, x, t, i) {
    const n = e + e, a = x + x, r = t + t, o = e * a, c = e * r, h = x * r, f = i * n, u = i * a, l = i * r;
    return { x: o - l, y: h + f, z: c - u };
  }
  static [s(3644)](e, x, t, i, n) {
    return (e - x) * (n - i) / (t - x) + i;
  }
  static average(e) {
    const x = s;
    let t = 0;
    return e.forEach((i) => {
      t += i;
    }), t / e[x(3105)];
  }
}
class Q3 {
  constructor(e, x, t) {
    const i = s;
    this[i(1280)] = t, this[i(1352)] = e, this[i(3054)] = x, this[i(959)] = { interactables: [], bg: [], player: null }, this[i(1815)] = { looping: [], onClick: [], onHover: [], camera: [] }, this[i(2938)] = [], this.wrapScene(this.models), this[i(976)](this.wrappedSceneZones);
  }
  wrapScene(e) {
    const x = s, t = { interactables: [], bgMesh: [], player: null }, i = [];
    for (let n = 0; n < e[x(3105)]; n++) {
      const a = e[n], r = a[x(3284)].userData;
      let o = {};
      const c = this[x(3162)](r, a.name);
      switch (r[x(566)]) {
        case x(1897):
          o = this.getInteractableObject(a, r, c), t.interactables[x(3156)](o);
          break;
        case x(2664):
          o = this[x(1392)](a, r), i[x(3156)](o);
          break;
        case x(1497):
          t[x(1497)][x(3156)](a.model);
          break;
        case "raycastMesh":
          t[x(1497)][x(3156)](a.model);
          break;
        case x(1007):
          t[x(1007)] = a[x(3284)];
          break;
      }
    }
    this[x(959)] = t, this.wrappedSceneZones = i;
  }
  [s(976)](e) {
    const x = s, t = [...e];
    for (let i = 0; i < t[x(3105)]; i++) {
      const n = t[i], a = n[x(3571)], r = this[x(2161)](n[x(2235)]);
      r[x(3105)] <= 0 && this[x(2648)](n.zone).forEach((u) => {
        r[x(3156)](u);
      });
      const o = this[x(2852)](r), c = new z();
      o[x(1658)](c);
      const h = new z();
      o[x(561)](h), t[i][x(1112)] = a, t[i][x(2282)] = o, t[i][x(854)] = h, t[i][x(473)] = c;
    }
    this[x(2938)] = t;
  }
  [s(2542)](e) {
    const x = s;
    let t = null;
    return this[x(2938)][x(1220)]((i) => {
      i[x(3678)] === e && (t = i);
    }), t;
  }
  getSceneZoneByName(e) {
    const x = s;
    let t = null, i = null;
    return this[x(2938)][x(1220)]((n) => {
      n[x(2235)] === e && (t = n);
    }), { zoneBox: t, index: i };
  }
  getLoopingAnimations() {
    const e = s, x = { looping: [] };
    return this.wrappedAnimations[e(3551)][e(1220)]((t) => {
      t.animations.forEach((i) => {
        x[c0(3551)].push(i);
      });
    }), x;
  }
  [s(2856)]() {
    return this.wrappedAnimations;
  }
  [s(3425)]() {
    const e = s;
    return this.wrappedModels[e(1007)];
  }
  [s(1883)]() {
    const e = s;
    return this[e(959)][e(1418)];
  }
  getInteractablesByZone(e) {
    const x = s, t = [];
    for (let i = 0; i < this[x(959)][x(1418)][x(3105)]; i++) {
      const n = this[x(959)][x(1418)][i];
      n[x(2235)] === e && t[x(3156)](n);
    }
    return t;
  }
  [s(2161)](e) {
    const x = s, t = [];
    for (let i = 0; i < this[x(959)][x(1418)][x(3105)]; i++) {
      const n = this.wrappedModels.interactables[i];
      n.zone === e && t[x(3156)](n.element[x(3284)]);
    }
    return t;
  }
  getBackgroundModelsByZone(e) {
    const x = s, t = [];
    for (let i = 0; i < this[x(959)][x(1497)][x(3105)]; i++) {
      const n = this.wrappedModels[x(1497)][i];
      n.type === x(3676) ? n[x(3049)][x(1220)]((a) => {
        const r = x;
        n[r(2066)][r(2235)] === e && t[r(3156)](a);
      }) : n[x(2066)][x(2235)] === e && t[x(3156)](n);
    }
    return t;
  }
  [s(2852)](e) {
    const x = s, t = new at();
    e[x(566)] === x(3676) && (e = [...e[x(3049)]]);
    for (let i = 0; i < e.length; i++) {
      const n = e[i];
      t[x(1179)](n);
    }
    return t;
  }
  getModel(e) {
    const x = s;
    for (let t = 0; t < this.models[x(3105)]; t++) {
      const i = this[x(1352)][t][x(3284)];
      if (i[x(3710)] === e)
        return i;
    }
    return null;
  }
  getAnimation(e) {
    const x = s;
    for (let t = 0; t < this[x(1280)][x(3105)]; t++) {
      const i = this[x(1280)][t];
      if (i[x(3710)] === e)
        return i;
    }
    return null;
  }
  [s(2153)](e) {
    const x = s, t = e[x(2742)](","), i = [];
    for (let n = 0; n < t[x(3105)]; n++) {
      const a = t[n];
      i[x(3156)](this.getAnimation(a));
    }
    return i;
  }
  getAnimationTrack(e, x) {
    const t = s;
    for (let i = 0; i < e[t(1823)].length; i++)
      if (e[t(1823)][i][t(3710)] === x)
        return e[t(1823)][i];
    return null;
  }
  [s(3400)](e) {
    const x = s, t = { position: null, rotation: null };
    for (let i = 0; i < e[x(2189)].length; i++) {
      const n = e[x(2189)][i];
      for (let a = 0; a < n[x(1823)][x(3105)]; a++) {
        const r = n[x(1823)][a];
        if (r.name[x(1684)](x(2888)))
          t[x(3571)] = new z(r.values[0], r[x(910)][1], r[x(910)][2]);
        else if (r[x(3710)].includes(".quaternion")) {
          const o = new $x(r[x(910)][0], r[x(910)][1], r[x(910)][2], r[x(910)][3]);
          t.rotation = o;
        }
      }
    }
    return t;
  }
  getAnimations(e, x) {
    const t = s;
    let i = null, n = null, a = null, r = null;
    return t(3481) in e && (i = this.getAnimationsFromCSV(e.loopAnimations), this[t(1815)][t(3551)].push({ name: x, animations: i })), t(508) in e && (n = this[t(2153)](e[t(508)]), this[t(1815)][t(1738)][t(3156)]({ name: x, animations: n })), t(2075) in e && (a = this[t(2153)](e[t(2075)]), this[t(1815)][t(3021)][t(3156)]({ name: x, animations: a })), t(1655) in e && (r = this[t(2153)](e.cameraAnimations), this[t(1815)][t(2189)][t(3156)]({ name: x, animations: r })), { loopAnimations: i, onHoverAnimations: a, onClickAnimations: n, cameraAnimations: r };
  }
  getInteractableObject(e, x, t) {
    const i = s, n = this[i(2208)](x[i(1809)]), a = { name: e[i(3710)], raycastTarget: n, element: e, animations: {}, zone: x[i(2235)] };
    return t[i(2075)] !== null && (a[i(1280)][i(3021)] = t[i(2075)]), t[i(508)] !== null && (a[i(1280)].onClick = t[i(508)]), t[i(1655)] !== null && (a[i(1280)][i(2189)] = t[i(1655)]), a;
  }
  [s(1392)](e, x) {
    const t = s, i = { zone: x[t(2235)], index: parseInt(x[t(3678)], 10), position: e[t(3284)][t(3571)] };
    return e[t(3284)].visible = ![], i;
  }
  [s(2208)](e) {
    const x = s, t = this.getModel(e);
    return t == null ? (console[x(2773)](x(2368), e), null) : (t[x(1870)].side = re, t[x(1870)].visible = ![], t);
  }
}
class xg {
  async [s(1359)](e) {
    const x = s;
    let t = null;
    return await fetch(e)[x(1941)]((i) => i[x(3143)]())[x(1941)]((i) => {
      t = i;
    }), t;
  }
}
class eg {
  constructor(e, x, t) {
    const i = s;
    this[i(662)] = e, this.renderer = x, this[i(2877)] = t, this.sceneWrapper;
    const n = new U3();
    if (n.setDecoderPath(i(948)), this[i(2728)] = new n3(), this[i(2728)][i(2726)](n), window.DEBUG) {
      const a = new kh(5e3);
      this.scene[i(3026)](a);
    }
  }
  [s(1636)]() {
    return this.sceneWrapper;
  }
  async [s(3510)]() {
    const e = s;
    return await new xg()[e(1359)](this[e(2877)]);
  }
  async build(e) {
    const x = s, t = await this[x(3510)](), i = [], n = [], a = await this[x(2737)](t.models, e), r = this[x(3577)](t[x(3054)]);
    return r.push(...a[x(3054)]), i.push(...a.models), n[x(3156)](...a[x(1280)]), this[x(2644)] = new Q3(i, r, n), this[x(2644)];
  }
  async [s(2737)](e, x) {
    const t = s, i = [], n = [], a = [];
    for (let r = 0; r < e[t(3105)]; r++) {
      const o = e[r], c = function(h) {
        const f = t;
        x(r + 1, e[f(3105)], 100 * h[f(1788)] / h[f(1377)]);
      };
      await this[t(923)](o, c).then((h) => {
        const f = t;
        window[f(2320)] && console[f(2773)](f(941), [...h.gltf[f(662)][f(3049)]]);
        const u = this[f(1378)](h);
        i[f(3156)](...u.models), n[f(3156)](...u.lights), a[f(3156)](...u.animations);
      });
    }
    return { models: i, lights: n, animations: a };
  }
  getModel(e, x) {
    const t = s;
    for (let i = 0; i < e[t(3105)]; i++) {
      const n = e[i];
      if (n.name === x)
        return n;
    }
    return null;
  }
  [s(1651)](e, x) {
    const t = s, i = { name: e[t(3710)], model: e };
    switch (this[t(1054)](e, x), e[t(2721)] = x[t(2721)], e[t(1719)] = x[t(1719)], e[t(2066)][t(566)]) {
      case t(1497):
        break;
      case t(1897):
        const n = this[t(2401)](x, e[t(3710)]);
        i[t(1440)] = n.type, i[t(1040)] = n[t(1040)];
        break;
    }
    return i;
  }
  [s(1278)](e, x) {
    return { type: e, light: x };
  }
  [s(1378)](e) {
    const x = s, t = [...e[x(2582)][x(662)][x(3049)]], i = e[x(2582)][x(1280)], n = [], a = [], r = 1e5;
    for (let o = 0; o < t.length; o++) {
      const c = t[o];
      switch (c[x(479)].enableAll(), c.type) {
        case "Mesh":
          n[x(3156)](this[x(1651)](c, e[x(825)]));
          break;
        case x(3676):
          c[x(3049)][x(1220)]((h) => {
            const f = x;
            this[f(1054)](h, e[f(825)]);
          }), n[x(3156)](this[x(1651)](c, e[x(825)]));
          break;
        case x(3061):
          n[x(3156)](this.createModelContainer(c, e[x(825)]));
          break;
        case x(3496):
          c[x(1798)] /= r, a[x(3156)](this[x(1278)](x(1482), c));
          break;
        case x(1119):
          c[x(1798)] /= r, a.push(this.createLightContainer(x(3705), c));
          break;
        case "SpotLight":
          c[x(1798)] /= r, a[x(3156)](this[x(1278)](x(1337), c));
          break;
        default:
          console[x(2773)](x(757), c);
          break;
      }
      this[x(662)].add(c);
    }
    return { models: n, lights: a, animations: i };
  }
  [s(1054)](e, x) {
    const t = s;
    e[t(3571)][t(1260)](e[t(3571)].x + x[t(3571)].x, e[t(3571)].y + x[t(3571)].y, e[t(3571)].z + x[t(3571)].z), e[t(3055)][t(1260)](x[t(591)].x, x[t(591)].y, x[t(591)].z, x.rotation.w), e[t(2204)][t(1260)](x.scale.x, x[t(2204)].y, x[t(2204)].z);
  }
  getHtml(e, x) {
    const t = s, i = this[t(1753)](e, x);
    if (i[t(1040)] !== void 0)
      return i.type === t(3456) && (i[t(1040)] = '<iframe id="XYZ3d-fullscreen" src="' + i[t(1040)] + t(1052)), i;
  }
  [s(1753)](e, x) {
    const t = s, i = e[t(3248)];
    for (let n = 0; n < i[t(3105)]; n++) {
      const a = i[n];
      if (a.modelName === x)
        return a;
    }
    return null;
  }
  async [s(923)](e, x) {
    return new Promise((t) => {
      const i = c0;
      return this[i(2728)].load(".." + e[i(597)], function(n) {
        t({ gltf: n, jsonData: e });
      }, x, function(n) {
        console[i(2773)]("An error happened " + n);
      });
    });
  }
  [s(3577)](e) {
    const x = s, t = [];
    for (let i = 0; i < e[x(3105)]; i++) {
      const n = e[i];
      let a, r;
      const o = { type: null, light: null };
      switch (n[x(566)]) {
        case x(496):
          this.addHDR(n[x(597)], n[x(2217)], n.backgroundBlurriness);
          break;
        case x(2216):
          this.addEXR(n[x(597)], n[x(2217)], n[x(2812)]);
          break;
        case x(2243):
          a = new z(n.position.x, n.position.y, n[x(3571)].z), r = this.addPointLight(a, n[x(3282)], n[x(1798)], n[x(3073)], n[x(2721)]), o.type = x(2243), o[x(1288)] = r;
          break;
        case "directionalLight":
          a = new z(n[x(3571)].x, n.position.y, n[x(3571)].z);
          const c = new z(n.target.x, n[x(671)].y, n.target.z);
          r = this[x(1693)](a, c, n[x(3282)], n.intensity, n.castShadow), o[x(566)] = "directionalLight", o[x(1288)] = r;
          break;
        case x(2414):
          r = this[x(2497)](n.color, n.intensity), o[x(566)] = x(2414), o.light = r;
          break;
      }
      t[x(3156)](o);
    }
    return t;
  }
  [s(2365)](e, x = 0, t = 1, i = 1500, n = ![]) {
    const a = s, r = new Da(x, t, i);
    if (r.position[a(2841)](e, 1), r[a(2721)] = n, r.normalBias = 0.1, this.scene[a(3026)](r), window[a(2320)]) {
      const o = new Gh(r, 0.25);
      this[a(662)][a(3026)](o);
    }
    return r;
  }
  [s(2497)](e = 0, x = 1) {
    const t = s, i = new eo(e, x);
    return this[t(662)][t(3026)](i), i;
  }
  [s(1693)](e, x = new z(0, 0, 0), t = 16777215, i = 2, n = ![]) {
    const a = s, r = new Oa(t, i);
    if (r[a(3571)][a(2841)](e, 1), r[a(671)][a(3571)][a(2841)](x, 1), r[a(2721)] = n, r[a(3094)] = 0.1, this.scene[a(3026)](r), this[a(662)][a(3026)](r.target), window.DEBUG) {
      const o = new Hh(r);
      this.scene[a(3026)](o);
    }
    return r;
  }
  [s(723)](e, x, t) {
    const i = s, n = new Bn(this[i(2863)]);
    n[i(3092)]();
    let a;
    new B3()[i(3442)](".." + e, (r) => {
      const o = i;
      a = n[o(577)](r).texture, this[o(662)][o(3169)] = a, this.scene[o(2525)] = a, this[o(662)][o(2217)] = x, this[o(662)][o(2812)] = t, r[o(3387)](), n[o(3387)]();
    });
  }
  addEXR(e, x, t) {
    const i = s, n = new Bn(this[i(2863)]);
    n[i(3092)]();
    let a;
    new J3()[i(3442)](".." + e, (r) => {
      const o = i;
      r[o(667)] = Gi, a = n[o(577)](r)[o(2431)], this[o(662)][o(3169)] = a, this[o(662)][o(2525)] = a, this[o(662)][o(2217)] = x, this[o(662)][o(2812)] = t, r.dispose(), n[o(3387)]();
    });
  }
}
class ds {
  constructor() {
    const e = s;
    this[e(2679)] = !![], this[e(2827)] = !![], this[e(1089)] = ![], this[e(2612)] = ![];
  }
  [s(531)]() {
  }
  render() {
    console.error(s(3663));
  }
  [s(3387)]() {
  }
}
const tg = new Ji(-1, 1, 1, -1, 0, 1), b2 = new ox();
b2[s(3599)](s(3571), new W0([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), b2[s(3599)]("uv", new W0([0, 2, 0, 0, 2, 0], 2));
class $h {
  constructor(e) {
    const x = s;
    this[x(1977)] = new Wx(b2, e);
  }
  dispose() {
    const e = s;
    this[e(1977)][e(1353)][e(3387)]();
  }
  render(e) {
    const x = s;
    e.render(this[x(1977)], tg);
  }
  get material() {
    const e = s;
    return this[e(1977)][e(1870)];
  }
  set [s(1870)](e) {
    const x = s;
    this[x(1977)][x(1870)] = e;
  }
}
const Jh = { uniforms: { tDiffuse: { value: null }, opacity: { value: 1 } }, vertexShader: s(3153), fragmentShader: `

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			gl_FragColor = texture2D( tDiffuse, vUv );
			gl_FragColor.a *= opacity;


		}` }, ig = { shaderID: s(3478), uniforms: { tDiffuse: { value: null }, luminosityThreshold: { value: 1 }, smoothWidth: { value: 1 }, defaultColor: { value: new P0(0) }, defaultOpacity: { value: 0 } }, vertexShader: s(2053), fragmentShader: `

		uniform sampler2D tDiffuse;
		uniform vec3 defaultColor;
		uniform float defaultOpacity;
		uniform float luminosityThreshold;
		uniform float smoothWidth;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );

			vec3 luma = vec3( 0.299, 0.587, 0.114 );

			float v = dot( texel.xyz, luma );

			vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );

			float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );

			gl_FragColor = mix( outputColor, texel, alpha );

		}` };
class Zi extends ds {
  constructor(e, x, t, i) {
    const n = s;
    super(), this[n(3218)] = x !== void 0 ? x : 1, this[n(1232)] = t, this.threshold = i, this.resolution = e !== void 0 ? new d0(e.x, e.y) : new d0(256, 256), this[n(2557)] = new P0(0, 0, 0), this.renderTargetsHorizontal = [], this.renderTargetsVertical = [], this[n(778)] = 5;
    let a = Math[n(1981)](this.resolution.x / 2), r = Math.round(this.resolution.y / 2);
    this[n(3544)] = new oe(a, r), this[n(3544)][n(2431)][n(3710)] = "UnrealBloomPass.bright", this.renderTargetBright[n(2431)][n(3632)] = ![];
    for (let u = 0; u < this[n(778)]; u++) {
      const l = new oe(a, r);
      l[n(2431)][n(3710)] = n(1191) + u, l[n(2431)][n(3632)] = ![], this[n(1009)][n(3156)](l);
      const _ = new oe(a, r);
      _[n(2431)][n(3710)] = n(819) + u, _[n(2431)].generateMipmaps = ![], this[n(3801)][n(3156)](_), a = Math.round(a / 2), r = Math[n(1981)](r / 2);
    }
    const o = ig;
    this[n(2424)] = zn[n(2272)](o[n(2833)]), this[n(2424)][n(722)][n(1811)] = i, this[n(2424)][n(3059)][n(1811)] = 0.01, this[n(3173)] = new ee({ uniforms: this[n(2424)], vertexShader: o[n(2377)], fragmentShader: o[n(2489)], defines: {} }), this.separableBlurMaterials = [];
    const c = [3, 5, 7, 9, 11];
    a = Math[n(1981)](this[n(613)].x / 2), r = Math[n(1981)](this[n(613)].y / 2);
    for (let u = 0; u < this.nMips; u++)
      this[n(2831)][n(3156)](this[n(3408)](c[u])), this[n(2831)][u][n(2833)][n(1807)][n(1811)] = new d0(a, r), a = Math[n(1981)](a / 2), r = Math.round(r / 2);
    this[n(1534)] = this[n(887)](this[n(778)]), this[n(1534)][n(2833)].blurTexture1[n(1811)] = this.renderTargetsVertical[0].texture, this[n(1534)][n(2833)][n(3794)][n(1811)] = this[n(3801)][1][n(2431)], this.compositeMaterial[n(2833)].blurTexture3[n(1811)] = this[n(3801)][2][n(2431)], this[n(1534)][n(2833)].blurTexture4[n(1811)] = this.renderTargetsVertical[3][n(2431)], this[n(1534)][n(2833)][n(3741)][n(1811)] = this[n(3801)][4].texture, this[n(1534)][n(2833)][n(3514)][n(1811)] = x, this[n(1534)][n(2833)][n(2194)][n(1811)] = 0.1, this[n(1534)][n(3035)] = !![];
    const h = [1, 0.8, 0.6, 0.4, 0.2];
    this.compositeMaterial[n(2833)].bloomFactors[n(1811)] = h, this[n(1406)] = [new z(1, 1, 1), new z(1, 1, 1), new z(1, 1, 1), new z(1, 1, 1), new z(1, 1, 1)], this[n(1534)].uniforms[n(1406)][n(1811)] = this[n(1406)];
    const f = Jh;
    this[n(3532)] = zn[n(2272)](f[n(2833)]), this[n(3532)][n(3746)][n(1811)] = 1, this[n(3288)] = new ee({ uniforms: this[n(3532)], vertexShader: f[n(2377)], fragmentShader: f[n(2489)], blending: ha, depthTest: ![], depthWrite: ![], transparent: !![] }), this[n(2679)] = !![], this[n(2827)] = ![], this[n(1143)] = new P0(), this[n(2110)] = 1, this.basic = new be(), this.fsQuad = new $h(null);
  }
  dispose() {
    const e = s;
    for (let x = 0; x < this[e(1009)][e(3105)]; x++)
      this[e(1009)][x][e(3387)]();
    for (let x = 0; x < this[e(3801)][e(3105)]; x++)
      this[e(3801)][x][e(3387)]();
    this.renderTargetBright[e(3387)]();
    for (let x = 0; x < this[e(2831)][e(3105)]; x++)
      this.separableBlurMaterials[x][e(3387)]();
    this[e(1534)].dispose(), this.materialCopy[e(3387)](), this.basic[e(3387)](), this[e(2453)][e(3387)]();
  }
  [s(531)](e, x) {
    const t = s;
    let i = Math[t(1981)](e / 2), n = Math[t(1981)](x / 2);
    this[t(3544)][t(531)](i, n);
    for (let a = 0; a < this.nMips; a++)
      this.renderTargetsHorizontal[a][t(531)](i, n), this.renderTargetsVertical[a][t(531)](i, n), this[t(2831)][a][t(2833)][t(1807)][t(1811)] = new d0(i, n), i = Math[t(1981)](i / 2), n = Math.round(n / 2);
  }
  [s(489)](e, x, t, i, n) {
    const a = s;
    e[a(672)](this[a(1143)]), this[a(2110)] = e.getClearAlpha();
    const r = e[a(1363)];
    e[a(1363)] = ![], e[a(3203)](this[a(2557)], 0), n && e[a(739)][a(2563)][a(1632)][a(2942)](![]), this[a(2612)] && (this[a(2453)][a(1870)] = this[a(2125)], this[a(2125)][a(3644)] = t.texture, e[a(2969)](null), e[a(1089)](), this[a(2453)][a(489)](e)), this[a(2424)][a(2900)][a(1811)] = t.texture, this[a(2424)][a(722)][a(1811)] = this.threshold, this.fsQuad.material = this.materialHighPassFilter, e[a(2969)](this[a(3544)]), e[a(1089)](), this.fsQuad[a(489)](e);
    let o = this[a(3544)];
    for (let c = 0; c < this[a(778)]; c++)
      this[a(2453)].material = this[a(2831)][c], this[a(2831)][c][a(2833)][a(2224)][a(1811)] = o.texture, this[a(2831)][c][a(2833)][a(2847)][a(1811)] = Zi[a(3796)], e[a(2969)](this.renderTargetsHorizontal[c]), e[a(1089)](), this[a(2453)][a(489)](e), this[a(2831)][c].uniforms[a(2224)][a(1811)] = this[a(1009)][c].texture, this[a(2831)][c][a(2833)].direction[a(1811)] = Zi[a(1852)], e[a(2969)](this.renderTargetsVertical[c]), e[a(1089)](), this.fsQuad.render(e), o = this.renderTargetsVertical[c];
    this[a(2453)][a(1870)] = this[a(1534)], this[a(1534)][a(2833)][a(3514)][a(1811)] = this[a(3218)], this[a(1534)][a(2833)][a(2194)][a(1811)] = this[a(1232)], this.compositeMaterial[a(2833)][a(1406)][a(1811)] = this[a(1406)], e.setRenderTarget(this.renderTargetsHorizontal[0]), e[a(1089)](), this[a(2453)][a(489)](e), this[a(2453)][a(1870)] = this[a(3288)], this[a(3532)][a(2900)][a(1811)] = this[a(1009)][0][a(2431)], n && e[a(739)][a(2563)].stencil[a(2942)](!![]), this.renderToScreen ? (e[a(2969)](null), this[a(2453)][a(489)](e)) : (e[a(2969)](t), this[a(2453)][a(489)](e)), e.setClearColor(this[a(1143)], this[a(2110)]), e[a(1363)] = r;
  }
  [s(3408)](e) {
    const x = s;
    return new ee({ defines: { KERNEL_RADIUS: e, SIGMA: e }, uniforms: { colorTexture: { value: null }, texSize: { value: new d0(0.5, 0.5) }, direction: { value: new d0(0.5, 0.5) } }, vertexShader: x(691), fragmentShader: x(1092) });
  }
  [s(887)](e) {
    const x = s;
    return new ee({ defines: { NUM_MIPS: e }, uniforms: { blurTexture1: { value: null }, blurTexture2: { value: null }, blurTexture3: { value: null }, blurTexture4: { value: null }, blurTexture5: { value: null }, bloomStrength: { value: 1 }, bloomFactors: { value: null }, bloomTintColors: { value: null }, bloomRadius: { value: 0 } }, vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`, fragmentShader: x(3001) });
  }
}
Zi[s(3796)] = new d0(1, 0), Zi[s(1852)] = new d0(0, 1);
class ng extends ds {
  constructor(e, x, t, i, n) {
    const a = s;
    super(), this.scene = e, this[a(2189)] = x, this.overrideMaterial = t, this[a(2557)] = i, this[a(3063)] = n !== void 0 ? n : 0, this[a(1089)] = !![], this.clearDepth = ![], this[a(2827)] = ![], this[a(1143)] = new P0();
  }
  render(e, x, t) {
    const i = s, n = e[i(1363)];
    e[i(1363)] = ![];
    let a, r;
    this[i(3170)] !== void 0 && (r = this[i(662)][i(3170)], this[i(662)][i(3170)] = this.overrideMaterial), this.clearColor && (e[i(672)](this[i(1143)]), a = e.getClearAlpha(), e[i(3203)](this[i(2557)], this[i(3063)])), this.clearDepth && e[i(564)](), e[i(2969)](this[i(2612)] ? null : t), this[i(1089)] && e.clear(e[i(2e3)], e[i(3201)], e.autoClearStencil), e[i(489)](this[i(662)], this[i(2189)]), this[i(2557)] && e.setClearColor(this[i(1143)], a), this[i(3170)] !== void 0 && (this[i(662)].overrideMaterial = r), e[i(1363)] = n;
  }
}
class sg extends ds {
  constructor(e, x) {
    const t = s;
    super(), this[t(2757)] = x !== void 0 ? x : t(2900), e instanceof ee ? (this[t(2833)] = e[t(2833)], this[t(1870)] = e) : e && (this[t(2833)] = zn[t(2272)](e[t(2833)]), this[t(1870)] = new ee({ defines: Object[t(1188)]({}, e.defines), uniforms: this[t(2833)], vertexShader: e[t(2377)], fragmentShader: e[t(2489)] })), this.fsQuad = new $h(this[t(1870)]);
  }
  [s(489)](e, x, t) {
    const i = s;
    this[i(2833)][this[i(2757)]] && (this[i(2833)][this[i(2757)]][i(1811)] = t[i(2431)]), this[i(2453)][i(1870)] = this[i(1870)], this[i(2612)] ? (e[i(2969)](null), this[i(2453)][i(489)](e)) : (e.setRenderTarget(x), this.clear && e[i(1089)](e[i(2e3)], e[i(3201)], e.autoClearStencil), this.fsQuad[i(489)](e));
  }
  dispose() {
    const e = s;
    this[e(1870)].dispose(), this[e(2453)].dispose();
  }
}
class Nc extends ds {
  constructor(e, x) {
    const t = s;
    super(), this[t(662)] = e, this[t(2189)] = x, this[t(1089)] = !![], this.needsSwap = ![], this[t(3222)] = ![];
  }
  [s(489)](e, x, t) {
    const i = s, n = e.getContext(), a = e.state;
    a[i(2563)].color[i(926)](![]), a.buffers.depth[i(926)](![]), a.buffers[i(3282)].setLocked(!![]), a.buffers[i(3611)][i(1972)](!![]);
    let r, o;
    this[i(3222)] ? (r = 0, o = 1) : (r = 1, o = 0), a.buffers[i(1632)].setTest(!![]), a[i(2563)][i(1632)][i(2196)](n[i(3525)], n[i(3525)], n.REPLACE), a[i(2563)][i(1632)][i(562)](n[i(1323)], r, 4294967295), a[i(2563)].stencil[i(2139)](o), a.buffers.stencil[i(1972)](!![]), e[i(2969)](t), this.clear && e[i(1089)](), e[i(489)](this[i(662)], this[i(2189)]), e.setRenderTarget(x), this[i(1089)] && e[i(1089)](), e[i(489)](this[i(662)], this[i(2189)]), a[i(2563)][i(3282)][i(1972)](![]), a[i(2563)].depth[i(1972)](![]), a[i(2563)][i(1632)].setLocked(![]), a[i(2563)].stencil[i(562)](n[i(604)], 1, 4294967295), a[i(2563)][i(1632)].setOp(n.KEEP, n[i(2092)], n[i(2092)]), a[i(2563)][i(1632)][i(1972)](!![]);
  }
}
class ag extends ds {
  constructor() {
    const e = s;
    super(), this[e(2827)] = ![];
  }
  render(e) {
    const x = s;
    e.state[x(2563)][x(1632)].setLocked(![]), e[x(739)][x(2563)][x(1632)][x(2942)](![]);
  }
}
class rg {
  constructor(e, x) {
    const t = s;
    if (this[t(2863)] = e, x === void 0) {
      const i = e[t(561)](new d0());
      this[t(3472)] = e.getPixelRatio(), this[t(1083)] = i.width, this._height = i[t(1674)], x = new oe(this[t(1083)] * this[t(3472)], this[t(1405)] * this._pixelRatio), x.texture[t(3710)] = t(1958);
    } else
      this[t(3472)] = 1, this._width = x[t(1631)], this._height = x[t(1674)];
    this[t(3596)] = x, this.renderTarget2 = x[t(2272)](), this[t(2010)].texture[t(3710)] = "EffectComposer.rt2", this.writeBuffer = this[t(3596)], this.readBuffer = this[t(2010)], this[t(2612)] = !![], this.passes = [], this[t(1050)] = new sg(Jh), this[t(3484)] = new za();
  }
  [s(2162)]() {
    const e = s, x = this[e(2349)];
    this[e(2349)] = this[e(1266)], this[e(1266)] = x;
  }
  [s(3264)](e) {
    const x = s;
    this[x(1973)][x(3156)](e), e[x(531)](this[x(1083)] * this[x(3472)], this[x(1405)] * this._pixelRatio);
  }
  insertPass(e, x) {
    const t = s;
    this[t(1973)].splice(x, 0, e), e[t(531)](this._width * this[t(3472)], this._height * this[t(3472)]);
  }
  [s(1502)](e) {
    const x = s, t = this.passes.indexOf(e);
    t !== -1 && this.passes[x(1733)](t, 1);
  }
  [s(1902)](e) {
    const x = s;
    for (let t = e + 1; t < this.passes.length; t++)
      if (this[x(1973)][t][x(2679)])
        return ![];
    return !![];
  }
  [s(489)](e) {
    const x = s;
    e === void 0 && (e = this[x(3484)].getDelta());
    const t = this[x(2863)][x(427)]();
    let i = ![];
    for (let n = 0, a = this[x(1973)][x(3105)]; n < a; n++) {
      const r = this[x(1973)][n];
      if (r.enabled !== ![]) {
        if (r[x(2612)] = this[x(2612)] && this[x(1902)](n), r[x(489)](this.renderer, this[x(1266)], this[x(2349)], e, i), r[x(2827)]) {
          if (i) {
            const o = this[x(2863)].getContext(), c = this[x(2863)][x(739)][x(2563)][x(1632)];
            c[x(562)](o[x(1442)], 1, 4294967295), this[x(1050)].render(this[x(2863)], this[x(1266)], this[x(2349)], e), c[x(562)](o.EQUAL, 1, 4294967295);
          }
          this[x(2162)]();
        }
        Nc !== void 0 && (r instanceof Nc ? i = !![] : r instanceof ag && (i = ![]));
      }
    }
    this[x(2863)][x(2969)](t);
  }
  [s(2007)](e) {
    const x = s;
    if (e === void 0) {
      const t = this[x(2863)][x(561)](new d0());
      this[x(3472)] = this[x(2863)].getPixelRatio(), this._width = t[x(1631)], this[x(1405)] = t[x(1674)], e = this[x(3596)][x(2272)](), e[x(531)](this[x(1083)] * this[x(3472)], this[x(1405)] * this[x(3472)]);
    }
    this[x(3596)].dispose(), this[x(2010)].dispose(), this.renderTarget1 = e, this[x(2010)] = e[x(2272)](), this[x(1266)] = this.renderTarget1, this.readBuffer = this[x(2010)];
  }
  [s(531)](e, x) {
    const t = s;
    this[t(1083)] = e, this._height = x;
    const i = this[t(1083)] * this[t(3472)], n = this[t(1405)] * this[t(3472)];
    this[t(3596)][t(531)](i, n), this[t(2010)][t(531)](i, n);
    for (let a = 0; a < this[t(1973)][t(3105)]; a++)
      this[t(1973)][a][t(531)](i, n);
  }
  setPixelRatio(e) {
    const x = s;
    this[x(3472)] = e, this[x(531)](this[x(1083)], this._height);
  }
  [s(3387)]() {
    const e = s;
    this[e(3596)].dispose(), this[e(2010)][e(3387)](), this.copyPass[e(3387)]();
  }
}
class og {
  constructor(e, x) {
    const t = s;
    Lt[t(2679)] = !![], this[t(651)] = document.getElementById(e), !this.canvas && console[t(533)]("Canvas not found. Make sure this returns the correct element: document.GetElementByID(", e, t(872)), this.cameraParams = x, this[t(2745)] = x[t(3579)][t(2630)], this[t(1631)] = this[t(651)][t(2490)], this[t(1674)] = this.canvas[t(797)], this[t(2189)] = new Vx(this.cameraParams[t(3557)], this[t(1631)] / this[t(1674)], 0.1, 1e4), this.camera.name = t(2322), this[t(662)] = new O2(), this[t(2863)], this[t(1491)], this.bloomPass, this[t(1480)] = x.postEffects[t(2679)], this.setupRenderer(), this[t(1480)] && this[t(2685)]();
  }
  [s(868)]() {
    return this[s(2189)];
  }
  [s(3795)]() {
    return this[s(662)];
  }
  [s(1422)]() {
    return this.renderer;
  }
  setupRenderer() {
    const e = s;
    this[e(2863)] = new Ta({ canvas: this[e(651)], antialias: !![], powerPreference: e(922), failIfMajorPerformanceCaveat: !![] }), this.renderer[e(2445)][e(2679)] = !![], this[e(2189)][e(479)][e(960)](), this[e(2863)][e(531)](this[e(1631)], this[e(1674)]), this[e(2863)][e(602)] = _2, this[e(2863)].toneMappingExposure = Math[e(3196)](this[e(2745)].exposure, 4), this[e(2863)][e(878)] = 4;
  }
  [s(2685)]() {
    const e = s, x = new ng(this[e(662)], this[e(2189)]), t = new Zi(new d0(this[e(1631)], this.height), this[e(2745)][e(3218)], this[e(2745)][e(1232)], this[e(2745)].threshold);
    t[e(2307)] = this.bloomParams[e(2307)], t.threshold = this[e(2745)][e(556)], t[e(3218)] = this[e(2745)].strength, t[e(1232)] = this.bloomParams[e(1232)], this[e(1491)] = new rg(this.renderer), this[e(1491)][e(531)](this.width, this[e(1674)]), this[e(1491)][e(3264)](x), this.finalComposer[e(3264)](t);
  }
  onWindowResized() {
    const e = s;
    this[e(1631)] = this[e(651)][e(2490)], this[e(1674)] = this[e(651)].scrollHeight, this[e(2189)][e(2308)] = this[e(1631)] / this[e(1674)], this[e(2189)].updateProjectionMatrix(), this[e(2863)][e(531)](this[e(1631)], this[e(1674)]), this[e(1480)] && this[e(1491)].setSize(this.width, this.height);
  }
  reset() {
    this[s(1980)]();
  }
  [s(489)]() {
    const e = s;
    this.isPostEffectsEnabled ? this[e(1491)][e(489)]() : this.renderer[e(489)](this[e(662)], this[e(2189)]);
  }
}
const nx = { LEFT: 1, RIGHT: 2, MIDDLE: 4 }, o0 = Object[s(1169)]({ NONE: 0, ROTATE: 1, TRUCK: 2, OFFSET: 4, DOLLY: 8, ZOOM: 16, TOUCH_ROTATE: 32, TOUCH_TRUCK: 64, TOUCH_OFFSET: 128, TOUCH_DOLLY: 256, TOUCH_ZOOM: 512, TOUCH_DOLLY_TRUCK: 1024, TOUCH_DOLLY_OFFSET: 2048, TOUCH_DOLLY_ROTATE: 4096, TOUCH_ZOOM_TRUCK: 8192, TOUCH_ZOOM_OFFSET: 16384, TOUCH_ZOOM_ROTATE: 32768 });
function kt(d) {
  return d[s(2480)];
}
function pt(d) {
  return d[s(519)];
}
const Ci = Math.PI * 2, Uc = Math.PI / 2, Qh = 1e-5, yn = Math.PI / 180;
function Pi(d, e, x) {
  return Math.max(e, Math.min(x, d));
}
function Dx(d, e = Qh) {
  return Math[s(3373)](d) < e;
}
function Ix(d, e, x = Qh) {
  return Dx(d - e, x);
}
function zc(d, e) {
  return Math[s(1981)](d / e) * e;
}
function wn(d) {
  const e = s;
  return isFinite(d) ? d : d < 0 ? -Number[e(1445)] : Number[e(1445)];
}
function Mn(d) {
  const e = s;
  return Math[e(3373)](d) < Number[e(1445)] ? d : d * (1 / 0);
}
function Qs(d, e, x, t, i = 1 / 0, n) {
  const a = s;
  t = Math[a(1803)](1e-4, t);
  const r = 2 / t, o = r * n, c = 1 / (1 + o + 0.48 * o * o + 0.235 * o * o * o);
  let h = d - e;
  const f = e, u = i * t;
  h = Pi(h, -u, u), e = d - h;
  const l = (x[a(1811)] + r * h) * n;
  x[a(1811)] = (x.value - r * l) * c;
  let _ = e + (h + l) * c;
  return f - d > 0 == _ > f && (_ = f, x[a(1811)] = (_ - f) / n), _;
}
function Bc(d, e, x, t, i = 1 / 0, n, a) {
  const r = s;
  t = Math.max(1e-4, t);
  const o = 2 / t, c = o * n, h = 1 / (1 + c + 0.48 * c * c + 0.235 * c * c * c);
  let f = e.x, u = e.y, l = e.z, _ = d.x - f, p = d.y - u, m = d.z - l;
  const y = f, v = u, g = l, b = i * t, M = b * b, A = _ * _ + p * p + m * m;
  if (A > M) {
    const X = Math[r(713)](A);
    _ = _ / X * b, p = p / X * b, m = m / X * b;
  }
  f = d.x - _, u = d.y - p, l = d.z - m;
  const L = (x.x + o * _) * n, P = (x.y + o * p) * n, S = (x.z + o * m) * n;
  x.x = (x.x - o * L) * h, x.y = (x.y - o * P) * h, x.z = (x.z - o * S) * h, a.x = f + (_ + L) * h, a.y = u + (p + P) * h, a.z = l + (m + S) * h;
  const I = y - d.x, C = v - d.y, G = g - d.z, $ = a.x - y, N = a.y - v, V = a.z - g;
  return I * $ + C * N + G * V > 0 && (a.x = y, a.y = v, a.z = g, x.x = (a.x - y) / n, x.y = (a.y - v) / n, x.z = (a.z - g) / n), a;
}
function Mr(d, e) {
  const x = s;
  e.set(0, 0), d.forEach((t) => {
    const i = c0;
    e.x += t[i(1507)], e.y += t[i(2662)];
  }), e.x /= d[x(3105)], e.y /= d[x(3105)];
}
function Sr(d, e) {
  const x = s;
  return pt(d) ? (console[x(3629)](e + " is not supported in OrthographicCamera"), !![]) : ![];
}
class cg {
  constructor() {
    this._listeners = {};
  }
  [s(818)](e, x) {
    const t = s, i = this[t(2897)];
    i[e] === void 0 && (i[e] = []), i[e][t(882)](x) === -1 && i[e].push(x);
  }
  hasEventListener(e, x) {
    const t = s, i = this[t(2897)];
    return i[e] !== void 0 && i[e][t(882)](x) !== -1;
  }
  [s(1079)](e, x) {
    const t = s, i = this[t(2897)], n = i[e];
    if (n !== void 0) {
      const a = n.indexOf(x);
      a !== -1 && n.splice(a, 1);
    }
  }
  removeAllEventListeners(e) {
    const x = s;
    if (!e) {
      this._listeners = {};
      return;
    }
    Array[x(1609)](this[x(2897)][e]) && (this[x(2897)][e][x(3105)] = 0);
  }
  [s(3157)](e) {
    const x = s, t = this._listeners, i = t[e.type];
    if (i !== void 0) {
      e[x(671)] = this;
      const n = i.slice(0);
      for (let a = 0, r = n.length; a < r; a++)
        n[a].call(this, e);
    }
  }
}
const dg = s(554), xa = 1 / 8, xf = typeof window !== s(2011), hg = xf && /Mac/[s(1081)](navigator[s(877)]), fg = !(xf && s(1419) in window);
let tx, Fc, ea, Tr, fe, rx, Tx, Li, Ge, He, Vt, Gc, Hc, Ie, Sn, Ri, kc, Er, Vc, Ar, Cr, ta;
class xi extends cg {
  static install(e) {
    const x = s;
    tx = e[x(2947)], Fc = Object[x(1169)](new tx.Vector3(0, 0, 0)), ea = Object[x(1169)](new tx[x(3099)](0, 1, 0)), Tr = Object[x(1169)](new tx[x(3099)](0, 0, 1)), fe = new tx[x(2374)](), rx = new tx[x(3099)](), Tx = new tx[x(3099)](), Li = new tx[x(3099)](), Ge = new tx[x(3099)](), He = new tx[x(3099)](), Vt = new tx[x(3099)](), Gc = new tx[x(3099)](), Hc = new tx[x(3099)](), Ie = new tx[x(505)](), Sn = new tx[x(505)](), Ri = new tx[x(1673)](), kc = new tx[x(1673)](), Er = new tx[x(924)](), Vc = new tx[x(826)](), Ar = new tx[x(826)](), Cr = new tx[x(3699)](), ta = new tx[x(3414)]();
  }
  static get [s(1137)]() {
    return o0;
  }
  constructor(e, x) {
    const t = s;
    super(), this[t(3433)] = 0, this.maxPolarAngle = Math.PI, this[t(1483)] = -1 / 0, this[t(3461)] = 1 / 0, this.minDistance = 0, this[t(2691)] = 1 / 0, this.infinityDolly = ![], this[t(844)] = 0.01, this[t(1620)] = 1 / 0, this[t(3523)] = 0.25, this[t(3423)] = 0.125, this[t(3045)] = 1 / 0, this[t(3518)] = 1, this[t(3381)] = 1, this.dollySpeed = 1, this[t(1654)] = 2, this.dollyToCursor = ![], this[t(3184)] = ![], this.verticalDragToForward = ![], this[t(2402)] = 0, this[t(2704)] = 0.01, this[t(502)] = [], this[t(1228)] = () => {
    }, this._enabled = !![], this[t(2530)] = o0[t(2415)], this[t(1342)] = null, this[t(2021)] = 0, this._hasRested = !![], this[t(1985)] = ![], this._needsUpdate = !![], this[t(2178)] = ![], this[t(2038)] = new DOMRect(), this[t(3318)] = [], this[t(558)] = ![], this[t(3763)] = ![], this._isUserControllingTruck = ![], this[t(2200)] = ![], this[t(2585)] = ![], this[t(2658)] = { value: 0 }, this[t(3046)] = { value: 0 }, this[t(3172)] = { value: 0 }, this[t(2440)] = new tx[t(3099)](), this[t(968)] = new tx.Vector3(), this._zoomVelocity = { value: 0 }, this[t(2645)] = (g, b, M) => {
      const A = t;
      if (kt(this[A(3606)])) {
        const L = rx[A(2875)](this[A(3606)][A(3571)])[A(1943)](this[A(1330)]), P = this[A(3606)][A(2291)]() * yn, S = L[A(3105)]() * Math[A(745)](P * 0.5), I = this[A(1654)] * g * S / this[A(2038)].height, C = this[A(1654)] * b * S / this._elementRect[A(1674)];
        this.verticalDragToForward ? (M ? this[A(1789)](this[A(767)].x + I, this[A(767)].y, this[A(767)].z, !![]) : this[A(1992)](I, 0, !![]), this[A(688)](-C, !![])) : M ? this[A(1789)](this[A(767)].x + I, this[A(767)].y + C, this[A(767)].z, !![]) : this[A(1992)](I, C, !![]);
      } else if (pt(this[A(3606)])) {
        const L = this._camera, P = g * (L[A(3383)] - L[A(1640)]) / L[A(2477)] / this[A(2038)].width, S = b * (L[A(1376)] - L.bottom) / L[A(2477)] / this[A(2038)].height;
        M ? this.setFocalOffset(this[A(767)].x + P, this[A(767)].y + S, this[A(767)].z, !![]) : this[A(1992)](P, S, !![]);
      }
    }, this[t(3326)] = (g, b) => {
      const M = t, A = Ci * this.azimuthRotateSpeed * g / this[M(2038)][M(1674)], L = Ci * this[M(3381)] * b / this[M(2038)][M(1674)];
      this[M(1565)](A, L, !![]);
    }, this[t(2460)] = (g, b, M) => {
      const A = t, L = Math[A(3196)](0.95, -g * this[A(1490)]), P = this[A(3575)][A(1232)] * L, S = this._sphericalEnd[A(1232)], I = S * (g >= 0 ? -1 : 1);
      this[A(2954)](P), this[A(1743)] && (P < this.minDistance || this[A(2691)] === this[A(1928)]) && (this[A(3606)][A(2223)](rx), this[A(769)][A(3026)](rx[A(608)]()[A(580)](I)), this._target.add(rx.normalize()[A(580)](I))), this[A(1588)] && (this._dollyControlAmount += this._sphericalEnd[A(1232)] - S, this[A(1743)] && (P < this[A(1928)] || this[A(2691)] === this[A(1928)]) && (this._dollyControlAmount -= I), this[A(2205)][A(1260)](b, M));
    }, this[t(1481)] = (g, b, M) => {
      const A = t, L = Math[A(3196)](0.95, g * this[A(1490)]), P = this[A(3756)];
      this.zoomTo(this[A(2776)] * L), this[A(1588)] && (this[A(2021)] += this._zoomEnd - P, this._dollyControlCoord.set(b, M));
    }, typeof tx === t(2011) && console.error(t(909)), this[t(3606)] = e, this[t(2667)] = new tx.Quaternion().setFromUnitVectors(this[t(3606)].up, ea), this[t(3270)] = this._yAxisUpSpace[t(2272)]().invert(), this[t(2530)] = o0[t(2415)], this[t(1330)] = new tx[t(3099)](), this[t(769)] = this[t(1330)][t(2272)](), this._focalOffset = new tx[t(3099)](), this[t(767)] = this[t(1401)][t(2272)](), this[t(2369)] = new tx[t(505)]()[t(3506)](rx[t(2875)](this[t(3606)][t(3571)]).applyQuaternion(this._yAxisUpSpace)), this[t(3575)] = this[t(2369)][t(2272)](), this._zoom = this._camera[t(2477)], this._zoomEnd = this[t(2776)], this[t(3164)] = [new tx[t(3099)](), new tx.Vector3(), new tx.Vector3(), new tx.Vector3()], this[t(575)](), this[t(1361)] = new tx[t(1673)](new tx[t(3099)](-1 / 0, -1 / 0, -1 / 0), new tx[t(3099)](1 / 0, 1 / 0, 1 / 0)), this[t(2760)] = this._target.clone(), this[t(3087)] = this[t(3606)][t(3571)][t(2272)](), this[t(3134)] = this[t(2776)], this[t(1360)] = this[t(1401)][t(2272)](), this[t(2021)] = 0, this[t(2205)] = new tx.Vector2(), this[t(1215)] = { left: o0[t(3745)], middle: o0[t(2615)], right: o0[t(2854)], wheel: kt(this[t(3606)]) ? o0[t(2615)] : pt(this[t(3606)]) ? o0[t(1073)] : o0[t(2415)] }, this[t(2434)] = { one: o0[t(1528)], two: kt(this[t(3606)]) ? o0[t(2830)] : pt(this._camera) ? o0[t(601)] : o0[t(2415)], three: o0.TOUCH_TRUCK };
    const i = new tx[t(2374)](), n = new tx[t(2374)](), a = new tx[t(2374)](), r = (g) => {
      const b = t;
      if (!this[b(3639)] || !this._domElement)
        return;
      const M = g[b(3171)] !== b(3766) ? null : (g[b(1233)] & nx[b(815)]) === nx[b(815)] ? nx[b(815)] : (g[b(1233)] & nx[b(3e3)]) === nx[b(3e3)] ? nx.MIDDLE : (g[b(1233)] & nx.RIGHT) === nx[b(932)] ? nx.RIGHT : null;
      if (M !== null) {
        const L = this[b(2892)](M);
        L && this[b(3318)][b(1733)](this[b(3318)][b(882)](L), 1);
      }
      const A = { pointerId: g[b(3724)], clientX: g[b(1507)], clientY: g[b(2662)], deltaX: 0, deltaY: 0, mouseButton: M };
      this[b(3318)].push(A), this[b(1058)][b(2290)][b(1079)](b(3576), c, { passive: ![] }), this[b(1058)].ownerDocument[b(1079)](b(2713), f), this._domElement[b(2290)].addEventListener(b(3576), c, { passive: ![] }), this._domElement[b(2290)].addEventListener(b(2713), f), m(g);
    }, o = (g) => {
      const b = t;
      if (!this[b(3639)] || !this[b(1058)])
        return;
      const M = (g.buttons & nx[b(815)]) === nx[b(815)] ? nx.LEFT : (g[b(1233)] & nx[b(3e3)]) === nx[b(3e3)] ? nx[b(3e3)] : (g.buttons & nx[b(932)]) === nx[b(932)] ? nx[b(932)] : null;
      if (M !== null) {
        const L = this[b(2892)](M);
        L && this._activePointers.splice(this[b(3318)][b(882)](L), 1);
      }
      const A = { pointerId: 0, clientX: g[b(1507)], clientY: g[b(2662)], deltaX: 0, deltaY: 0, mouseButton: (g.buttons & nx[b(815)]) === nx[b(815)] ? nx[b(815)] : (g.buttons & nx[b(3e3)]) === nx[b(815)] ? nx[b(3e3)] : (g[b(1233)] & nx[b(932)]) === nx.LEFT ? nx.RIGHT : null };
      this._activePointers[b(3156)](A), this[b(1058)].ownerDocument[b(1079)](b(1813), h), this[b(1058)].ownerDocument[b(1079)](b(1203), u), this._domElement[b(2290)][b(818)](b(1813), h), this[b(1058)][b(2290)][b(818)]("mouseup", u), m(g);
    }, c = (g) => {
      const b = t;
      g[b(3060)] && g.preventDefault();
      const M = g[b(3724)], A = this[b(3183)](M);
      if (A) {
        if (A[b(1507)] = g.clientX, A[b(2662)] = g[b(2662)], A[b(3144)] = g[b(2885)], A[b(3406)] = g[b(2547)], g[b(3171)] === b(1433))
          switch (this[b(3318)].length) {
            case 1:
              this[b(2530)] = this[b(2434)][b(1692)];
              break;
            case 2:
              this._state = this[b(2434)][b(1309)];
              break;
            case 3:
              this[b(2530)] = this[b(2434)][b(3361)];
              break;
          }
        else
          this[b(2530)] = 0, (g[b(1233)] & nx[b(815)]) === nx[b(815)] && (this[b(2530)] = this[b(2530)] | this.mouseButtons.left), (g[b(1233)] & nx[b(3e3)]) === nx[b(3e3)] && (this[b(2530)] = this[b(2530)] | this[b(1215)][b(2132)]), (g[b(1233)] & nx.RIGHT) === nx[b(932)] && (this[b(2530)] = this._state | this[b(1215)][b(3383)]);
        y();
      }
    }, h = (g) => {
      const b = t, M = this[b(3183)](0);
      M && (M[b(1507)] = g[b(1507)], M.clientY = g.clientY, M.deltaX = g[b(2885)], M[b(3406)] = g.movementY, this[b(2530)] = 0, (g[b(1233)] & nx.LEFT) === nx[b(815)] && (this[b(2530)] = this[b(2530)] | this.mouseButtons[b(1640)]), (g[b(1233)] & nx.MIDDLE) === nx.MIDDLE && (this[b(2530)] = this[b(2530)] | this[b(1215)][b(2132)]), (g[b(1233)] & nx[b(932)]) === nx.RIGHT && (this[b(2530)] = this[b(2530)] | this[b(1215)].right), y());
    }, f = (g) => {
      const b = t, M = g[b(3724)], A = this._findPointerById(M);
      if (A && this[b(3318)][b(1733)](this[b(3318)][b(882)](A), 1), g[b(3171)] === b(1433))
        switch (this._activePointers.length) {
          case 0:
            this[b(2530)] = o0[b(2415)];
            break;
          case 1:
            this[b(2530)] = this[b(2434)][b(1692)];
            break;
          case 2:
            this._state = this.touches[b(1309)];
            break;
          case 3:
            this[b(2530)] = this.touches.three;
            break;
        }
      else
        this[b(2530)] = o0[b(2415)];
      v();
    }, u = () => {
      const g = t, b = this[g(3183)](0);
      b && this[g(3318)][g(1733)](this._activePointers[g(882)](b), 1), this[g(2530)] = o0.NONE, v();
    };
    let l = -1;
    const _ = (g) => {
      const b = t;
      if (!this[b(3639)] || this[b(1215)][b(1016)] === o0[b(2415)])
        return;
      if (g[b(436)](), this[b(1588)] || this[b(1215)][b(1016)] === o0[b(3745)] || this[b(1215)].wheel === o0[b(2854)]) {
        const S = performance.now();
        l - S < 1e3 && this._getClientRect(this[b(2038)]), l = S;
      }
      const M = hg ? -1 : -3, A = g.deltaMode === 1 ? g[b(3406)] / M : g.deltaY / (M * 10), L = this[b(1588)] ? (g[b(1507)] - this[b(2038)].x) / this[b(2038)].width * 2 - 1 : 0, P = this[b(1588)] ? (g[b(2662)] - this[b(2038)].y) / this[b(2038)][b(1674)] * -2 + 1 : 0;
      switch (this[b(1215)].wheel) {
        case o0[b(3745)]: {
          this[b(3326)](g[b(3144)], g[b(3406)]), this[b(558)] = !![];
          break;
        }
        case o0[b(2854)]: {
          this[b(2645)](g[b(3144)], g[b(3406)], ![]), this._isUserControllingTruck = !![];
          break;
        }
        case o0[b(493)]: {
          this._truckInternal(g[b(3144)], g[b(3406)], !![]), this[b(2200)] = !![];
          break;
        }
        case o0[b(2615)]: {
          this[b(2460)](-A, L, P), this[b(3763)] = !![];
          break;
        }
        case o0.ZOOM: {
          this._zoomInternal(-A, L, P), this._isUserControllingZoom = !![];
          break;
        }
      }
      this[b(3157)]({ type: b(3277) });
    }, p = (g) => {
      const b = t;
      if (!(!this._domElement || !this[b(3639)])) {
        if (this[b(1215)][b(3383)] === xi.ACTION[b(2415)]) {
          const M = g instanceof PointerEvent ? g[b(3724)] : (g instanceof MouseEvent, 0), A = this[b(3183)](M);
          A && this[b(3318)].splice(this[b(3318)][b(882)](A), 1), this[b(1058)][b(2290)][b(1079)](b(3576), c, { passive: ![] }), this._domElement[b(2290)].removeEventListener(b(2713), f), this._domElement[b(2290)].removeEventListener(b(1813), h), this[b(1058)][b(2290)][b(1079)]("mouseup", u);
          return;
        }
        g[b(436)]();
      }
    }, m = (g) => {
      const b = t;
      if (!this[b(3639)])
        return;
      if (Mr(this[b(3318)], fe), this[b(2731)](this[b(2038)]), i[b(2875)](fe), n.copy(fe), this[b(3318)][b(3105)] >= 2) {
        const A = fe.x - this[b(3318)][1][b(1507)], L = fe.y - this[b(3318)][1][b(2662)], P = Math[b(713)](A * A + L * L);
        a.set(0, P);
        const S = (this._activePointers[0][b(1507)] + this._activePointers[1].clientX) * 0.5, I = (this[b(3318)][0][b(2662)] + this[b(3318)][1][b(2662)]) * 0.5;
        n.set(S, I);
      }
      if (b(3171) in g && g[b(3171)] === b(1433))
        switch (this[b(3318)].length) {
          case 1:
            this._state = this[b(2434)].one;
            break;
          case 2:
            this[b(2530)] = this.touches[b(1309)];
            break;
          case 3:
            this._state = this[b(2434)][b(3361)];
            break;
        }
      else
        this[b(2530)] = 0, (g[b(1233)] & nx.LEFT) === nx[b(815)] && (this[b(2530)] = this[b(2530)] | this[b(1215)][b(1640)]), (g[b(1233)] & nx[b(3e3)]) === nx[b(3e3)] && (this._state = this[b(2530)] | this[b(1215)].middle), (g[b(1233)] & nx[b(932)]) === nx[b(932)] && (this[b(2530)] = this._state | this[b(1215)].right);
      ((this._state & o0.ROTATE) === o0.ROTATE || (this[b(2530)] & o0[b(1528)]) === o0[b(1528)] || (this[b(2530)] & o0[b(803)]) === o0[b(803)] || (this[b(2530)] & o0[b(3671)]) === o0[b(3671)]) && (this._sphericalEnd[b(2949)] = this._spherical[b(2949)], this[b(3575)][b(1088)] = this._spherical.phi, this[b(2658)][b(1811)] = 0, this[b(3046)].value = 0), ((this[b(2530)] & o0[b(2854)]) === o0[b(2854)] || (this[b(2530)] & o0[b(3189)]) === o0[b(3189)] || (this[b(2530)] & o0[b(2830)]) === o0[b(2830)] || (this[b(2530)] & o0[b(601)]) === o0[b(601)]) && (this[b(769)].copy(this[b(1330)]), this[b(2440)][b(1260)](0, 0, 0)), ((this[b(2530)] & o0[b(2615)]) === o0[b(2615)] || (this._state & o0[b(3086)]) === o0[b(3086)] || (this[b(2530)] & o0.TOUCH_DOLLY_TRUCK) === o0[b(2830)] || (this[b(2530)] & o0[b(3764)]) === o0[b(3764)] || (this[b(2530)] & o0.TOUCH_DOLLY_ROTATE) === o0[b(803)]) && (this[b(3575)].radius = this._spherical[b(1232)], this[b(3172)][b(1811)] = 0), ((this[b(2530)] & o0[b(1073)]) === o0[b(1073)] || (this[b(2530)] & o0[b(3043)]) === o0[b(3043)] || (this[b(2530)] & o0[b(601)]) === o0[b(601)] || (this[b(2530)] & o0[b(1906)]) === o0[b(1906)] || (this[b(2530)] & o0[b(3671)]) === o0[b(3671)]) && (this[b(3756)] = this[b(2776)], this[b(1102)][b(1811)] = 0), ((this[b(2530)] & o0[b(493)]) === o0[b(493)] || (this[b(2530)] & o0[b(2961)]) === o0[b(2961)] || (this[b(2530)] & o0[b(3764)]) === o0.TOUCH_DOLLY_OFFSET || (this[b(2530)] & o0[b(1906)]) === o0[b(1906)]) && (this[b(767)][b(2875)](this[b(1401)]), this[b(968)][b(1260)](0, 0, 0)), this[b(3157)]({ type: b(2385) });
    }, y = () => {
      const g = t;
      if (!this[g(3639)])
        return;
      Mr(this[g(3318)], fe);
      const b = this[g(1058)] && document[g(3779)] === this[g(1058)], M = b ? -this[g(3318)][0].deltaX : n.x - fe.x, A = b ? -this[g(3318)][0][g(3406)] : n.y - fe.y;
      if (n[g(2875)](fe), ((this[g(2530)] & o0.ROTATE) === o0[g(3745)] || (this._state & o0.TOUCH_ROTATE) === o0[g(1528)] || (this[g(2530)] & o0[g(803)]) === o0.TOUCH_DOLLY_ROTATE || (this[g(2530)] & o0.TOUCH_ZOOM_ROTATE) === o0[g(3671)]) && (this._rotateInternal(M, A), this._isUserControllingRotate = !![]), (this._state & o0[g(2615)]) === o0[g(2615)] || (this._state & o0[g(1073)]) === o0[g(1073)]) {
        const L = this.dollyToCursor ? (i.x - this[g(2038)].x) / this._elementRect[g(1631)] * 2 - 1 : 0, P = this[g(1588)] ? (i.y - this._elementRect.y) / this._elementRect[g(1674)] * -2 + 1 : 0;
        (this[g(2530)] & o0[g(2615)]) === o0[g(2615)] ? (this[g(2460)](A * xa, L, P), this[g(3763)] = !![]) : (this._zoomInternal(A * xa, L, P), this[g(2585)] = !![]);
      }
      if ((this[g(2530)] & o0.TOUCH_DOLLY) === o0[g(3086)] || (this[g(2530)] & o0[g(3043)]) === o0[g(3043)] || (this[g(2530)] & o0.TOUCH_DOLLY_TRUCK) === o0[g(2830)] || (this[g(2530)] & o0[g(601)]) === o0.TOUCH_ZOOM_TRUCK || (this[g(2530)] & o0.TOUCH_DOLLY_OFFSET) === o0[g(3764)] || (this[g(2530)] & o0[g(1906)]) === o0.TOUCH_ZOOM_OFFSET || (this[g(2530)] & o0[g(803)]) === o0.TOUCH_DOLLY_ROTATE || (this[g(2530)] & o0[g(3671)]) === o0.TOUCH_ZOOM_ROTATE) {
        const L = fe.x - this[g(3318)][1][g(1507)], P = fe.y - this[g(3318)][1][g(2662)], S = Math.sqrt(L * L + P * P), I = a.y - S;
        a.set(0, S);
        const C = this[g(1588)] ? (n.x - this[g(2038)].x) / this[g(2038)].width * 2 - 1 : 0, G = this[g(1588)] ? (n.y - this[g(2038)].y) / this._elementRect[g(1674)] * -2 + 1 : 0;
        (this[g(2530)] & o0[g(3086)]) === o0[g(3086)] || (this[g(2530)] & o0.TOUCH_DOLLY_ROTATE) === o0[g(803)] || (this[g(2530)] & o0[g(2830)]) === o0[g(2830)] || (this[g(2530)] & o0[g(3764)]) === o0[g(3764)] ? (this[g(2460)](I * xa, C, G), this[g(3763)] = !![]) : (this[g(1481)](I * xa, C, G), this._isUserControllingZoom = !![]);
      }
      ((this[g(2530)] & o0.TRUCK) === o0[g(2854)] || (this[g(2530)] & o0.TOUCH_TRUCK) === o0[g(3189)] || (this[g(2530)] & o0[g(2830)]) === o0[g(2830)] || (this[g(2530)] & o0.TOUCH_ZOOM_TRUCK) === o0[g(601)]) && (this[g(2645)](M, A, ![]), this._isUserControllingTruck = !![]), ((this._state & o0[g(493)]) === o0[g(493)] || (this[g(2530)] & o0[g(2961)]) === o0[g(2961)] || (this[g(2530)] & o0[g(3764)]) === o0[g(3764)] || (this[g(2530)] & o0[g(1906)]) === o0[g(1906)]) && (this._truckInternal(M, A, !![]), this[g(2200)] = !![]), this[g(3157)]({ type: "control" });
    }, v = () => {
      const g = t;
      Mr(this[g(3318)], fe), n[g(2875)](fe), this[g(3318)][g(3105)] === 0 && this[g(1058)] && (this[g(1058)][g(2290)][g(1079)](g(3576), c, { passive: ![] }), this._domElement[g(2290)][g(1079)](g(1813), h), this[g(1058)][g(2290)][g(1079)](g(2713), f), this[g(1058)].ownerDocument[g(1079)](g(1203), u), this[g(3157)]({ type: g(2267) }));
    };
    this[t(1245)] = (g) => {
      const b = t;
      this[b(1058)] = g, this[b(1058)].style[b(1033)] = b(1227), this[b(1058)][b(433)][b(783)] = "none", this[b(1058)][b(433)][b(3750)] = b(1227), this[b(1058)].addEventListener(b(2814), r), fg && this._domElement[b(818)](b(3630), o), this[b(1058)][b(818)](b(897), f), this._domElement[b(818)]("wheel", _, { passive: ![] }), this._domElement[b(818)](b(3364), p);
    }, this._removeAllEventListeners = () => {
      const g = t;
      this[g(1058)] && (this._domElement[g(433)][g(1033)] = "", this._domElement[g(433)][g(783)] = "", this[g(1058)][g(433)].webkitUserSelect = "", this._domElement[g(1079)](g(2814), r), this[g(1058)][g(1079)]("mousedown", o), this[g(1058)][g(1079)]("pointercancel", f), this._domElement[g(1079)](g(1016), _, { passive: ![] }), this._domElement.removeEventListener(g(3364), p), this[g(1058)][g(2290)][g(1079)](g(3576), c, { passive: ![] }), this[g(1058)][g(2290)][g(1079)]("mousemove", h), this[g(1058)][g(2290)][g(1079)](g(2713), f), this[g(1058)][g(2290)].removeEventListener(g(1203), u));
    }, this[t(1228)] = () => {
      const g = t;
      this._state !== o0[g(2415)] && (this._state = o0[g(2415)], this[g(3318)].length = 0, v());
    }, x && this[t(2797)](x), this.update(0);
  }
  get [s(2189)]() {
    return this[s(3606)];
  }
  set camera(e) {
    const x = s;
    this._camera = e, this[x(3111)](), this._camera[x(1701)](), this[x(575)](), this[x(3473)] = !![];
  }
  get [s(2679)]() {
    return this._enabled;
  }
  set [s(2679)](e) {
    const x = s;
    this._enabled = e, this[x(1058)] && (e ? (this._domElement[x(433)][x(1033)] = x(1227), this[x(1058)][x(433)][x(783)] = x(1227), this[x(1058)][x(433)][x(3750)] = x(1227)) : (this[x(1228)](), this[x(1058)].style[x(1033)] = "", this[x(1058)][x(433)][x(783)] = "", this[x(1058)][x(433)][x(3750)] = ""));
  }
  get [s(3526)]() {
    return !this[s(3332)];
  }
  get [s(748)]() {
    return this[s(2530)];
  }
  get [s(1183)]() {
    const e = s;
    return this[e(2369)][e(1232)];
  }
  set [s(1183)](e) {
    const x = s;
    this._spherical[x(1232)] === e && this[x(3575)].radius === e || (this[x(2369)][x(1232)] = e, this[x(3575)][x(1232)] = e, this[x(3473)] = !![]);
  }
  get [s(2659)]() {
    return this[s(2369)].theta;
  }
  set azimuthAngle(e) {
    const x = s;
    this._spherical[x(2949)] === e && this[x(3575)][x(2949)] === e || (this[x(2369)].theta = e, this[x(3575)][x(2949)] = e, this[x(3473)] = !![]);
  }
  get [s(2017)]() {
    const e = s;
    return this[e(2369)][e(1088)];
  }
  set polarAngle(e) {
    const x = s;
    this._spherical.phi === e && this._sphericalEnd[x(1088)] === e || (this._spherical[x(1088)] = e, this._sphericalEnd.phi = e, this[x(3473)] = !![]);
  }
  get boundaryEnclosesCamera() {
    return this[s(1985)];
  }
  set [s(1843)](e) {
    const x = s;
    this[x(1985)] = e, this[x(3473)] = !![];
  }
  [s(818)](e, x) {
    super.addEventListener(e, x);
  }
  [s(1079)](e, x) {
    const t = s;
    super[t(1079)](e, x);
  }
  rotate(e, x, t = ![]) {
    const i = s;
    return this.rotateTo(this[i(3575)][i(2949)] + e, this[i(3575)].phi + x, t);
  }
  rotateAzimuthTo(e, x = ![]) {
    const t = s;
    return this[t(1118)](e, this[t(3575)].phi, x);
  }
  [s(3333)](e, x = ![]) {
    const t = s;
    return this[t(1118)](this[t(3575)][t(2949)], e, x);
  }
  [s(1118)](e, x, t = ![]) {
    const i = s;
    this[i(558)] = ![];
    const n = Pi(e, this[i(1483)], this[i(3461)]), a = Pi(x, this[i(3433)], this.maxPolarAngle);
    this[i(3575)][i(2949)] = n, this[i(3575)][i(1088)] = a, this[i(3575)][i(2184)](), this[i(3473)] = !![], !t && (this._spherical[i(2949)] = this[i(3575)][i(2949)], this[i(2369)].phi = this[i(3575)][i(1088)]);
    const r = !t || Ix(this[i(2369)][i(2949)], this[i(3575)][i(2949)], this[i(2704)]) && Ix(this._spherical.phi, this[i(3575)][i(1088)], this[i(2704)]);
    return this[i(3636)](r);
  }
  dolly(e, x = ![]) {
    const t = s;
    return this[t(2954)](this[t(3575)][t(1232)] - e, x);
  }
  [s(2954)](e, x = ![]) {
    const t = s;
    this._isUserControllingDolly = ![];
    const i = this[t(3575)][t(1232)], n = Pi(e, this[t(1928)], this.maxDistance);
    if (this[t(502)][t(3105)] >= 1) {
      const o = this[t(2258)](), c = Ix(o, this[t(2369)].radius);
      if (!(i > n) && c)
        return Promise.resolve();
      this[t(3575)].radius = Math[t(3085)](n, o);
    } else
      this._sphericalEnd[t(1232)] = n;
    this[t(3473)] = !![], !x && (this[t(2369)][t(1232)] = this._sphericalEnd.radius);
    const r = !x || Ix(this._spherical.radius, this[t(3575)][t(1232)], this.restThreshold);
    return this._createOnRestPromise(r);
  }
  [s(2477)](e, x = ![]) {
    const t = s;
    return this.zoomTo(this[t(3756)] + e, x);
  }
  [s(1219)](e, x = ![]) {
    const t = s;
    this[t(2585)] = ![], this[t(3756)] = Pi(e, this[t(844)], this[t(1620)]), this._needsUpdate = !![], !x && (this._zoom = this[t(3756)]);
    const i = !x || Ix(this[t(2776)], this[t(3756)], this[t(2704)]);
    return this[t(3636)](i);
  }
  pan(e, x, t = ![]) {
    const i = s;
    return console[i(3629)](i(1959)), this.truck(e, x, t);
  }
  [s(1992)](e, x, t = ![]) {
    const i = s;
    this._camera.updateMatrix(), Ge.setFromMatrixColumn(this._camera[i(1067)], 0), He.setFromMatrixColumn(this[i(3606)].matrix, 1), Ge.multiplyScalar(e), He.multiplyScalar(-x);
    const n = rx[i(2875)](Ge)[i(3026)](He), a = Tx[i(2875)](this._targetEnd)[i(3026)](n);
    return this[i(1729)](a.x, a.y, a.z, t);
  }
  [s(688)](e, x = ![]) {
    const t = s;
    rx[t(3531)](this[t(3606)][t(1067)], 0), rx[t(956)](this[t(3606)].up, rx), rx.multiplyScalar(e);
    const i = Tx.copy(this[t(769)])[t(3026)](rx);
    return this.moveTo(i.x, i.y, i.z, x);
  }
  elevate(e, x = ![]) {
    const t = s;
    return rx[t(2875)](this[t(3606)].up).multiplyScalar(e), this[t(1729)](this[t(769)].x + rx.x, this[t(769)].y + rx.y, this[t(769)].z + rx.z, x);
  }
  moveTo(e, x, t, i = ![]) {
    const n = s;
    this._isUserControllingTruck = ![];
    const a = rx[n(1260)](e, x, t)[n(1943)](this._targetEnd);
    this._encloseToBoundary(this[n(769)], a, this[n(2402)]), this[n(3473)] = !![], !i && this[n(1330)][n(2875)](this[n(769)]);
    const r = !i || Ix(this[n(1330)].x, this[n(769)].x, this[n(2704)]) && Ix(this._target.y, this[n(769)].y, this[n(2704)]) && Ix(this._target.z, this[n(769)].z, this[n(2704)]);
    return this._createOnRestPromise(r);
  }
  [s(3757)](e, x, t, i = ![]) {
    const n = s, a = rx.set(e, x, t), r = a[n(1943)](this[n(769)])[n(608)](), o = r[n(580)](-this[n(3575)].radius);
    return this.setPosition(o.x, o.y, o.z, i);
  }
  [s(3023)](e, x, { cover: t = ![], paddingLeft: i = 0, paddingRight: n = 0, paddingBottom: a = 0, paddingTop: r = 0 } = {}) {
    const o = s, c = [], h = e.isBox3 ? Ri.copy(e) : Ri[o(3392)](e);
    h[o(2253)]() && (console[o(3629)](o(1398)), Promise[o(3450)]());
    const f = zc(this[o(3575)].theta, Uc), u = zc(this[o(3575)].phi, Uc);
    c.push(this[o(1118)](f, u, x));
    const l = rx[o(1548)](this[o(3575)])[o(608)](), _ = Vc[o(1611)](l, Tr), p = Ix(Math.abs(l.y), 1);
    p && _.multiply(Ar.setFromAxisAngle(ea, f)), _[o(2246)](this._yAxisUpSpaceInverse);
    const m = kc[o(2561)]();
    Tx[o(2875)](h[o(3085)])[o(718)](_), m.expandByPoint(Tx), Tx[o(2875)](h[o(3085)])[o(2357)](h.max.x).applyQuaternion(_), m[o(1186)](Tx), Tx[o(2875)](h.min).setY(h.max.y).applyQuaternion(_), m[o(1186)](Tx), Tx.copy(h.max)[o(3096)](h[o(3085)].z)[o(718)](_), m[o(1186)](Tx), Tx[o(2875)](h[o(3085)])[o(3096)](h[o(1803)].z).applyQuaternion(_), m.expandByPoint(Tx), Tx[o(2875)](h[o(1803)]).setY(h.min.y)[o(718)](_), m.expandByPoint(Tx), Tx[o(2875)](h[o(1803)])[o(2357)](h.min.x)[o(718)](_), m[o(1186)](Tx), Tx[o(2875)](h[o(1803)])[o(718)](_), m[o(1186)](Tx), m[o(3085)].x -= i, m[o(3085)].y -= a, m[o(1803)].x += n, m.max.y += r, _[o(1611)](Tr, l), p && _[o(3272)](Ar[o(1525)]()), _[o(3272)](this[o(2667)]);
    const y = m[o(561)](rx), v = m.getCenter(Tx)[o(718)](_);
    if (kt(this[o(3606)])) {
      const g = this[o(2993)](y.x, y.y, y.z, t);
      c[o(3156)](this[o(1729)](v.x, v.y, v.z, x)), c[o(3156)](this.dollyTo(g, x)), c[o(3156)](this[o(1789)](0, 0, 0, x));
    } else if (pt(this[o(3606)])) {
      const g = this._camera, b = g[o(3383)] - g.left, M = g.top - g.bottom, A = t ? Math.max(b / y.x, M / y.y) : Math[o(3085)](b / y.x, M / y.y);
      c[o(3156)](this.moveTo(v.x, v.y, v.z, x)), c.push(this[o(1219)](A, x)), c[o(3156)](this[o(1789)](0, 0, 0, x));
    }
    return Promise.all(c);
  }
  [s(2192)](e, x) {
    const t = s, i = [], n = e instanceof tx[t(924)], a = n ? Er[t(2875)](e) : xi[t(870)](e, Er);
    if (i.push(this[t(1729)](a.center.x, a[t(551)].y, a[t(551)].z, x)), kt(this[t(3606)])) {
      const r = this[t(2135)](a[t(1232)]);
      i[t(3156)](this[t(2954)](r, x));
    } else if (pt(this[t(3606)])) {
      const r = this[t(3606)].right - this[t(3606)].left, o = this[t(3606)][t(1376)] - this[t(3606)].bottom, c = 2 * a[t(1232)], h = Math[t(3085)](r / c, o / c);
      i[t(3156)](this.zoomTo(h, x));
    }
    return i[t(3156)](this[t(1789)](0, 0, 0, x)), Promise[t(3029)](i);
  }
  [s(3488)](e, x, t, i, n, a, r = ![]) {
    const o = s;
    this[o(558)] = ![], this[o(3763)] = ![], this[o(1180)] = ![];
    const c = Tx[o(1260)](i, n, a), h = rx.set(e, x, t);
    this[o(769)][o(2875)](c), this._sphericalEnd[o(3506)](h.sub(c)[o(718)](this[o(2667)])), this.normalizeRotations(), this[o(3473)] = !![], !r && (this[o(1330)].copy(this._targetEnd), this[o(2369)][o(2875)](this[o(3575)]));
    const f = !r || Ix(this[o(1330)].x, this[o(769)].x, this[o(2704)]) && Ix(this[o(1330)].y, this[o(769)].y, this.restThreshold) && Ix(this[o(1330)].z, this[o(769)].z, this[o(2704)]) && Ix(this[o(2369)][o(2949)], this[o(3575)][o(2949)], this[o(2704)]) && Ix(this._spherical[o(1088)], this[o(3575)][o(1088)], this.restThreshold) && Ix(this[o(2369)][o(1232)], this[o(3575)][o(1232)], this[o(2704)]);
    return this[o(3636)](f);
  }
  lerpLookAt(e, x, t, i, n, a, r, o, c, h, f, u, l, _ = ![]) {
    const p = s;
    this[p(558)] = ![], this[p(3763)] = ![], this[p(1180)] = ![];
    const m = rx.set(i, n, a), y = Tx[p(1260)](e, x, t);
    Ie[p(3506)](y[p(1943)](m)[p(718)](this._yAxisUpSpace));
    const v = Li.set(h, f, u), g = Tx[p(1260)](r, o, c);
    Sn[p(3506)](g.sub(v)[p(718)](this[p(2667)])), this[p(769)][p(2875)](m.lerp(v, l));
    const b = Sn[p(2949)] - Ie[p(2949)], M = Sn[p(1088)] - Ie.phi, A = Sn[p(1232)] - Ie[p(1232)];
    this[p(3575)].set(Ie[p(1232)] + A * l, Ie[p(1088)] + M * l, Ie[p(2949)] + b * l), this.normalizeRotations(), this[p(3473)] = !![], !_ && (this[p(1330)].copy(this[p(769)]), this[p(2369)][p(2875)](this[p(3575)]));
    const L = !_ || Ix(this[p(1330)].x, this[p(769)].x, this[p(2704)]) && Ix(this._target.y, this[p(769)].y, this[p(2704)]) && Ix(this[p(1330)].z, this._targetEnd.z, this[p(2704)]) && Ix(this[p(2369)][p(2949)], this._sphericalEnd[p(2949)], this.restThreshold) && Ix(this[p(2369)][p(1088)], this[p(3575)][p(1088)], this[p(2704)]) && Ix(this[p(2369)][p(1232)], this[p(3575)][p(1232)], this.restThreshold);
    return this[p(3636)](L);
  }
  [s(1350)](e, x, t, i = ![]) {
    const n = s;
    return this.setLookAt(e, x, t, this[n(769)].x, this._targetEnd.y, this[n(769)].z, i);
  }
  [s(3476)](e, x, t, i = ![]) {
    const n = s, a = this.getPosition(rx), r = this.setLookAt(a.x, a.y, a.z, e, x, t, i);
    return this[n(3575)].phi = Pi(this[n(2017)], this.minPolarAngle, this[n(1192)]), r;
  }
  [s(1789)](e, x, t, i = ![]) {
    const n = s;
    this[n(2200)] = ![], this[n(767)][n(1260)](e, x, t), this._needsUpdate = !![], i || this[n(1401)][n(2875)](this[n(767)]);
    const a = !i || Ix(this._focalOffset.x, this[n(767)].x, this[n(2704)]) && Ix(this[n(1401)].y, this[n(767)].y, this[n(2704)]) && Ix(this._focalOffset.z, this[n(767)].z, this[n(2704)]);
    return this[n(3636)](a);
  }
  [s(1617)](e, x, t) {
    const i = s;
    this[i(3606)][i(3640)](), Ge.setFromMatrixColumn(this[i(3606)][i(1874)], 0), He.setFromMatrixColumn(this._camera[i(1874)], 1), Vt[i(3531)](this[i(3606)].matrixWorldInverse, 2);
    const n = rx[i(1260)](e, x, t), a = n[i(3570)](this._camera.position), r = n.sub(this[i(3606)][i(3571)]);
    Ge[i(580)](r.x), He[i(580)](r.y), Vt[i(580)](r.z), rx[i(2875)](Ge)[i(3026)](He)[i(3026)](Vt), rx.z = rx.z + a, this.dollyTo(a, ![]), this.setFocalOffset(-rx.x, rx.y, -rx.z, ![]), this.moveTo(e, x, t, ![]);
  }
  [s(2039)](e) {
    const x = s;
    if (!e) {
      this[x(1361)][x(3085)].set(-1 / 0, -1 / 0, -1 / 0), this[x(1361)][x(1803)].set(1 / 0, 1 / 0, 1 / 0), this._needsUpdate = !![];
      return;
    }
    this[x(1361)][x(2875)](e), this[x(1361)].clampPoint(this[x(769)], this[x(769)]), this._needsUpdate = !![];
  }
  [s(845)](e, x, t, i) {
    const n = s;
    if (e === null) {
      this[n(1342)] = null;
      return;
    }
    this._viewport = this[n(1342)] || new tx.Vector4(), typeof e === n(1407) ? this[n(1342)][n(1260)](e, x, t, i) : this[n(1342)].copy(e);
  }
  [s(2993)](e, x, t, i = ![]) {
    const n = s;
    if (Sr(this[n(3606)], "getDistanceToFitBox"))
      return this[n(2369)][n(1232)];
    const a = e / x, r = this._camera[n(2291)]() * yn, o = this._camera[n(2308)];
    return ((i ? a > o : a < o) ? x : e / o) * 0.5 / Math[n(745)](r * 0.5) + t * 0.5;
  }
  [s(2135)](e) {
    const x = s;
    if (Sr(this._camera, "getDistanceToFitSphere"))
      return this[x(2369)][x(1232)];
    const t = this._camera[x(2291)]() * yn, i = Math[x(3041)](Math[x(745)](t * 0.5) * this[x(3606)].aspect) * 2, n = 1 < this[x(3606)][x(2308)] ? t : i;
    return e / Math.sin(n * 0.5);
  }
  [s(2636)](e) {
    const x = s;
    return (e && e[x(3804)] ? e : new tx[x(3099)]())[x(2875)](this._targetEnd);
  }
  [s(2271)](e) {
    const x = s;
    return (e && e[x(3804)] ? e : new tx[x(3099)]())[x(1548)](this[x(3575)]).applyQuaternion(this[x(3270)]).add(this[x(769)]);
  }
  [s(467)](e) {
    const x = s;
    return (e && e.isVector3 ? e : new tx[x(3099)]())[x(2875)](this[x(767)]);
  }
  normalizeRotations() {
    const e = s;
    this._sphericalEnd[e(2949)] = this._sphericalEnd[e(2949)] % Ci, this[e(3575)][e(2949)] < 0 && (this._sphericalEnd[e(2949)] += Ci), this._spherical[e(2949)] += Ci * Math.round((this[e(3575)][e(2949)] - this[e(2369)][e(2949)]) / Ci);
  }
  [s(2007)](e = ![]) {
    const x = s, t = [this[x(3488)](this._position0.x, this[x(3087)].y, this[x(3087)].z, this[x(2760)].x, this[x(2760)].y, this[x(2760)].z, e), this[x(1789)](this[x(1360)].x, this[x(1360)].y, this[x(1360)].z, e), this[x(1219)](this[x(3134)], e)];
    return Promise[x(3029)](t);
  }
  [s(3217)]() {
    const e = s;
    this[e(2636)](this._target0), this[e(2271)](this[e(3087)]), this[e(3134)] = this[e(2776)], this[e(1360)][e(2875)](this[e(1401)]);
  }
  [s(3111)]() {
    const e = s;
    this._yAxisUpSpace.setFromUnitVectors(this._camera.up, ea), this._yAxisUpSpaceInverse[e(2875)](this._yAxisUpSpace)[e(1525)];
  }
  update(e) {
    const x = s, t = this[x(3575)].theta - this[x(2369)][x(2949)], i = this._sphericalEnd.phi - this._spherical[x(1088)], n = this._sphericalEnd.radius - this._spherical.radius, a = Gc.subVectors(this[x(769)], this[x(1330)]), r = Hc[x(1061)](this[x(767)], this._focalOffset), o = this._zoomEnd - this._zoom;
    if (Dx(t))
      this._thetaVelocity[x(1811)] = 0, this[x(2369)][x(2949)] = this[x(3575)][x(2949)];
    else {
      const u = this[x(558)] ? this.draggingSmoothTime : this.smoothTime;
      this[x(2369)][x(2949)] = Qs(this._spherical.theta, this[x(3575)][x(2949)], this._thetaVelocity, u, 1 / 0, e), this[x(3473)] = !![];
    }
    if (Dx(i))
      this[x(3046)][x(1811)] = 0, this[x(2369)][x(1088)] = this[x(3575)][x(1088)];
    else {
      const u = this[x(558)] ? this[x(3423)] : this[x(3523)];
      this[x(2369)][x(1088)] = Qs(this[x(2369)][x(1088)], this[x(3575)][x(1088)], this._phiVelocity, u, 1 / 0, e), this[x(3473)] = !![];
    }
    if (Dx(n))
      this._radiusVelocity[x(1811)] = 0, this._spherical[x(1232)] = this[x(3575)][x(1232)];
    else {
      const u = this[x(3763)] ? this[x(3423)] : this.smoothTime;
      this._spherical[x(1232)] = Qs(this[x(2369)].radius, this[x(3575)].radius, this[x(3172)], u, this[x(3045)], e), this[x(3473)] = !![];
    }
    if (Dx(a.x) && Dx(a.y) && Dx(a.z))
      this[x(2440)][x(1260)](0, 0, 0), this._target.copy(this._targetEnd);
    else {
      const u = this[x(1180)] ? this.draggingSmoothTime : this[x(3523)];
      Bc(this[x(1330)], this[x(769)], this[x(2440)], u, this[x(3045)], e, this[x(1330)]), this[x(3473)] = !![];
    }
    if (Dx(r.x) && Dx(r.y) && Dx(r.z))
      this._focalOffsetVelocity[x(1260)](0, 0, 0), this[x(1401)][x(2875)](this[x(767)]);
    else {
      const u = this._isUserControllingOffset ? this[x(3423)] : this[x(3523)];
      Bc(this[x(1401)], this._focalOffsetEnd, this._focalOffsetVelocity, u, this.maxSpeed, e, this._focalOffset), this[x(3473)] = !![];
    }
    if (this._dollyControlAmount !== 0) {
      if (kt(this[x(3606)])) {
        const u = this[x(3606)], l = rx[x(1548)](this[x(2369)])[x(718)](this[x(3270)])[x(608)]()[x(3515)](), _ = Tx[x(2875)](l).cross(u.up)[x(608)]();
        _[x(2296)]() === 0 && (_.x = 1);
        const p = Li[x(956)](_, l), m = this[x(3575)][x(1232)] * Math[x(745)](u[x(2291)]() * yn * 0.5), y = this[x(3575)][x(1232)] - this._dollyControlAmount, v = (y - this[x(3575)][x(1232)]) / this[x(3575)].radius, g = rx.copy(this._targetEnd)[x(3026)](_[x(580)](this[x(2205)].x * m * u[x(2308)])).add(p[x(580)](this[x(2205)].y * m));
        this[x(769)][x(2841)](g, v);
      } else if (pt(this[x(3606)])) {
        const u = this[x(3606)], l = rx[x(1260)](this[x(2205)].x, this._dollyControlCoord.y, (u.near + u[x(3691)]) / (u[x(1448)] - u[x(3691)]))[x(1603)](u), _ = Tx.set(0, 0, -1)[x(718)](u.quaternion), p = Li[x(2875)](l)[x(3026)](_.multiplyScalar(-l[x(1454)](u.up))), m = this[x(2776)] - this[x(2021)], y = -(m - this[x(3756)]) / this._zoom, v = rx[x(1548)](this[x(2369)])[x(718)](this[x(3270)]).normalize()[x(3515)](), g = this[x(769)][x(1454)](v);
        this[x(769)].lerp(p, y);
        const b = this[x(769)][x(1454)](v), M = v.multiplyScalar(b - g);
        this[x(769)].sub(M);
      }
      this._target[x(2875)](this._targetEnd), this[x(1361)].clampPoint(this[x(769)], this[x(769)]), this[x(2021)] = 0;
    }
    if (Dx(o))
      this[x(1102)].value = 0, this._zoom = this[x(3756)];
    else {
      const u = this[x(2585)] ? this[x(3423)] : this[x(3523)];
      this._zoom = Qs(this._zoom, this[x(3756)], this[x(1102)], u, 1 / 0, e);
    }
    this._camera[x(2477)] !== this[x(2776)] && (this[x(3606)][x(2477)] = this._zoom, this[x(3606)][x(1701)](), this[x(575)](), this[x(3473)] = !![]);
    const c = this._collisionTest();
    this[x(2369)][x(1232)] = Math[x(3085)](this[x(2369)][x(1232)], c), this[x(2369)][x(2184)](), this._camera[x(3571)][x(1548)](this[x(2369)])[x(718)](this[x(3270)])[x(3026)](this[x(1330)]), this._camera[x(2577)](this[x(1330)]), (!Dx(this[x(1401)].x) || !Dx(this._focalOffset.y) || !Dx(this[x(1401)].z)) && (this._camera[x(3640)](), Ge[x(3531)](this[x(3606)][x(1067)], 0), He[x(3531)](this[x(3606)][x(1067)], 1), Vt[x(3531)](this[x(3606)].matrix, 2), Ge[x(580)](this._focalOffset.x), He[x(580)](-this[x(1401)].y), Vt[x(580)](this._focalOffset.z), rx[x(2875)](Ge).add(He).add(Vt), this._camera[x(3571)].add(rx)), this[x(1985)] && this._encloseToBoundary(this[x(3606)][x(3571)].copy(this[x(1330)]), rx.setFromSpherical(this[x(2369)])[x(718)](this._yAxisUpSpaceInverse), 1);
    const f = this[x(3473)];
    return f && !this[x(2178)] ? (this[x(3332)] = ![], this[x(3157)]({ type: x(2213) }), this[x(3157)]({ type: x(3452) })) : f ? (this[x(3157)]({ type: "update" }), Dx(t, this[x(2704)]) && Dx(i, this.restThreshold) && Dx(n, this[x(2704)]) && Dx(a.x, this[x(2704)]) && Dx(a.y, this.restThreshold) && Dx(a.z, this.restThreshold) && Dx(r.x, this[x(2704)]) && Dx(r.y, this[x(2704)]) && Dx(r.z, this[x(2704)]) && Dx(o, this[x(2704)]) && !this[x(3332)] && (this[x(3332)] = !![], this[x(3157)]({ type: x(1208) }))) : !f && this[x(2178)] && this.dispatchEvent({ type: x(2794) }), this[x(2178)] = f, this._needsUpdate = ![], f;
  }
  [s(3139)]() {
    const e = s;
    return JSON.stringify({ enabled: this[e(3639)], minDistance: this[e(1928)], maxDistance: wn(this[e(2691)]), minZoom: this[e(844)], maxZoom: wn(this[e(1620)]), minPolarAngle: this[e(3433)], maxPolarAngle: wn(this[e(1192)]), minAzimuthAngle: wn(this[e(1483)]), maxAzimuthAngle: wn(this[e(3461)]), smoothTime: this.smoothTime, draggingSmoothTime: this[e(3423)], dollySpeed: this[e(1490)], truckSpeed: this[e(1654)], dollyToCursor: this[e(1588)], verticalDragToForward: this.verticalDragToForward, target: this[e(769)].toArray(), position: rx.setFromSpherical(this._sphericalEnd).add(this[e(769)])[e(1496)](), zoom: this[e(3756)], focalOffset: this._focalOffsetEnd[e(1496)](), target0: this._target0[e(1496)](), position0: this[e(3087)][e(1496)](), zoom0: this[e(3134)], focalOffset0: this[e(1360)][e(1496)]() });
  }
  [s(3037)](e, x = ![]) {
    const t = s, i = JSON[t(1359)](e), n = rx.fromArray(i.position);
    this[t(2679)] = i[t(2679)], this[t(1928)] = i[t(1928)], this.maxDistance = Mn(i[t(2691)]), this[t(844)] = i[t(844)], this.maxZoom = Mn(i[t(1620)]), this[t(3433)] = i[t(3433)], this.maxPolarAngle = Mn(i[t(1192)]), this[t(1483)] = Mn(i[t(1483)]), this.maxAzimuthAngle = Mn(i[t(3461)]), this[t(3523)] = i[t(3523)], this.draggingSmoothTime = i[t(3423)], this[t(1490)] = i[t(1490)], this[t(1654)] = i[t(1654)], this[t(1588)] = i[t(1588)], this[t(1818)] = i[t(1818)], this._target0[t(666)](i[t(3598)]), this[t(3087)].fromArray(i[t(2801)]), this[t(3134)] = i.zoom0, this[t(1360)][t(666)](i[t(569)]), this[t(1729)](i[t(671)][0], i[t(671)][1], i[t(671)][2], x), Ie[t(3506)](n.sub(this[t(769)])[t(718)](this[t(2667)])), this.rotateTo(Ie.theta, Ie[t(1088)], x), this[t(1219)](i[t(2477)], x), this[t(1789)](i[t(2889)][0], i[t(2889)][1], i[t(2889)][2], x), this[t(3473)] = !![];
  }
  connect(e) {
    const x = s;
    if (this._domElement) {
      console[x(3629)](x(2265));
      return;
    }
    e[x(3599)](x(2669), dg), this[x(1245)](e);
  }
  [s(2496)]() {
    const e = s;
    this[e(1228)](), this[e(3680)](), this[e(1058)] && (this[e(1058)][e(423)]("data-camera-controls-version"), this[e(1058)] = void 0);
  }
  [s(3387)]() {
    const e = s;
    this[e(1956)](), this[e(2496)]();
  }
  [s(3183)](e) {
    const x = s;
    return this[x(3318)][x(1602)]((t) => t[x(3724)] === e);
  }
  [s(2892)](e) {
    const x = s;
    return this[x(3318)].find((t) => t[x(2771)] === e);
  }
  [s(3479)](e, x, t) {
    const i = s, n = x[i(2296)]();
    if (n === 0)
      return e;
    const a = Tx[i(2875)](x)[i(3026)](e), r = this._boundary.clampPoint(a, Li), o = r[i(1943)](a), c = o[i(2296)]();
    if (c === 0)
      return e.add(x);
    if (c === n)
      return e;
    if (t === 0)
      return e.add(x)[i(3026)](o);
    {
      const h = 1 + t * c / x[i(1454)](o);
      return e[i(3026)](Tx[i(2875)](x).multiplyScalar(h))[i(3026)](o[i(580)](1 - t));
    }
  }
  [s(575)]() {
    const e = s;
    if (kt(this._camera)) {
      const x = this[e(3606)], t = x[e(1448)], i = x.getEffectiveFOV() * yn, n = Math[e(745)](i * 0.5) * t, a = n * x[e(2308)];
      this[e(3164)][0][e(1260)](-a, -n, 0), this._nearPlaneCorners[1][e(1260)](a, -n, 0), this[e(3164)][2][e(1260)](a, n, 0), this[e(3164)][3][e(1260)](-a, n, 0);
    } else if (pt(this._camera)) {
      const x = this[e(3606)], t = 1 / x[e(2477)], i = x[e(1640)] * t, n = x[e(3383)] * t, a = x[e(1376)] * t, r = x[e(574)] * t;
      this[e(3164)][0][e(1260)](i, a, 0), this._nearPlaneCorners[1].set(n, a, 0), this._nearPlaneCorners[2].set(n, r, 0), this[e(3164)][3][e(1260)](i, r, 0);
    }
  }
  [s(2258)]() {
    const e = s;
    let x = 1 / 0;
    if (!(this[e(502)].length >= 1) || Sr(this._camera, e(2258)))
      return x;
    const i = rx[e(1548)](this[e(2369)])[e(3349)](this._spherical.radius);
    Cr[e(2577)](Fc, i, this[e(3606)].up);
    for (let n = 0; n < 4; n++) {
      const a = Tx[e(2875)](this[e(3164)][n]);
      a[e(2442)](Cr);
      const r = Li[e(1168)](this[e(1330)], a);
      ta[e(1260)](r, i), ta[e(3691)] = this._spherical[e(1232)] + 1;
      const o = ta[e(2206)](this[e(502)]);
      o.length !== 0 && o[0][e(1183)] < x && (x = o[0][e(1183)]);
    }
    return x;
  }
  _getClientRect(e) {
    const x = s;
    if (!this._domElement)
      return;
    const t = this[x(1058)].getBoundingClientRect();
    return e.x = t[x(1640)], e.y = t[x(1376)], this._viewport ? (e.x += this[x(1342)].x, e.y += t.height - this[x(1342)].w - this[x(1342)].y, e[x(1631)] = this[x(1342)].z, e[x(1674)] = this._viewport.w) : (e[x(1631)] = t[x(1631)], e[x(1674)] = t.height), e;
  }
  [s(3636)](e) {
    const x = s;
    return e ? Promise[x(3450)]() : (this._hasRested = ![], this[x(3157)]({ type: x(655) }), new Promise((t) => {
      const i = x, n = () => {
        const a = c0;
        this.removeEventListener(a(1208), n), t();
      };
      this[i(818)](i(1208), n);
    }));
  }
  _addAllEventListeners(e) {
  }
  [s(3680)]() {
  }
  get dampingFactor() {
    return console[s(3629)](".dampingFactor has been deprecated. use smoothTime (in seconds) instead."), 0;
  }
  set [s(3643)](e) {
    const x = s;
    console[x(3629)](x(1856));
  }
  get [s(2660)]() {
    return console.warn(s(2255)), 0;
  }
  set draggingDampingFactor(e) {
    console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.");
  }
  static [s(870)](e, x = new tx[s(924)]()) {
    const t = s, i = x, n = i[t(551)];
    Ri[t(2561)](), e.traverseVisible((r) => {
      const o = t;
      r[o(3464)] && Ri[o(1179)](r);
    }), Ri.getCenter(n);
    let a = 0;
    return e[t(2717)]((r) => {
      const o = t;
      if (!r[o(3464)])
        return;
      const c = r, h = c[o(1353)].clone();
      if (h[o(2442)](c[o(490)]), h[o(3634)]) {
        const f = h, u = f[o(3265)][o(3571)];
        for (let l = 0, _ = u.count; l < _; l++)
          rx[o(804)](u, l), a = Math[o(1803)](a, n[o(1679)](rx));
      } else {
        const f = h.attributes[o(3571)];
        for (let u = 0, l = f.count; u < l; u++)
          rx[o(804)](f, u), a = Math[o(1803)](a, n.distanceToSquared(rx));
      }
    }), i[t(1232)] = Math[t(713)](a), i;
  }
}
const Tn = new Bh();
class lg extends Ye {
  constructor(e, x, t) {
    const i = s;
    super(), this._objects = e, this[i(3606)] = x, this._domElement = t, this[i(890)] = null, this[i(1426)] = null, this[i(2826)] = [], this[i(3178)] = 30, this[i(2679)] = !![], this[i(2024)] = ![], this[i(1370)] = window.innerWidth / 2, this[i(1370)] = window.innerHeight / 2, this[i(1320)] = 0, this[i(3772)] = this[i(3178)], this.intersectableObjects = this[i(1428)](this._objects), this.pointer = new d0(), this[i(3120)] = (n) => {
      const a = i;
      if (this[a(2679)] !== ![] && (this[a(1320)] += 1, this[a(1320)] > Number.MAX_SAFE_INTEGER && (this[a(1320)] = 0), this[a(1683)](n), Tn[a(3128)](this[a(1331)], this[a(3606)]), this[a(3502)] == null && (this[a(3502)] = getIntersectableObjects(this[a(1635)])), n[a(3171)] === "mouse" || n.pointerType === a(1041) || n[a(3171)] === a(1433)))
        if (this[a(2826)].length = 0, Tn[a(3128)](this.pointer, this[a(3606)]), Tn[a(2206)](this[a(3502)], ![], this._intersections), this[a(2826)][a(3105)] > 0) {
          let r = this[a(2826)][0].object;
          r = this[a(1685)](r[a(3710)]), this[a(1426)] !== r && this._hovered !== null && (this[a(3157)]({ type: a(2915), object: this[a(1426)] }), this[a(1058)].style[a(838)] = a(1767), this._hovered = null), this._hovered !== r && (this[a(3157)]({ type: a(3738), object: r }), this._domElement[a(433)][a(838)] = a(1331), this._hovered = r);
        } else
          this[a(1426)] !== null && (this.dispatchEvent({ type: a(2915), object: this[a(1426)] }), this[a(1058)].style.cursor = a(1767), this._hovered = null);
    }, this.onPointerUp = (n) => {
      const a = i;
      if (this[a(2679)] !== ![] && !(typeof n === TouchEvent && n[a(2434)][a(3105)] > 1)) {
        if (this[a(1320)] > Math[a(3085)](this[a(3178)] * 2, 20)) {
          this[a(1320)] = 0;
          return;
        }
        if (this[a(1320)] = 0, (this[a(3502)] == null || this.intersectableObjects == null) && (this[a(3502)] = getIntersectableObjects(this[a(1635)])), this._domElement[a(433)][a(1033)] = "none", this[a(1683)](n), this[a(2826)][a(3105)] = 0, Tn.setFromCamera(this[a(1331)], this[a(3606)]), Tn[a(2206)](this[a(3502)], ![], this._intersections), this._intersections.length > 0) {
          const r = this[a(2826)][0][a(1413)];
          this[a(890)] = this[a(1685)](r.name), this[a(3157)]({ type: a(2814), object: this[a(890)] }), this._hovered = this[a(890)];
        }
      }
    }, this[i(700)]();
  }
  [s(700)]() {
    const e = s;
    this[e(1058)][e(818)](e(3576), this.onPointerMove), this._domElement.addEventListener(e(695), this[e(1375)]), this[e(1058)][e(818)](e(1203), this[e(1375)]);
  }
  deactivate() {
    const e = s;
    this._domElement[e(1079)](e(3576), this[e(3120)]), this[e(1058)][e(1079)](e(695), this.onPointerUp), this[e(1058)][e(1079)](e(1203), this.onPointerUp), this._domElement[e(433)][e(838)] = "";
  }
  updatePointer(e) {
    const x = s, t = this._domElement[x(3158)]();
    this.pointer.x = (e[x(1507)] - t[x(1640)]) / t[x(1631)] * 2 - 1, this[x(1331)].y = -(e.clientY - t[x(1376)]) / t.height * 2 + 1;
  }
  [s(3387)]() {
    this[s(2905)]();
  }
  getObjects() {
    return this[s(1635)];
  }
  [s(1428)](e) {
    const x = s, t = [];
    for (let i = 0; i < e[x(3105)]; i++) {
      const n = e[i];
      t[x(3156)](n[x(1809)]);
    }
    return t;
  }
  getHitObject(e) {
    const x = s;
    for (let t = 0; t < this._objects[x(3105)]; t++) {
      const i = this[x(1635)][t];
      if (i.raycastTarget[x(3710)] === e)
        return i;
    }
    return null;
  }
}
class ug {
  constructor(e, x) {
    const t = s;
    xi[t(454)]({ THREE: e }), this[t(2679)] = !![], this.paused = ![], this[t(1045)], this[t(3780)], this[t(2189)], this[t(553)], this[t(790)], this[t(2644)], this.activeSceneZone, this[t(1608)] = 0.05, this[t(733)] = 0.05, this[t(453)] = x, this[t(1036)] = 0, this[t(3322)] = 0, this.tiltY = 0, this[t(2974)] = 512, this.tiltXArr = new Array(this[t(2974)])[t(1314)](0), this.tiltYArr = new Array(this[t(2974)])[t(1314)](0), this[t(865)] = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i[t(1081)](navigator.userAgent), this[t(1727)] = this[t(865)] ? 1.5 : 3, this[t(1462)] = new d0();
  }
  init(e, x, t, i, n, a) {
    const r = s;
    this[r(2863)] = e, this[r(2189)] = x, this.sceneWrapper = t, this.pointerDownCallback = i, this[r(518)] = n, this[r(1713)] = a, this[r(3545)] = this[r(2644)][r(2542)](this.activeZoneIndex), this.setupGyro(), this[r(3646)](), this[r(2809)](), this.resetCamera();
  }
  [s(1945)]() {
    const e = s;
    if (this.cameraParams[e(1717)])
      try {
        let x = new Gyroscope({ frequency: 15 });
        x[e(818)](e(3560), (t) => {
          const i = e;
          this[i(735)][i(3156)](x.y * 2), this[i(3572)].push(x.x * 2), this.tiltX = Js[i(701)](this[i(735)]), this[i(495)] = Js.average(this[i(3572)]), this[i(735)][i(3105)] > this[i(2974)] && (this[i(735)][i(465)](), this[i(3572)][i(465)]());
        }), x[e(1917)]();
      } catch (x) {
        console[e(2773)](e(1385), x);
      }
  }
  setupCamera() {
    const e = s;
    this.camera[e(3571)][e(2841)](this[e(3545)][e(1112)], 1), this[e(2189)][e(2577)](this.activeSceneZone[e(473)]), this[e(2142)](this.fitCameraOffset), this[e(3780)] && this.controls[e(3387)](), this[e(3780)] = new xi(this[e(2189)], this[e(2863)][e(482)]), this[e(3780)][e(2704)] = 0.1, this.resetControlsLimits();
  }
  [s(584)]() {
    const e = s;
    this[e(453)][e(3603)] !== !![] && (this.controls[e(1215)][e(3383)] = xi[e(1137)].ROTATE, this[e(3780)].touches[e(1309)] = xi[e(1137)][e(3043)], this[e(3780)][e(3461)] = this.controls[e(2659)] + this[e(733)], this.controls[e(1483)] = this.controls[e(2659)] - this[e(733)], this[e(3780)].maxPolarAngle = this[e(3780)][e(2017)] + this[e(733)], this[e(3780)][e(3433)] = this[e(3780)][e(2017)] - this[e(733)], this.controls.maxDistance = this.controls.distance * 2, this[e(3780)][e(1620)] = this.controls.distance * 2, this[e(1462)] = new d0(this[e(3780)][e(2659)], this.controls[e(2017)]));
  }
  setupRaycaster() {
    const e = s;
    this[e(1045)] && this[e(1045)][e(3387)]();
    const x = this[e(2644)][e(2941)](this[e(3545)][e(2235)]);
    this[e(1045)] = new lg(x, this[e(2189)], this[e(2863)].domElement), this[e(1045)][e(818)](e(2814), this.onPointerDown[e(3529)](this)), this[e(1045)][e(818)](e(3738), this[e(839)][e(3529)](this)), this.raycastManager[e(818)]("hoveroff", this[e(3243)][e(3529)](this));
  }
  [s(1429)]() {
    const e = s;
    this.activeZoneIndex += 1, this[e(2644)][e(2938)][e(3105)] <= this.activeZoneIndex && (this[e(1036)] = 0), this.changeSceneZoneByIndex(this[e(1036)]);
  }
  changeSceneZoneByIndex(e, x = 0.01) {
    const t = s, i = this[t(2644)][t(2542)](e);
    this.activeZoneIndex = e, this.changeCameraZone(i, x);
  }
  [s(3185)](e, x = 0.01) {
    const t = s, i = this[t(2644)][t(1646)](e);
    this[t(1036)] = i.index, this[t(2441)](i[t(806)], x);
  }
  [s(2441)](e, x = 0.01) {
    const t = s;
    this[t(3545)] = e;
    const i = this.fitCameraToZone(this.fitCameraOffset);
    this[t(2179)](![]), this.orbitCameraTo(e.boxCenter, e[t(473)], i, x)[t(1941)](() => {
      const n = t;
      this[n(3780)][n(3217)](), this[n(584)](), this[n(2179)](!![]);
    }), this[t(2809)]();
  }
  [s(2142)](e = 3) {
    const x = s, t = Math.max(this[x(3545)][x(854)].x, this[x(3545)][x(854)].y, this[x(3545)][x(854)].z), i = t / (2 * Math[x(3041)](Math.PI * this.camera[x(3557)] / 360)), n = i / this[x(2189)][x(2308)], a = e * Math[x(1803)](i, n), r = this[x(3545)].lookAtTarget[x(2272)]()[x(1943)](this[x(2189)].position)[x(608)]()[x(580)](a);
    return this.camera[x(3571)][x(2875)](this.activeSceneZone.lookAtTarget)[x(1943)](r), this[x(2189)].lookAt(this.activeSceneZone[x(473)]), this[x(2189)].position[x(3570)](this[x(3545)][x(473)]);
  }
  [s(2179)](e) {
    const x = s;
    this[x(2679)] = e, this[x(1045)].enabled = e, this[x(3780)].enabled = e;
  }
  [s(2067)](e) {
    const x = s;
    this.paused = e, this.enabled = !e, this[x(1045)][x(2679)] = !e;
  }
  [s(665)](e = !![]) {
    const x = s;
    this[x(2679)] && (this.moveCamera(this[x(3545)][x(1112)], e), this.setLookAt(this[x(3545)].boxCenter, this.activeSceneZone[x(473)], e), this.controls[x(2007)](e));
  }
  setDampFactor(e = 0.05) {
    const x = s;
    this.controls[x(3523)] = e * 50;
  }
  setZoom(e, x = !![]) {
    this[s(3780)].zoomTo(e, x);
  }
  [s(3488)](e, x, t = !![]) {
    const i = s;
    return this[i(3780)][i(3488)](e.x, e.y, e.z, x.x, x.y, x.z, t);
  }
  [s(1965)](e, x = !![]) {
    const t = s;
    return this[t(3780)][t(1729)](e.x, e.y, e.z, !![]);
  }
  [s(3509)](e) {
    const x = s;
    this[x(2189)][x(1690)] = e, this[x(2189)][x(1701)]();
  }
  [s(3130)](e, x, t, i = 0.04, n = !![]) {
    const a = s;
    return e = e[a(1943)](x)[a(3399)](t)[a(3026)](x), this[a(1554)](i), this.controls[a(3488)](e.x, e.y, e.z, x.x, x.y, x.z, n);
  }
  [s(1046)](e) {
    const x = s;
    e[x(1413)] === null || !this[x(2679)] || (this[x(1045)][x(2679)] = ![], this.pointerDownCallback(e[x(1413)]));
  }
  [s(839)](e) {
    const x = s;
    e[x(1413)] !== null && this[x(518)](e[x(1413)]);
  }
  [s(3243)](e) {
    const x = s;
    e[x(1413)] !== null && this[x(1713)](e[x(1413)]);
  }
  [s(1675)]() {
    const e = s;
    if (this.controls[e(3526)] || this[e(453)][e(3603)])
      return;
    const x = this.controls.currentAction == 32 || this[e(3780)][e(748)] == 1;
    let t = -1, i = 1;
    !x && (this[e(453)].followMouse && this[e(1045)][e(1331)].x && (this[e(1462)].x = this.raycastManager[e(1331)].x + this[e(3780)].azimuthAngle, this[e(1462)].y = -this[e(1045)][e(1331)].y + this[e(3780)][e(2017)], this.rotationTarget.x = Js[e(3644)](this[e(1462)].x, this[e(3780)][e(2659)] + t, this[e(3780)][e(2659)] + i, this[e(3780)].minAzimuthAngle, this.controls[e(3461)]), this[e(1462)].y = Js.map(this[e(1462)].y, this[e(3780)][e(2017)] + t, this[e(3780)][e(2017)] + i, this.controls[e(3433)], this[e(3780)][e(1192)])), this.isMobileDevice && this[e(453)][e(1717)] && (this[e(1462)].x = this[e(3322)] + this[e(3780)][e(2659)], this[e(1462)].y = this[e(495)] + this.controls[e(2017)]), this.controls[e(1118)](this.rotationTarget.x, this[e(1462)].y, ![]));
  }
  update(e) {
    const x = s;
    this.controls !== null && (this[x(1045)][x(3178)] = e * 1e3, !this.paused && (this[x(1675)](), this[x(3780)][x(3452)](e)));
  }
}
class bg {
  constructor(e, x) {
    const t = s;
    this[t(488)] = ![], this[t(1211)] = t(3316), this[t(3647)] = t(1493), this[t(2020)] = document[t(2287)](e), this.loadingScreen = document[t(2287)](x), !this[t(2020)] && console[t(533)]("iframe not found. Make sure this returns the correct element: document.getElementById(", e, t(872)), !this.loadingScreen && console[t(533)]("loadingScreen not found. Make sure this returns the correct element: document.getElementById(", x, ");  ");
  }
  [s(3174)](e, x = null) {
    const t = s;
    this[t(488)] = e, e == !![] || this.loadingScreen[t(3137)](), x != null && (this[t(1757)][t(3137)](), x());
  }
  [s(2074)](e = "", x = !![]) {
    const t = s;
    window[t(1474)][t(3583)] && x ? window[t(1474)].pushState(null, null, e) : location[t(2543)] = e;
  }
  [s(657)](e = !![]) {
    const x = s;
    this[x(488)] = e, e ? (this[x(2020)][x(1159)][x(3026)](this[x(3647)]), this[x(2020)][x(1159)].remove(this[x(1211)])) : (this[x(2020)][x(1159)][x(3026)](this[x(1211)]), this[x(2020)].classList[x(3137)](this[x(3647)]), this[x(2074)]("", ![]));
  }
  setDynamicHTML(e) {
    const x = s;
    this[x(2020)][x(1374)] = e;
  }
  [s(2946)](e) {
    const x = s;
    let t = '<div id="XYZ3d-close-btn" class="XYZ3d-close-btn"><span>✕</span';
    this[x(2020)][x(971)]("beforeend", t), t = this[x(2020)][x(3044)]("#XYZ3d-close-btn"), t[x(818)](x(3093), () => {
      this[x(657)](![]), e();
    });
  }
  [s(2715)](e, x, t) {
    const i = s;
    this[i(750)](e), this[i(2946)](x), this.pushHashURL(t);
  }
  [s(2338)](e) {
    window[s(1235)](e);
  }
  [s(3088)](e) {
    const x = s;
    this[x(2020)][x(3044)](".XYZ3d-close") && (e(), this[x(2020)][x(1374)] = "");
  }
}
class mg {
  constructor(e) {
    const x = s;
    let t = this, i = null, n, a, r, o, c, h, f = null, u, l;
    window.DEBUG = e[x(3231)];
    async function _() {
      const P = x;
      i = new og(e.domElements[P(2572)], e[P(2189)]), n = new ug(i3, e[P(2189)]), a = new bg(e[P(2411)][P(831)], e.domElements[P(3742)]), a[P(3174)](!![]);
      const S = i[P(3795)]();
      f = i[P(868)]();
      const I = i[P(1422)]();
      o = await new eg(S, I, e[P(2877)])[P(501)](($, N, V) => {
        const X = P;
        t[X(2759)] && t[X(2759)]($, N, Math.round(V));
      }), u = new za(), r = new zh(S);
      const G = o.getLoopingAnimations();
      return v(P(3551), G, !![]), n.init(I, f, o, A, b, M), a.showLoadingScreen(![], y), p(), m(), { camera: f, scene: S, renderer: I, sceneWrapper: o };
    }
    function p() {
      const P = x;
      window.onhashchange = function() {
        const S = c0;
        location[S(2543)] == "" ? a[S(3088)](y) : window.history[S(2337)] && window[S(1474)][S(2337)]();
      }, window.addEventListener(P(3534), () => {
        y();
      }, ![]);
    }
    function m() {
      const P = x;
      requestAnimationFrame(m), !a[P(488)] && (l = u[P(2781)](), r[P(3452)](l), n[P(3452)](l), i[P(489)](), t[P(1509)] && t[P(1509)](l));
    }
    function y(P = !![]) {
      const S = x;
      i[S(2007)](), n[S(665)](P);
    }
    async function v(P, S, I = ![], C = ![], G = null) {
      function $(V) {
        const X = c0;
        return Object[X(2070)](V)[X(3105)] === 0;
      }
      return $(S) === !![] || !(P in S) ? void 0 : g(S[P], G, I, C);
    }
    async function g(P, S = null, I = ![], C = ![]) {
      const G = x;
      let $ = 0;
      for (let N = 0; N < P.length; N++) {
        const V = P[N], X = r[G(2321)](V, S);
        X[G(3620)] = Ve, X[G(914)](), X[G(2007)](), X[G(2104)] = !![], X[G(2638)] = !![], !I && (X[G(2614)](w2), X[G(2007)]()), X[G(1765)] = C, X[G(1653)](), V.duration > $ && ($ = V[G(3403)]);
      }
      return new Promise((N) => setTimeout(() => {
        N();
      }, $ * 1e3));
    }
    function b(P) {
      const S = x;
      P[S(1809)] == null || !n[S(2679)] || (v(S(3021), P[S(1280)]), t[S(3393)] !== null && t.onHoverOverCallback(P));
    }
    function M(P) {
      const S = x;
      P[S(1809)] != null && t[S(3148)] !== null && t.onHoverOffCallback(P);
    }
    async function A(P) {
      const S = x;
      t[S(742)] !== null && t.onPointerDownCallback(P), n[S(2067)](!![]), r[S(3321)]();
      const I = v("camera", P[S(1280)], ![], ![], f), C = v("onClick", P[S(1280)], ![], ![]);
      await Promise[S(3029)]([I, C]);
      const G = o[S(2984)]();
      v("looping", G, !![]), L(P), n[S(2067)](![]);
    }
    function L(P) {
      const S = x;
      switch (c = P[S(1386)].contentType, h = P[S(1386)][S(1040)], c) {
        case S(2956):
          break;
        case S(1829):
          n[S(2963)](h);
          break;
        case S(2867):
          n[S(3185)](h);
          break;
        case "iframe":
          a[S(2715)](h, y), a[S(657)]();
          break;
        case S(2631):
          a[S(2338)](h), y();
          break;
      }
      h = null, c = null;
    }
    t[x(3185)] = function(P, S = 0.01) {
      n[x(3185)](P, S);
    }, t[x(1429)] = function() {
      n[x(2963)]();
    }, t.setup = _, t[x(2007)] = y, t[x(742)] = null, t[x(3393)] = null, t[x(3148)] = null, t[x(1509)] = null, t.onProgressLoading = null;
  }
}
export {
  mg as default
};
//# sourceMappingURL=xyz3d.es.js.map
