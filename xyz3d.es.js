import * as d from "https://unpkg.com/three/build/three.module.js";
import { GLTFLoader as H } from "https://unpkg.com/three@0.149.0/examples/jsm/loaders/GLTFLoader.js";
import { DRACOLoader as R } from "https://unpkg.com/three@0.149.0/examples/jsm/loaders/DRACOLoader.js";
import { RGBELoader as F } from "https://unpkg.com/three@0.149.0/examples/jsm/loaders/RGBELoader.js";
import { EXRLoader as G } from "https://unpkg.com/three@0.149.0/examples/jsm/loaders/EXRLoader.js";
import { UnrealBloomPass as X } from "https://unpkg.com/three@0.149.0/examples/jsm/postprocessing/UnrealBloomPass.js";
import { RenderPass as Y } from "https://unpkg.com/three@0.149.0/examples/jsm/postprocessing/RenderPass.js";
import { EffectComposer as W } from "https://unpkg.com/three@0.149.0/examples/jsm/postprocessing/EffectComposer.js";
import "https://unpkg.com/three@0.149.0/examples/jsm/postprocessing/ShaderPass.js";
import "https://unpkg.com/three@0.149.0/examples/jsm/shaders/FXAAShader.js";
import "https://cdn.jsdelivr.net/npm/camera-controls/dist/camera-controls.min.js";
const i = M;
(function(p, t) {
  const e = M, x = p();
  for (; []; )
    try {
      if (parseInt(e(554)) / 1 * (parseInt(e(215)) / 2) + -parseInt(e(295)) / 3 * (parseInt(e(358)) / 4) + -parseInt(e(198)) / 5 + -parseInt(e(279)) / 6 * (-parseInt(e(446)) / 7) + parseInt(e(553)) / 8 + parseInt(e(299)) / 9 + parseInt(e(377)) / 10 === t)
        break;
      x.push(x.shift());
    } catch {
      x.push(x.shift());
    }
})(D, 646457);
function D() {
  const p = ["addPointLight", "activeSceneZone", "getRandomIntRange", "play", "interactables", "1868520uBhfNP", "Cache", "cameraAnimations", "hash", "pointLight", "sub", "pointer", "pop", '"></iframe>', "Camera", "rotation", "isPostEffectsEnabled", "tracks", "backgroundBlurriness", "left", "lights", "minStaticFrames", "gyro", "two", "touch", "onHoverOffCallback", "round", "load", "atan", "jsonData", "setupCamera", "looping", "addGLTFModel", "zoomTo", "style", "castShadow", "bgMesh", "finalComposer", "hiddenSelector", "loopAnimations", "hoveroff", "WebGLRenderer", "goToNextZone", "sceneWrapper", "MAX_SAFE_INTEGER", "quaternionToVector3", "name", "defaultDampFactor", "directionalLight", "modelName", "toneMapping", "innerHTML", "visible", "_intersections", "loadModel", "loadingScreenID", "PMREMGenerator", "init", "exposure", "includes", "aspect", "fitCameraOffset", "orbit", "innerWidth", "zone", "loaded", "setZoom", "hoverOverCallback", "render", "debug", "push", "getSceneWrapper", "getCameraAnimationStart", "goToZone", "98399HUKXFe", "addAmbientLight", "random", "blendMode", "texture", "getHtml", "SpotLight", "clampWhenFinished", "getSize", "moveCamera", "getAnimations", "raycastManager", "getElementById", "updatePointer", "onProgressLoading", "wrappedAnimations", "intersectObjects", "backgroundIntensity", "addPass", "loadingScreen", "onClick", "hoveron", "fromEquirectangular", "PointLightHelper", "bloom", "getModel", "jsonPath", "rotateCamera", "scene", "followMouse", "addEXR", "position", "history", "mouseup", "min", "wrappedSceneZones", "camera", "EventDispatcher", "addDynamicCloseButton", "userAgent", "getBoundingBox", "azimuthAngle", "strength", "nextSceneZone", "getSceneZoneByName", "models", ":>> GLTF element unrecognized:", "isOverlayActive", "pointerDownCallback", "distanceTo", "getInteractableModelsByZone", "setCameraOffset", "raycastTarget", "getWrappedAnimations", "clientY", "test", "setFromCamera", "forEach", "activeZoneIndex", "loadJson", "map", "stopAllAction", ");  ", "hoverOffCallback", "getIntersectableObjects", "getInteractables", "onPointerUp", "tiltX", "_camera", "orbitCameraTo", "changeCameraZone", "onUpdate", "addEventListener", "player", "userData", "environment", "AxesHelper", "receiveShadow", "values", "open", "clientX", "width", "compileEquirectangularShader", "getCamera", "onHoverAnimations", "onClickAnimations", "material", "DEBUG", "Box3", "contentContainer", "all", "gammaFactor", "fov", "onHoverOver", "interactablesContent", "model", "normalize", "getBackgroundModelsByZone", "beforeend", "getHitObject", "rotationTarget", "layers", "path", "tiltY", "onHoverOff", "ambientLight", "XYZ3d-hidden", "2248952CGXDhv", "1wFhYbp", "Scene", "setDynamicHTML", "pushHashURL", "onhashchange", "activate", "Mesh", "changeSceneZoneByName", ".quaternion", "XYZ3d-visible", "scale", "index", "paused", "createLightContainer", "intersectableObjects", "updateSceneZones", "setDynamicContent", "PointLight", "setPaused", "click", "wrappedModels", "defaultRotationDistance", "start", "pen", "DirectionalLight", "reset", "dispatchEvent", "fill", "Clock", "fps", "average", "classList", "deactivate", "top", "lookAt", "_hovered", "currentAction", "3357375lcHhEF", "wrapScene", "ACTION", "add", "_objects", "onWindowResized", "lookAtTargetBox", "size", "pointermove", "closeDynamicContent", "content", "maxGyroSignals", "intensity", "scrollHeight", "toneMappingExposure", "getAnimation", "zeroSlopeAtStart", "670562zMLyxl", "animations", "domElements", "scrollWidth", "setupRaycaster", "gltf", "parse", "multiplyScalar", "bind", "renderer", "onPointerDown", "then", "moveTo", "processModel", "set", "raycastMesh", "maxAzimuthAngle", "fitCameraToZone", "targetPosition", "light", "Quaternion", "getSceneZoneByIndex", "Vector3", "contentType", "getScene", "getRaycastTarget", ".XYZ3d-close", "tiltXArr", "resize", "clipAction", "querySelector", "json", "threshold", "touchend", "Raycaster", "keys", "setLoop", "error", "NoBlending", "showDynamicHTML", "type", "enabled", "openLink", "ReinhardToneMapping", "transformGroup", "object", "iframe", "clone", "setupPostEffects", "onPointerDownCallback", "resetCamera", "halfWindowWidth", "EquirectangularReflectionMapping", "expandByObject", "pushState", "Vector2", "auto", "postEffects", "update", "canvasID", "enableAll", "lookAtTarget", "minPolarAngle", "addLighting", "486tQlBdk", "boxCenter", "resetControlsLimits", "domElement", "polarAngle", "showLoadingScreen", "interactable", "_domElement", "ROTATE", "lerp", "updateProjectionMatrix", "setDampFactor", "pow", "height", "link", "bloomParams", "9yfFuwO", "cursor", "active", "setModelMatrixData", "4084182AGpCXt", "setLength", "animation", "Group", "getAnimationsFromCSV", "LoopOnce", "touches", '<div id="XYZ3d-close-btn" class="XYZ3d-close-btn"><span>âœ•</span', "controls", "setDecoderPath", "minAzimuthAngle", "pointerType", "addHDR", "onHoverOverCallback", "onPointerMove", "setup", "#XYZ3d-close-btn", "setLookAt", "getHtmlData", "onHover", "children", "insertAdjacentHTML", "getRenderer", "getDelta", "removeEventListener", "bloomPass", "background", "The gryto motion sensor is not supported on this device.", "setSize", "gltfLoader", "PerspectiveCamera", "createModelContainer", "duration", "getObjects", "maxPolarAngle", "cameraParams", "getRandomRange", "canvas", "total", "tiltYArr", "nextScene", "length", "radius", "frame", "element", "addDirectionalLight", "lookAtTargetSize", "max", "getLoopingAnimations", "getCameraBoundsObject", "hdr", "target", "isMobileDevice", "iframeID", "distance", "normalBias", "gltf children :>> ", "directional", "https://unpkg.com/three@0.147.0/examples/js/libs/draco/", "1436980qQSTYC", "_selected", "setupRenderer", "log", "visibleSelector", "install", "color", "AmbientLight", "build", "reading", "getBoundingClientRect", "changeSceneZoneByIndex", "dispose", "innerHeight"];
  return D = function() {
    return p;
  }, D();
}
function M(p, t) {
  const e = D();
  return M = function(x, s) {
    return x = x - 165, e[x];
  }, M(p, t);
}
class P {
  static [i(335)](t, e) {
    return Math.random() * (e - t) + t;
  }
  static [i(374)](t, e) {
    const x = i;
    return Math[x(398)](Math[x(448)]() * (e - t) + t);
  }
  static [i(417)](t, e, x, s) {
    const o = t + t, n = e + e, a = x + x, c = t * n, l = t * a, b = e * a, f = s * o, g = s * n, A = s * a;
    return { x: c - A, y: b + f, z: l - g };
  }
  static [i(506)](t, e, x, s, o) {
    return (t - e) * (o - s) / (x - e) + s;
  }
  static [i(191)](t) {
    const e = i;
    let x = 0;
    return t[e(503)]((s) => {
      x += s;
    }), x / t[e(340)];
  }
}
class q {
  constructor(t, e, x) {
    const s = i;
    this.animations = x, this[s(491)] = t, this[s(392)] = e, this[s(181)] = { interactables: [], bg: [], player: null }, this.wrappedAnimations = { looping: [], onClick: [], onHover: [], camera: [] }, this[s(481)] = [], this[s(199)](this[s(491)]), this[s(176)](this[s(481)]);
  }
  [i(199)](t) {
    const e = i, x = { interactables: [], bgMesh: [], player: null }, s = [];
    for (let o = 0; o < t[e(340)]; o++) {
      const n = t[o], a = n.model[e(520)];
      let c = {};
      const l = this[e(456)](a, n[e(418)]);
      switch (a[e(255)]) {
        case e(285):
          c = this.getInteractableObject(n, a, l), x.interactables.push(c);
          break;
        case "cameraBounds":
          c = this.getCameraBoundsObject(n, a), s[e(442)](c);
          break;
        case e(408):
          x[e(408)][e(442)](n[e(541)]);
          break;
        case e(230):
          x[e(408)][e(442)](n[e(541)]);
          break;
        case e(519):
          x[e(519)] = n[e(541)];
          break;
      }
    }
    this.wrappedModels = x, this[e(481)] = s;
  }
  updateSceneZones(t) {
    const e = i, x = [...t];
    for (let s = 0; s < x[e(340)]; s++) {
      const o = x[s], n = o.position, a = this[e(496)](o[e(436)]);
      a[e(340)] <= 0 && this[e(543)](o[e(436)])[e(503)]((g) => {
        a.push(g);
      });
      const c = this[e(486)](a), l = new d[e(237)]();
      c.getCenter(l);
      const b = new d.Vector3();
      c[e(454)](b), x[s][e(280)] = n, x[s][e(204)] = c, x[s].lookAtTargetSize = b, x[s].lookAtTarget = l;
    }
    this[e(481)] = x;
  }
  [i(236)](t) {
    const e = i;
    let x = null;
    return this[e(481)][e(503)]((s) => {
      s[e(172)] === t && (x = s);
    }), x;
  }
  [i(490)](t) {
    const e = i;
    let x = null, s = null;
    return this[e(481)][e(503)]((o) => {
      o.zone === t && (x = o);
    }), { zoneBox: x, index: s };
  }
  getLoopingAnimations() {
    const t = i, e = { looping: [] };
    return this[t(461)][t(403)][t(503)]((x) => {
      const s = t;
      x[s(216)].forEach((o) => {
        const n = s;
        e[n(403)][n(442)](o);
      });
    }), e;
  }
  [i(499)]() {
    return this[i(461)];
  }
  getPlayer() {
    return this[i(181)].player;
  }
  [i(511)]() {
    const t = i;
    return this[t(181)][t(376)];
  }
  getInteractablesByZone(t) {
    const e = i, x = [];
    for (let s = 0; s < this[e(181)][e(376)][e(340)]; s++) {
      const o = this[e(181)][e(376)][s];
      o.zone === t && x[e(442)](o);
    }
    return x;
  }
  getInteractableModelsByZone(t) {
    const e = i, x = [];
    for (let s = 0; s < this[e(181)][e(376)][e(340)]; s++) {
      const o = this[e(181)].interactables[s];
      o[e(436)] === t && x[e(442)](o[e(343)].model);
    }
    return x;
  }
  [i(543)](t) {
    const e = i, x = [];
    for (let s = 0; s < this[e(181)][e(408)].length; s++) {
      const o = this.wrappedModels[e(408)][s];
      o[e(255)] === e(302) ? o[e(319)][e(503)]((n) => {
        const a = e;
        o[a(520)].zone === t && x[a(442)](n);
      }) : o[e(520)][e(436)] === t && x[e(442)](o);
    }
    return x;
  }
  [i(486)](t) {
    const e = i, x = new d[e(534)]();
    t[e(255)] === e(302) && (t = [...t[e(319)]]);
    for (let s = 0; s < t[e(340)]; s++) {
      const o = t[s];
      x[e(268)](o);
    }
    return x;
  }
  getModel(t) {
    const e = i;
    for (let x = 0; x < this[e(491)][e(340)]; x++) {
      const s = this[e(491)][x][e(541)];
      if (s[e(418)] === t)
        return s;
    }
    return null;
  }
  [i(213)](t) {
    const e = i;
    for (let x = 0; x < this[e(216)][e(340)]; x++) {
      const s = this.animations[x];
      if (s[e(418)] === t)
        return s;
    }
    return null;
  }
  [i(303)](t) {
    const e = i, x = t.split(","), s = [];
    for (let o = 0; o < x[e(340)]; o++) {
      const n = x[o];
      s[e(442)](this[e(213)](n));
    }
    return s;
  }
  getAnimationTrack(t, e) {
    const x = i;
    for (let s = 0; s < t[x(389)][x(340)]; s++)
      if (t[x(389)][s].name === e)
        return t[x(389)][s];
    return null;
  }
  [i(444)](t) {
    const e = i, x = { position: null, rotation: null };
    for (let s = 0; s < t[e(482)][e(340)]; s++) {
      const o = t[e(482)][s];
      for (let n = 0; n < o[e(389)].length; n++) {
        const a = o[e(389)][n];
        if (a[e(418)][e(431)](".position"))
          x.position = new d[e(237)](a[e(524)][0], a.values[1], a[e(524)][2]);
        else if (a.name[e(431)](e(169))) {
          const c = new d[e(235)](a.values[0], a.values[1], a[e(524)][2], a[e(524)][3]);
          x[e(387)] = c;
        }
      }
    }
    return x;
  }
  [i(456)](t, e) {
    const x = i;
    let s = null, o = null, n = null, a = null;
    return x(411) in t && (s = this.getAnimationsFromCSV(t[x(411)]), this[x(461)].looping[x(442)]({ name: e, animations: s })), "onClickAnimations" in t && (o = this[x(303)](t.onClickAnimations), this.wrappedAnimations.onClick[x(442)]({ name: e, animations: o })), x(530) in t && (n = this[x(303)](t[x(530)]), this[x(461)].onHover.push({ name: e, animations: n })), x(379) in t && (a = this.getAnimationsFromCSV(t[x(379)]), this.wrappedAnimations[x(482)][x(442)]({ name: e, animations: a })), { loopAnimations: s, onHoverAnimations: n, onClickAnimations: o, cameraAnimations: a };
  }
  getInteractableObject(t, e, x) {
    const s = i, o = this.getRaycastTarget(e[s(498)]), n = { name: t[s(418)], raycastTarget: o, element: t, animations: {}, zone: e.zone };
    return x[s(530)] !== null && (n.animations[s(318)] = x[s(530)]), x[s(531)] !== null && (n[s(216)].onClick = x[s(531)]), x[s(379)] !== null && (n[s(216)][s(482)] = x[s(379)]), n;
  }
  [i(348)](t, e) {
    const x = i, s = { zone: e[x(436)], index: parseInt(e.index, 10), position: t[x(541)].position };
    return t[x(541)][x(424)] = ![], s;
  }
  [i(240)](t) {
    const e = i, x = this[e(471)](t);
    return x == null ? (console[e(361)]("Missing raycast target for: ", t), null) : (x[e(532)].side = d.BackSide, x[e(532)][e(424)] = ![], x);
  }
}
class U {
  async [i(221)](t) {
    const e = i;
    let x = null;
    return await fetch(t)[e(226)]((s) => s[e(246)]())[e(226)]((s) => {
      x = s;
    }), x;
  }
}
class N {
  constructor(t, e, x) {
    const s = i;
    this.scene = t, this[s(224)] = e, this[s(472)] = x, this[s(415)];
    const o = new R();
    if (o[s(308)](s(357)), this[s(328)] = new H(), this.gltfLoader.setDRACOLoader(o), window[s(533)]) {
      const n = new d[s(522)](5e3);
      this[s(474)][s(201)](n);
    }
  }
  [i(443)]() {
    return this[i(415)];
  }
  async [i(505)]() {
    const t = i;
    return await new U()[t(221)](this[t(472)]);
  }
  async [i(366)](t) {
    const e = i, x = await this[e(505)](), s = [], o = [], n = await this.addGLTFModel(x[e(491)], t), a = this[e(278)](x[e(392)]);
    return a[e(442)](...n[e(392)]), s[e(442)](...n[e(491)]), o[e(442)](...n.animations), this[e(415)] = new q(s, a, o), this.sceneWrapper;
  }
  async [i(404)](t, e) {
    const x = i, s = [], o = [], n = [];
    for (let a = 0; a < t[x(340)]; a++) {
      const c = t[a], l = function(b) {
        const f = x;
        e(a + 1, t.length, 100 * b[f(437)] / b[f(337)]);
      };
      await this.loadModel(c, l).then((b) => {
        const f = x;
        window[f(533)] && console[f(361)](f(355), [...b[f(220)][f(474)][f(319)]]);
        const g = this[f(228)](b);
        s.push(...g[f(491)]), o.push(...g[f(392)]), n[f(442)](...g.animations);
      });
    }
    return { models: s, lights: o, animations: n };
  }
  [i(471)](t, e) {
    const x = i;
    for (let s = 0; s < t.length; s++) {
      const o = t[s];
      if (o[x(418)] === e)
        return o;
    }
    return null;
  }
  [i(330)](t, e) {
    const x = i, s = { name: t[x(418)], model: t };
    switch (this[x(298)](t, e), t[x(407)] = e.castShadow, t[x(523)] = e.receiveShadow, t[x(520)].type) {
      case x(408):
        break;
      case "interactable":
        const o = this[x(451)](e, t[x(418)]);
        s[x(238)] = o[x(255)], s[x(208)] = o[x(208)];
        break;
    }
    return s;
  }
  createLightContainer(t, e) {
    return { type: t, light: e };
  }
  processModel(t) {
    const e = i, x = [...t[e(220)].scene[e(319)]], s = t[e(220)][e(216)], o = [], n = [], a = 1e5;
    for (let c = 0; c < x[e(340)]; c++) {
      const l = x[c];
      switch (l[e(547)].enableAll(), l[e(255)]) {
        case e(167):
          o[e(442)](this.createModelContainer(l, t.jsonData));
          break;
        case e(302):
          l[e(319)][e(503)]((b) => {
            this.setModelMatrixData(b, t.jsonData);
          }), o[e(442)](this[e(330)](l, t.jsonData));
          break;
        case "Object3D":
          o.push(this.createModelContainer(l, t[e(401)]));
          break;
        case "PointLight":
          l.intensity /= a, n[e(442)](this[e(174)]("point", l));
          break;
        case "DirectionalLight":
          l[e(210)] /= a, n[e(442)](this[e(174)](e(356), l));
          break;
        case e(452):
          l.intensity /= a, n[e(442)](this[e(174)]("spot", l));
          break;
        default:
          console[e(361)](e(492), l);
          break;
      }
      this[e(474)][e(201)](l);
    }
    return { models: o, lights: n, animations: s };
  }
  [i(298)](t, e) {
    const x = i;
    t[x(477)][x(229)](t[x(477)].x + e[x(477)].x, t[x(477)].y + e.position.y, t[x(477)].z + e[x(477)].z), t.quaternion[x(229)](e.rotation.x, e[x(387)].y, e[x(387)].z, e[x(387)].w), t[x(171)][x(229)](e[x(171)].x, e[x(171)].y, e[x(171)].z);
  }
  [i(451)](t, e) {
    const x = i, s = this[x(317)](t, e);
    if (s[x(208)] !== void 0)
      return s.type === "iframe" && (s[x(208)] = '<iframe id="XYZ3d-fullscreen" src="' + s[x(208)] + x(385)), s;
  }
  getHtmlData(t, e) {
    const x = i, s = t[x(540)];
    for (let o = 0; o < s.length; o++) {
      const n = s[o];
      if (n[x(421)] === e)
        return n;
    }
    return null;
  }
  async [i(426)](t, e) {
    return new Promise((x) => {
      const s = M;
      return this[s(328)].load(".." + t[s(548)], function(o) {
        x({ gltf: o, jsonData: t });
      }, e, function(o) {
        console[s(361)]("An error happened " + o);
      });
    });
  }
  [i(278)](t) {
    const e = i, x = [];
    for (let s = 0; s < t[e(340)]; s++) {
      const o = t[s];
      let n, a;
      const c = { type: null, light: null };
      switch (o[e(255)]) {
        case e(349):
          this[e(311)](o[e(548)], o[e(463)], o.backgroundBlurriness);
          break;
        case "exr":
          this[e(476)](o.path, o[e(463)], o[e(390)]);
          break;
        case e(381):
          n = new d[e(237)](o[e(477)].x, o[e(477)].y, o[e(477)].z), a = this[e(372)](n, o[e(364)], o[e(210)], o[e(205)], o[e(407)]), c[e(255)] = e(381), c.light = a;
          break;
        case e(420):
          n = new d[e(237)](o[e(477)].x, o[e(477)].y, o[e(477)].z);
          const l = new d[e(237)](o.target.x, o[e(350)].y, o[e(350)].z);
          a = this.addDirectionalLight(n, l, o[e(364)], o[e(210)], o[e(407)]), c[e(255)] = e(420), c[e(234)] = a;
          break;
        case e(551):
          a = this[e(447)](o.color, o.intensity), c[e(255)] = "ambientLight", c.light = a;
          break;
      }
      x.push(c);
    }
    return x;
  }
  addPointLight(t, e = 0, x = 1, s = 1500, o = ![]) {
    const n = i, a = new d[n(178)](e, x, s);
    if (a.position[n(288)](t, 1), a[n(407)] = o, a[n(354)] = 0.1, this[n(474)].add(a), window[n(533)]) {
      const c = new d[n(469)](a, 0.25);
      this[n(474)][n(201)](c);
    }
    return a;
  }
  [i(447)](t = 0, e = 1) {
    const x = i, s = new d[x(365)](t, e);
    return this[x(474)][x(201)](s), s;
  }
  [i(344)](t, e = new d[i(237)](0, 0, 0), x = 16777215, s = 2, o = ![]) {
    const n = i, a = new d[n(185)](x, s);
    if (a[n(477)][n(288)](t, 1), a[n(350)].position[n(288)](e, 1), a.castShadow = o, a.normalBias = 0.1, this[n(474)][n(201)](a), this[n(474)][n(201)](a[n(350)]), window[n(533)]) {
      const c = new d.DirectionalLightHelper(a);
      this[n(474)][n(201)](c);
    }
    return a;
  }
  [i(311)](t, e, x) {
    const s = i, o = new d[s(428)](this[s(224)]);
    o[s(528)]();
    let n;
    new F()[s(399)](".." + t, (a) => {
      const c = s;
      n = o.fromEquirectangular(a)[c(450)], this[c(474)].environment = n, this[c(474)][c(325)] = n, this[c(474)][c(463)] = e, this[c(474)].backgroundBlurriness = x, a[c(370)](), o.dispose();
    });
  }
  [i(476)](t, e, x) {
    const s = i, o = new d[s(428)](this[s(224)]);
    o.compileEquirectangularShader();
    let n;
    new G()[s(399)](".." + t, (a) => {
      const c = s;
      a.mapping = d[c(267)], n = o[c(468)](a).texture, this.scene[c(521)] = n, this[c(474)][c(325)] = n, this[c(474)][c(463)] = e, this[c(474)][c(390)] = x, a.dispose(), o[c(370)]();
    });
  }
}
class V {
  constructor(t, e) {
    const x = i;
    d[x(378)][x(256)] = !![], this.canvas = document[x(458)](t), !this[x(336)] && console[x(252)]("Canvas not found. Make sure this returns the correct element: document.GetElementByID(", t, x(508)), this.cameraParams = e, this[x(294)] = e[x(272)][x(470)], this[x(527)] = this.canvas.scrollWidth, this.height = this[x(336)].scrollHeight, this[x(482)] = new d[x(329)](this[x(334)][x(538)], this[x(527)] / this[x(292)], 0.1, 1e4), this[x(482)][x(418)] = x(386), this[x(474)] = new d[x(555)](), this[x(224)], this[x(409)], this[x(324)], this[x(388)] = e[x(272)][x(256)], this[x(360)](), this[x(388)] && this[x(263)]();
  }
  [i(529)]() {
    return this.camera;
  }
  [i(239)]() {
    return this[i(474)];
  }
  [i(321)]() {
    return this.renderer;
  }
  [i(360)]() {
    const t = i;
    this[t(224)] = new d[t(413)]({ canvas: this[t(336)], antialias: !![], powerPreference: "high-performance", failIfMajorPerformanceCaveat: !![] }), this[t(224)].shadowMap.enabled = !![], this[t(482)][t(547)][t(275)](), this[t(224)][t(327)](this.width, this[t(292)]), this.renderer[t(422)] = d[t(258)], this[t(224)][t(212)] = Math[t(291)](this[t(294)][t(430)], 4), this[t(224)][t(537)] = 4;
  }
  setupPostEffects() {
    const t = i, e = new Y(this[t(474)], this.camera), x = new X(new d.Vector2(this[t(527)], this.height), this.bloomParams.strength, this[t(294)][t(341)], this[t(294)][t(247)]);
    x.exposure = this[t(294)].exposure, x[t(247)] = this.bloomParams[t(247)], x[t(488)] = this[t(294)][t(488)], x[t(341)] = this.bloomParams.radius, this[t(409)] = new W(this[t(224)]), this[t(409)][t(327)](this[t(527)], this[t(292)]), this[t(409)][t(464)](e), this[t(409)][t(464)](x);
  }
  [i(203)]() {
    const t = i;
    this[t(527)] = this[t(336)][t(218)], this[t(292)] = this[t(336)][t(211)], this[t(482)][t(432)] = this.width / this.height, this[t(482)][t(289)](), this[t(224)][t(327)](this.width, this[t(292)]), this[t(388)] && this[t(409)].setSize(this[t(527)], this[t(292)]);
  }
  [i(186)]() {
    this[i(203)]();
  }
  render() {
    const t = i;
    this[t(388)] ? this[t(409)][t(440)]() : this[t(224)].render(this[t(474)], this[t(482)]);
  }
}
const L = new d[i(249)]();
class Q extends d[i(483)] {
  constructor(t, e, x) {
    const s = i;
    super(), this[s(202)] = t, this[s(514)] = e, this[s(286)] = x, this._selected = null, this._hovered = null, this._intersections = [], this.fps = 30, this.enabled = !![], this[s(259)] = ![], this[s(266)] = window[s(435)] / 2, this[s(266)] = window[s(371)] / 2, this.frame = 0, this[s(393)] = this[s(190)], this[s(175)] = this[s(510)](this[s(202)]), this[s(383)] = new d.Vector2(), this[s(313)] = (o) => {
      const n = s;
      if (this.enabled !== ![] && (this[n(342)] += 1, this[n(342)] > Number[n(416)] && (this[n(342)] = 0), this[n(459)](o), L[n(502)](this[n(383)], this[n(514)]), this.intersectableObjects == null && (this.intersectableObjects = getIntersectableObjects(this[n(202)])), o[n(310)] === "mouse" || o[n(310)] === n(184) || o[n(310)] === n(396)))
        if (this[n(425)][n(340)] = 0, L[n(502)](this[n(383)], this._camera), L[n(462)](this[n(175)], ![], this[n(425)]), this[n(425)][n(340)] > 0) {
          let a = this[n(425)][0][n(260)];
          a = this[n(545)](a[n(418)]), this[n(196)] !== a && this[n(196)] !== null && (this[n(187)]({ type: "hoveroff", object: this[n(196)] }), this[n(286)].style[n(296)] = "auto", this[n(196)] = null), this[n(196)] !== a && (this[n(187)]({ type: "hoveron", object: a }), this[n(286)][n(406)][n(296)] = n(383), this[n(196)] = a);
        } else
          this._hovered !== null && (this.dispatchEvent({ type: n(412), object: this[n(196)] }), this[n(286)][n(406)].cursor = n(271), this[n(196)] = null);
    }, this.onPointerUp = (o) => {
      const n = s;
      if (this.enabled !== ![] && !(typeof o === TouchEvent && o[n(305)][n(340)] > 1)) {
        if (this[n(342)] > Math[n(480)](this[n(190)] * 2, 20)) {
          this[n(342)] = 0;
          return;
        }
        if (this.frame = 0, (this.intersectableObjects == null || this.intersectableObjects == null) && (this[n(175)] = getIntersectableObjects(this._objects)), this[n(286)].style.touchAction = "none", this[n(459)](o), this[n(425)].length = 0, L[n(502)](this[n(383)], this[n(514)]), L[n(462)](this[n(175)], ![], this[n(425)]), this._intersections[n(340)] > 0) {
          const a = this[n(425)][0][n(260)];
          this[n(359)] = this[n(545)](a[n(418)]), this[n(187)]({ type: "pointerdown", object: this[n(359)] }), this[n(196)] = this[n(359)];
        }
      }
    }, this[s(166)]();
  }
  activate() {
    const t = i;
    this[t(286)][t(518)](t(206), this.onPointerMove), this[t(286)][t(518)](t(248), this[t(512)]), this[t(286)][t(518)](t(479), this[t(512)]);
  }
  [i(193)]() {
    const t = i;
    this[t(286)][t(323)](t(206), this.onPointerMove), this._domElement[t(323)]("touchend", this[t(512)]), this[t(286)][t(323)](t(479), this[t(512)]), this._domElement.style[t(296)] = "";
  }
  [i(459)](t) {
    const e = i, x = this._domElement[e(368)]();
    this[e(383)].x = (t[e(526)] - x[e(391)]) / x.width * 2 - 1, this[e(383)].y = -(t[e(500)] - x[e(194)]) / x[e(292)] * 2 + 1;
  }
  [i(370)]() {
    this[i(193)]();
  }
  [i(332)]() {
    return this[i(202)];
  }
  [i(510)](t) {
    const e = i, x = [];
    for (let s = 0; s < t[e(340)]; s++) {
      const o = t[s];
      x[e(442)](o[e(498)]);
    }
    return x;
  }
  [i(545)](t) {
    const e = i;
    for (let x = 0; x < this[e(202)].length; x++) {
      const s = this[e(202)][x];
      if (s[e(498)].name === t)
        return s;
    }
    return null;
  }
}
class J {
  constructor(t, e) {
    const x = i;
    CameraControls[x(363)]({ THREE: t }), this[x(256)] = !![], this[x(173)] = ![], this[x(457)], this[x(307)], this[x(482)], this[x(233)], this[x(494)], this.sceneWrapper, this.activeSceneZone, this[x(419)] = 0.05, this.defaultRotationDistance = 0.05, this[x(334)] = e, this[x(504)] = 0, this[x(513)] = 0, this.tiltY = 0, this[x(209)] = 512, this[x(242)] = new Array(this.maxGyroSignals)[x(188)](0), this.tiltYArr = new Array(this[x(209)]).fill(0), this.isMobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i[x(501)](navigator[x(485)]), this.fitCameraOffset = this.isMobileDevice ? 1.5 : 3, this[x(546)] = new d[x(270)]();
  }
  [i(429)](t, e, x, s, o, n) {
    const a = i;
    this.renderer = t, this.camera = e, this[a(415)] = x, this.pointerDownCallback = s, this.hoverOverCallback = o, this[a(509)] = n, this[a(373)] = this[a(415)][a(236)](this[a(504)]), this.setupGyro(), this[a(402)](), this[a(219)](), this[a(265)]();
  }
  setupGyro() {
    const t = i;
    if (this[t(334)][t(394)])
      try {
        let e = new Gyroscope({ frequency: 15 });
        e[t(518)](t(367), (x) => {
          const s = t;
          this.tiltXArr[s(442)](e.y * 2), this.tiltYArr[s(442)](e.x * 2), this[s(513)] = P[s(191)](this[s(242)]), this[s(549)] = P[s(191)](this[s(338)]), this[s(242)][s(340)] > this[s(209)] && (this[s(242)][s(384)](), this.tiltYArr[s(384)]());
        }), e[t(183)]();
      } catch (e) {
        console.log(t(326), e);
      }
  }
  [i(402)]() {
    const t = i;
    this[t(482)].position.lerp(this[t(373)][t(280)], 1), this[t(482)][t(195)](this[t(373)].lookAtTarget), this[t(232)](this[t(433)]), this[t(307)] && this[t(307)][t(370)](), this.controls = new CameraControls(this.camera, this[t(224)][t(282)]), this.controls.restThreshold = 0.1, this[t(281)]();
  }
  [i(281)]() {
    const t = i;
    this[t(334)][t(434)] !== !![] && (this[t(307)].mouseButtons.right = CameraControls[t(200)][t(287)], this[t(307)][t(305)][t(395)] = CameraControls.ACTION.TOUCH_ZOOM, this.controls[t(231)] = this.controls[t(487)] + this[t(182)], this[t(307)].minAzimuthAngle = this.controls[t(487)] - this[t(182)], this[t(307)][t(333)] = this[t(307)].polarAngle + this[t(182)], this[t(307)][t(277)] = this.controls.polarAngle - this[t(182)], this[t(307)].maxDistance = this[t(307)][t(353)] * 2, this[t(307)].maxZoom = this[t(307)][t(353)] * 2, this[t(546)] = new d.Vector2(this[t(307)].azimuthAngle, this[t(307)][t(283)]));
  }
  [i(219)]() {
    const t = i;
    this[t(457)] && this[t(457)][t(370)]();
    const e = this.sceneWrapper.getInteractablesByZone(this.activeSceneZone.zone);
    this[t(457)] = new Q(e, this[t(482)], this[t(224)].domElement), this[t(457)][t(518)]("pointerdown", this[t(225)][t(223)](this)), this[t(457)][t(518)](t(467), this[t(539)][t(223)](this)), this[t(457)][t(518)]("hoveroff", this[t(550)][t(223)](this));
  }
  nextSceneZone() {
    const t = i;
    this.activeZoneIndex += 1, this[t(415)][t(481)].length <= this[t(504)] && (this.activeZoneIndex = 0), this[t(369)](this[t(504)]);
  }
  [i(369)](t, e = 0.01) {
    const x = i, s = this[x(415)][x(236)](t);
    this[x(504)] = t, this[x(516)](s, e);
  }
  [i(168)](t, e = 0.01) {
    const x = i, s = this.sceneWrapper[x(490)](t);
    this.activeZoneIndex = s[x(172)], this[x(516)](s.zoneBox, e);
  }
  [i(516)](t, e = 0.01) {
    const x = i;
    this.activeSceneZone = t;
    const s = this[x(232)](this.fitCameraOffset);
    this.setInputActive(![]), this.orbitCameraTo(t.boxCenter, t[x(276)], s, e).then(() => {
      const o = x;
      this[o(307)].saveState(), this[o(281)](), this.setInputActive(!![]);
    }), this[x(219)]();
  }
  fitCameraToZone(t = 3) {
    const e = i, x = Math[e(346)](this[e(373)][e(345)].x, this[e(373)][e(345)].y, this[e(373)][e(345)].z), s = x / (2 * Math[e(400)](Math.PI * this[e(482)].fov / 360)), o = s / this.camera[e(432)], n = t * Math[e(346)](s, o), a = this[e(373)][e(276)][e(262)]()[e(382)](this.camera.position)[e(542)]()[e(222)](n);
    return this.camera[e(477)].copy(this[e(373)].lookAtTarget).sub(a), this[e(482)].lookAt(this.activeSceneZone[e(276)]), this.camera[e(477)][e(495)](this[e(373)][e(276)]);
  }
  setInputActive(t) {
    const e = i;
    this[e(256)] = t, this[e(457)][e(256)] = t, this.controls[e(256)] = t;
  }
  [i(179)](t) {
    const e = i;
    this[e(173)] = t, this[e(256)] = !t, this[e(457)].enabled = !t;
  }
  [i(265)](t = !![]) {
    const e = i;
    this.enabled && (this[e(455)](this.activeSceneZone.boxCenter, t), this.setLookAt(this[e(373)][e(280)], this[e(373)].lookAtTarget, t), this[e(307)][e(186)](t));
  }
  [i(290)](t = 0.05) {
    const e = i;
    this[e(307)].smoothTime = t * 50;
  }
  [i(438)](t, e = !![]) {
    const x = i;
    this[x(307)][x(405)](t, e);
  }
  setLookAt(t, e, x = !![]) {
    const s = i;
    return this.controls[s(316)](t.x, t.y, t.z, e.x, e.y, e.z, x);
  }
  [i(455)](t, e = !![]) {
    const x = i;
    return this[x(307)][x(227)](t.x, t.y, t.z, !![]);
  }
  [i(497)](t) {
    const e = i;
    this[e(482)].filmOffset = t, this[e(482)].updateProjectionMatrix();
  }
  [i(515)](t, e, x, s = 0.04, o = !![]) {
    const n = i;
    return t = t[n(382)](e)[n(300)](x)[n(201)](e), this[n(290)](s), this.controls[n(316)](t.x, t.y, t.z, e.x, e.y, e.z, o);
  }
  onPointerDown(t) {
    const e = i;
    t[e(260)] === null || !this[e(256)] || (this.raycastManager[e(256)] = ![], this[e(494)](t[e(260)]));
  }
  [i(539)](t) {
    const e = i;
    t.object !== null && this[e(439)](t[e(260)]);
  }
  [i(550)](t) {
    const e = i;
    t[e(260)] !== null && this[e(509)](t[e(260)]);
  }
  [i(473)]() {
    const t = i;
    if (this.controls[t(297)] || this[t(334)].orbit)
      return;
    const e = this[t(307)].currentAction == 32 || this.controls[t(197)] == 1;
    let x = -1, s = 1;
    !e && (this[t(334)][t(475)] && this.raycastManager[t(383)].x && (this[t(546)].x = this[t(457)][t(383)].x + this[t(307)][t(487)], this[t(546)].y = -this[t(457)][t(383)].y + this[t(307)][t(283)], this[t(546)].x = P.map(this[t(546)].x, this.controls[t(487)] + x, this[t(307)][t(487)] + s, this.controls[t(309)], this.controls[t(231)]), this[t(546)].y = P[t(506)](this[t(546)].y, this[t(307)][t(283)] + x, this[t(307)][t(283)] + s, this[t(307)][t(277)], this[t(307)][t(333)])), this[t(351)] && this[t(334)][t(394)] && (this[t(546)].x = this.tiltX + this[t(307)][t(487)], this[t(546)].y = this.tiltY + this[t(307)][t(283)]), this.controls.rotateTo(this[t(546)].x, this[t(546)].y, ![]));
  }
  [i(273)](t) {
    const e = i;
    this.controls !== null && (this[e(457)][e(190)] = t * 1e3, !this[e(173)] && (this[e(473)](), this[e(307)][e(273)](t)));
  }
}
class K {
  constructor(t, e) {
    const x = i;
    this[x(493)] = ![], this[x(410)] = x(552), this.visibleSelector = x(170), this[x(535)] = document[x(458)](t), this.loadingScreen = document.getElementById(e), !this[x(535)] && console[x(252)]("iframe not found. Make sure this returns the correct element: document.getElementById(", t, x(508)), !this[x(465)] && console[x(252)]("loadingScreen not found. Make sure this returns the correct element: document.getElementById(", e, x(508));
  }
  [i(284)](t, e = null) {
    const x = i;
    this[x(493)] = t, t == !![] || this.loadingScreen.remove(), e != null && (this[x(465)].remove(), e());
  }
  pushHashURL(t = "", e = !![]) {
    const x = i;
    window.history[x(269)] && e ? window[x(478)][x(269)](null, null, t) : location[x(380)] = t;
  }
  [i(254)](t = !![]) {
    const e = i;
    this[e(493)] = t, t ? (this.contentContainer[e(192)].add(this[e(362)]), this.contentContainer[e(192)].remove(this.hiddenSelector)) : (this[e(535)][e(192)][e(201)](this.hiddenSelector), this.contentContainer.classList.remove(this[e(362)]), this.pushHashURL("", ![]));
  }
  setDynamicHTML(t) {
    const e = i;
    this[e(535)][e(423)] = t;
  }
  addDynamicCloseButton(t) {
    const e = i;
    let x = e(306);
    this[e(535)][e(320)](e(544), x), x = this[e(535)].querySelector(e(315)), x[e(518)](e(180), () => {
      this.showDynamicHTML(![]), t();
    });
  }
  [i(177)](t, e, x) {
    const s = i;
    this[s(556)](t), this[s(484)](e), this[s(557)](x);
  }
  [i(257)](t) {
    window[i(525)](t);
  }
  [i(207)](t) {
    const e = i;
    this[e(535)][e(245)](e(241)) && (t(), this.contentContainer[e(423)] = "");
  }
}
class rt {
  constructor(t) {
    const e = i;
    let x = this, s = null, o, n, a, c, l, b, f = null, g, A;
    window[e(533)] = t[e(441)];
    async function E() {
      const r = e;
      s = new V(t[r(217)][r(274)], t[r(482)]), o = new J(d, t[r(482)]), n = new K(t[r(217)][r(352)], t.domElements[r(427)]), n[r(284)](!![]);
      const h = s[r(239)]();
      f = s[r(529)]();
      const _ = s[r(321)]();
      c = await new N(h, _, t[r(472)])[r(366)]((y, w, v) => {
        const m = r;
        x[m(460)] && x[m(460)](y, w, Math.round(v));
      }), g = new d[r(189)](), a = new d.AnimationMixer(h);
      const u = c[r(347)]();
      return S("looping", u, !![]), o.init(_, f, c, Z, O, z), n.showLoadingScreen(![], C), I(), T(), { camera: f, scene: h, renderer: _, sceneWrapper: c };
    }
    function I() {
      const r = e;
      window[r(165)] = function() {
        const h = r;
        location.hash == "" ? n[h(207)](C) : window.history.back && window[h(478)].back();
      }, window[r(518)](r(243), () => {
        C();
      }, ![]);
    }
    function T() {
      const r = e;
      requestAnimationFrame(T), !n[r(493)] && (A = g[r(322)](), a[r(273)](A), o[r(273)](A), s[r(440)](), x.onUpdate && x.onUpdate(A));
    }
    function C(r = !![]) {
      const h = e;
      s[h(186)](), o[h(265)](r);
    }
    async function S(r, h, _ = ![], k = ![], u = null) {
      function y(v) {
        const m = M;
        return Object[m(250)](v)[m(340)] === 0;
      }
      return y(h) === !![] || !(r in h) ? void 0 : B(h[r], u, _, k);
    }
    async function B(r, h = null, _ = ![], k = ![]) {
      const u = e;
      let y = 0;
      for (let w = 0; w < r.length; w++) {
        const v = r[w], m = a[u(244)](v, h);
        m[u(449)] = d[u(253)], m.stop(), m[u(186)](), m.zeroSlopeAtEnd = !![], m[u(214)] = !![], !_ && (m[u(251)](d[u(304)]), m.reset()), m[u(453)] = k, m[u(375)](), v[u(331)] > y && (y = v[u(331)]);
      }
      return new Promise((w) => setTimeout(() => {
        w();
      }, y * 1e3));
    }
    function O(r) {
      const h = e;
      r.raycastTarget == null || !o[h(256)] || (S(h(318), r[h(216)]), x[h(312)] !== null && x[h(312)](r));
    }
    function z(r) {
      const h = e;
      r[h(498)] != null && x[h(397)] !== null && x[h(397)](r);
    }
    async function Z(r) {
      const h = e;
      x.onPointerDownCallback !== null && x[h(264)](r), o[h(179)](!![]), a[h(507)]();
      const _ = S("camera", r[h(216)], ![], ![], f), k = S(h(466), r[h(216)], ![], ![]);
      await Promise[h(536)]([_, k]);
      const u = c[h(347)]();
      S(h(403), u, !![]), j(r), o.setPaused(![]);
    }
    function j(r) {
      const h = e;
      switch (l = r[h(343)][h(238)], b = r[h(343)].content, l) {
        case h(301):
          break;
        case h(414):
          o[h(339)](b);
          break;
        case h(445):
          o[h(168)](b);
          break;
        case h(261):
          n.setDynamicContent(b, C), n[h(254)]();
          break;
        case h(293):
          n.openLink(b), C();
          break;
      }
      b = null, l = null;
    }
    x[e(168)] = function(r, h = 0.01) {
      o[e(168)](r, h);
    }, x[e(489)] = function() {
      o[e(339)]();
    }, x[e(314)] = E, x.reset = C, x[e(264)] = null, x[e(312)] = null, x[e(397)] = null, x[e(517)] = null, x.onProgressLoading = null;
  }
}
export {
  rt as default
};
